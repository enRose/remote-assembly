"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@react-stately";
exports.ids = ["vendor-chunks/@react-stately"];
exports.modules = {

/***/ "(ssr)/./node_modules/@react-stately/checkbox/dist/import.mjs":
/*!**************************************************************!*\
  !*** ./node_modules/@react-stately/checkbox/dist/import.mjs ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useCheckboxGroupState: () => (/* binding */ $587d3ad58be6d31f$export$daff6da51032a415)\n/* harmony export */ });\n/* harmony import */ var _react_stately_form__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @react-stately/form */ \"(ssr)/./node_modules/@react-stately/form/dist/import.mjs\");\n/* harmony import */ var _react_stately_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @react-stately/utils */ \"(ssr)/./node_modules/@react-stately/utils/dist/import.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ function $587d3ad58be6d31f$export$daff6da51032a415(props = {}) {\n    let [selectedValues, setValue] = (0, _react_stately_utils__WEBPACK_IMPORTED_MODULE_1__.useControlledState)(props.value, props.defaultValue || [], props.onChange);\n    let isRequired = !!props.isRequired && selectedValues.length === 0;\n    let invalidValues = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)(new Map());\n    let validation = (0, _react_stately_form__WEBPACK_IMPORTED_MODULE_2__.useFormValidationState)({\n        ...props,\n        value: selectedValues\n    });\n    let isInvalid = validation.displayValidation.isInvalid;\n    var _props_validationState;\n    const state = {\n        ...validation,\n        value: selectedValues,\n        setValue (value) {\n            if (props.isReadOnly || props.isDisabled) return;\n            setValue(value);\n        },\n        isDisabled: props.isDisabled || false,\n        isReadOnly: props.isReadOnly || false,\n        isSelected (value) {\n            return selectedValues.includes(value);\n        },\n        addValue (value) {\n            if (props.isReadOnly || props.isDisabled) return;\n            if (!selectedValues.includes(value)) setValue(selectedValues.concat(value));\n        },\n        removeValue (value) {\n            if (props.isReadOnly || props.isDisabled) return;\n            if (selectedValues.includes(value)) setValue(selectedValues.filter((existingValue)=>existingValue !== value));\n        },\n        toggleValue (value) {\n            if (props.isReadOnly || props.isDisabled) return;\n            if (selectedValues.includes(value)) setValue(selectedValues.filter((existingValue)=>existingValue !== value));\n            else setValue(selectedValues.concat(value));\n        },\n        setInvalid (value, v) {\n            let s = new Map(invalidValues.current);\n            if (v.isInvalid) s.set(value, v);\n            else s.delete(value);\n            invalidValues.current = s;\n            validation.updateValidation((0, _react_stately_form__WEBPACK_IMPORTED_MODULE_2__.mergeValidation)(...s.values()));\n        },\n        validationState: (_props_validationState = props.validationState) !== null && _props_validationState !== void 0 ? _props_validationState : isInvalid ? \"invalid\" : null,\n        isInvalid: isInvalid,\n        isRequired: isRequired\n    };\n    return state;\n}\n //# sourceMappingURL=module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXN0YXRlbHkvY2hlY2tib3gvZGlzdC9pbXBvcnQubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBdUk7QUFDbEQ7QUFDdkM7QUFFOUM7Ozs7Ozs7Ozs7Q0FVQyxHQUFHOzs7Ozs7Ozs7O0NBVUgsR0FHRCxTQUFTUSwwQ0FBMENDLFFBQVEsQ0FBQyxDQUFDO0lBQ3pELElBQUksQ0FBQ0MsZ0JBQWdCQyxTQUFTLEdBQUcsQ0FBQyxHQUFHTixvRUFBd0IsRUFBR0ksTUFBTUcsS0FBSyxFQUFFSCxNQUFNSSxZQUFZLElBQUksRUFBRSxFQUFFSixNQUFNSyxRQUFRO0lBQ3JILElBQUlDLGFBQWEsQ0FBQyxDQUFDTixNQUFNTSxVQUFVLElBQUlMLGVBQWVNLE1BQU0sS0FBSztJQUNqRSxJQUFJQyxnQkFBZ0IsQ0FBQyxHQUFHVix5Q0FBWSxFQUFHLElBQUlXO0lBQzNDLElBQUlDLGFBQWEsQ0FBQyxHQUFHbEIsdUVBQTRCLEVBQUc7UUFDaEQsR0FBR1EsS0FBSztRQUNSRyxPQUFPRjtJQUNYO0lBQ0EsSUFBSVUsWUFBWUQsV0FBV0UsaUJBQWlCLENBQUNELFNBQVM7SUFDdEQsSUFBSUU7SUFDSixNQUFNQyxRQUFRO1FBQ1YsR0FBR0osVUFBVTtRQUNiUCxPQUFPRjtRQUNQQyxVQUFVQyxLQUFLO1lBQ1gsSUFBSUgsTUFBTWUsVUFBVSxJQUFJZixNQUFNZ0IsVUFBVSxFQUFFO1lBQzFDZCxTQUFTQztRQUNiO1FBQ0FhLFlBQVloQixNQUFNZ0IsVUFBVSxJQUFJO1FBQ2hDRCxZQUFZZixNQUFNZSxVQUFVLElBQUk7UUFDaENFLFlBQVlkLEtBQUs7WUFDYixPQUFPRixlQUFlaUIsUUFBUSxDQUFDZjtRQUNuQztRQUNBZ0IsVUFBVWhCLEtBQUs7WUFDWCxJQUFJSCxNQUFNZSxVQUFVLElBQUlmLE1BQU1nQixVQUFVLEVBQUU7WUFDMUMsSUFBSSxDQUFDZixlQUFlaUIsUUFBUSxDQUFDZixRQUFRRCxTQUFTRCxlQUFlbUIsTUFBTSxDQUFDakI7UUFDeEU7UUFDQWtCLGFBQWFsQixLQUFLO1lBQ2QsSUFBSUgsTUFBTWUsVUFBVSxJQUFJZixNQUFNZ0IsVUFBVSxFQUFFO1lBQzFDLElBQUlmLGVBQWVpQixRQUFRLENBQUNmLFFBQVFELFNBQVNELGVBQWVxQixNQUFNLENBQUMsQ0FBQ0MsZ0JBQWdCQSxrQkFBa0JwQjtRQUMxRztRQUNBcUIsYUFBYXJCLEtBQUs7WUFDZCxJQUFJSCxNQUFNZSxVQUFVLElBQUlmLE1BQU1nQixVQUFVLEVBQUU7WUFDMUMsSUFBSWYsZUFBZWlCLFFBQVEsQ0FBQ2YsUUFBUUQsU0FBU0QsZUFBZXFCLE1BQU0sQ0FBQyxDQUFDQyxnQkFBZ0JBLGtCQUFrQnBCO2lCQUNqR0QsU0FBU0QsZUFBZW1CLE1BQU0sQ0FBQ2pCO1FBQ3hDO1FBQ0FzQixZQUFZdEIsS0FBSyxFQUFFdUIsQ0FBQztZQUNoQixJQUFJQyxJQUFJLElBQUlsQixJQUFJRCxjQUFjb0IsT0FBTztZQUNyQyxJQUFJRixFQUFFZixTQUFTLEVBQUVnQixFQUFFRSxHQUFHLENBQUMxQixPQUFPdUI7aUJBQ3pCQyxFQUFFRyxNQUFNLENBQUMzQjtZQUNkSyxjQUFjb0IsT0FBTyxHQUFHRDtZQUN4QmpCLFdBQVdxQixnQkFBZ0IsQ0FBQyxDQUFDLEdBQUdyQyxnRUFBcUIsS0FBTWlDLEVBQUVLLE1BQU07UUFDdkU7UUFDQUMsaUJBQWlCLENBQUNwQix5QkFBeUJiLE1BQU1pQyxlQUFlLE1BQU0sUUFBUXBCLDJCQUEyQixLQUFLLElBQUlBLHlCQUF5QkYsWUFBWSxZQUFZO1FBQ25LQSxXQUFXQTtRQUNYTCxZQUFZQTtJQUNoQjtJQUNBLE9BQU9RO0FBQ1g7QUFLNEUsQ0FDNUUsa0NBQWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1mbGFzay8uL25vZGVfbW9kdWxlcy9AcmVhY3Qtc3RhdGVseS9jaGVja2JveC9kaXN0L2ltcG9ydC5tanM/YTlhMyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge3VzZUZvcm1WYWxpZGF0aW9uU3RhdGUgYXMgJGIzbnVPJHVzZUZvcm1WYWxpZGF0aW9uU3RhdGUsIG1lcmdlVmFsaWRhdGlvbiBhcyAkYjNudU8kbWVyZ2VWYWxpZGF0aW9ufSBmcm9tIFwiQHJlYWN0LXN0YXRlbHkvZm9ybVwiO1xuaW1wb3J0IHt1c2VDb250cm9sbGVkU3RhdGUgYXMgJGIzbnVPJHVzZUNvbnRyb2xsZWRTdGF0ZX0gZnJvbSBcIkByZWFjdC1zdGF0ZWx5L3V0aWxzXCI7XG5pbXBvcnQge3VzZVJlZiBhcyAkYjNudU8kdXNlUmVmfSBmcm9tIFwicmVhY3RcIjtcblxuLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIC8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyBcblxuXG5mdW5jdGlvbiAkNTg3ZDNhZDU4YmU2ZDMxZiRleHBvcnQkZGFmZjZkYTUxMDMyYTQxNShwcm9wcyA9IHt9KSB7XG4gICAgbGV0IFtzZWxlY3RlZFZhbHVlcywgc2V0VmFsdWVdID0gKDAsICRiM251TyR1c2VDb250cm9sbGVkU3RhdGUpKHByb3BzLnZhbHVlLCBwcm9wcy5kZWZhdWx0VmFsdWUgfHwgW10sIHByb3BzLm9uQ2hhbmdlKTtcbiAgICBsZXQgaXNSZXF1aXJlZCA9ICEhcHJvcHMuaXNSZXF1aXJlZCAmJiBzZWxlY3RlZFZhbHVlcy5sZW5ndGggPT09IDA7XG4gICAgbGV0IGludmFsaWRWYWx1ZXMgPSAoMCwgJGIzbnVPJHVzZVJlZikobmV3IE1hcCgpKTtcbiAgICBsZXQgdmFsaWRhdGlvbiA9ICgwLCAkYjNudU8kdXNlRm9ybVZhbGlkYXRpb25TdGF0ZSkoe1xuICAgICAgICAuLi5wcm9wcyxcbiAgICAgICAgdmFsdWU6IHNlbGVjdGVkVmFsdWVzXG4gICAgfSk7XG4gICAgbGV0IGlzSW52YWxpZCA9IHZhbGlkYXRpb24uZGlzcGxheVZhbGlkYXRpb24uaXNJbnZhbGlkO1xuICAgIHZhciBfcHJvcHNfdmFsaWRhdGlvblN0YXRlO1xuICAgIGNvbnN0IHN0YXRlID0ge1xuICAgICAgICAuLi52YWxpZGF0aW9uLFxuICAgICAgICB2YWx1ZTogc2VsZWN0ZWRWYWx1ZXMsXG4gICAgICAgIHNldFZhbHVlICh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHByb3BzLmlzUmVhZE9ubHkgfHwgcHJvcHMuaXNEaXNhYmxlZCkgcmV0dXJuO1xuICAgICAgICAgICAgc2V0VmFsdWUodmFsdWUpO1xuICAgICAgICB9LFxuICAgICAgICBpc0Rpc2FibGVkOiBwcm9wcy5pc0Rpc2FibGVkIHx8IGZhbHNlLFxuICAgICAgICBpc1JlYWRPbmx5OiBwcm9wcy5pc1JlYWRPbmx5IHx8IGZhbHNlLFxuICAgICAgICBpc1NlbGVjdGVkICh2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHNlbGVjdGVkVmFsdWVzLmluY2x1ZGVzKHZhbHVlKTtcbiAgICAgICAgfSxcbiAgICAgICAgYWRkVmFsdWUgKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAocHJvcHMuaXNSZWFkT25seSB8fCBwcm9wcy5pc0Rpc2FibGVkKSByZXR1cm47XG4gICAgICAgICAgICBpZiAoIXNlbGVjdGVkVmFsdWVzLmluY2x1ZGVzKHZhbHVlKSkgc2V0VmFsdWUoc2VsZWN0ZWRWYWx1ZXMuY29uY2F0KHZhbHVlKSk7XG4gICAgICAgIH0sXG4gICAgICAgIHJlbW92ZVZhbHVlICh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHByb3BzLmlzUmVhZE9ubHkgfHwgcHJvcHMuaXNEaXNhYmxlZCkgcmV0dXJuO1xuICAgICAgICAgICAgaWYgKHNlbGVjdGVkVmFsdWVzLmluY2x1ZGVzKHZhbHVlKSkgc2V0VmFsdWUoc2VsZWN0ZWRWYWx1ZXMuZmlsdGVyKChleGlzdGluZ1ZhbHVlKT0+ZXhpc3RpbmdWYWx1ZSAhPT0gdmFsdWUpKTtcbiAgICAgICAgfSxcbiAgICAgICAgdG9nZ2xlVmFsdWUgKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAocHJvcHMuaXNSZWFkT25seSB8fCBwcm9wcy5pc0Rpc2FibGVkKSByZXR1cm47XG4gICAgICAgICAgICBpZiAoc2VsZWN0ZWRWYWx1ZXMuaW5jbHVkZXModmFsdWUpKSBzZXRWYWx1ZShzZWxlY3RlZFZhbHVlcy5maWx0ZXIoKGV4aXN0aW5nVmFsdWUpPT5leGlzdGluZ1ZhbHVlICE9PSB2YWx1ZSkpO1xuICAgICAgICAgICAgZWxzZSBzZXRWYWx1ZShzZWxlY3RlZFZhbHVlcy5jb25jYXQodmFsdWUpKTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0SW52YWxpZCAodmFsdWUsIHYpIHtcbiAgICAgICAgICAgIGxldCBzID0gbmV3IE1hcChpbnZhbGlkVmFsdWVzLmN1cnJlbnQpO1xuICAgICAgICAgICAgaWYgKHYuaXNJbnZhbGlkKSBzLnNldCh2YWx1ZSwgdik7XG4gICAgICAgICAgICBlbHNlIHMuZGVsZXRlKHZhbHVlKTtcbiAgICAgICAgICAgIGludmFsaWRWYWx1ZXMuY3VycmVudCA9IHM7XG4gICAgICAgICAgICB2YWxpZGF0aW9uLnVwZGF0ZVZhbGlkYXRpb24oKDAsICRiM251TyRtZXJnZVZhbGlkYXRpb24pKC4uLnMudmFsdWVzKCkpKTtcbiAgICAgICAgfSxcbiAgICAgICAgdmFsaWRhdGlvblN0YXRlOiAoX3Byb3BzX3ZhbGlkYXRpb25TdGF0ZSA9IHByb3BzLnZhbGlkYXRpb25TdGF0ZSkgIT09IG51bGwgJiYgX3Byb3BzX3ZhbGlkYXRpb25TdGF0ZSAhPT0gdm9pZCAwID8gX3Byb3BzX3ZhbGlkYXRpb25TdGF0ZSA6IGlzSW52YWxpZCA/IFwiaW52YWxpZFwiIDogbnVsbCxcbiAgICAgICAgaXNJbnZhbGlkOiBpc0ludmFsaWQsXG4gICAgICAgIGlzUmVxdWlyZWQ6IGlzUmVxdWlyZWRcbiAgICB9O1xuICAgIHJldHVybiBzdGF0ZTtcbn1cblxuXG5cblxuZXhwb3J0IHskNTg3ZDNhZDU4YmU2ZDMxZiRleHBvcnQkZGFmZjZkYTUxMDMyYTQxNSBhcyB1c2VDaGVja2JveEdyb3VwU3RhdGV9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bW9kdWxlLmpzLm1hcFxuIl0sIm5hbWVzIjpbInVzZUZvcm1WYWxpZGF0aW9uU3RhdGUiLCIkYjNudU8kdXNlRm9ybVZhbGlkYXRpb25TdGF0ZSIsIm1lcmdlVmFsaWRhdGlvbiIsIiRiM251TyRtZXJnZVZhbGlkYXRpb24iLCJ1c2VDb250cm9sbGVkU3RhdGUiLCIkYjNudU8kdXNlQ29udHJvbGxlZFN0YXRlIiwidXNlUmVmIiwiJGIzbnVPJHVzZVJlZiIsIiQ1ODdkM2FkNThiZTZkMzFmJGV4cG9ydCRkYWZmNmRhNTEwMzJhNDE1IiwicHJvcHMiLCJzZWxlY3RlZFZhbHVlcyIsInNldFZhbHVlIiwidmFsdWUiLCJkZWZhdWx0VmFsdWUiLCJvbkNoYW5nZSIsImlzUmVxdWlyZWQiLCJsZW5ndGgiLCJpbnZhbGlkVmFsdWVzIiwiTWFwIiwidmFsaWRhdGlvbiIsImlzSW52YWxpZCIsImRpc3BsYXlWYWxpZGF0aW9uIiwiX3Byb3BzX3ZhbGlkYXRpb25TdGF0ZSIsInN0YXRlIiwiaXNSZWFkT25seSIsImlzRGlzYWJsZWQiLCJpc1NlbGVjdGVkIiwiaW5jbHVkZXMiLCJhZGRWYWx1ZSIsImNvbmNhdCIsInJlbW92ZVZhbHVlIiwiZmlsdGVyIiwiZXhpc3RpbmdWYWx1ZSIsInRvZ2dsZVZhbHVlIiwic2V0SW52YWxpZCIsInYiLCJzIiwiY3VycmVudCIsInNldCIsImRlbGV0ZSIsInVwZGF0ZVZhbGlkYXRpb24iLCJ2YWx1ZXMiLCJ2YWxpZGF0aW9uU3RhdGUiLCJ1c2VDaGVja2JveEdyb3VwU3RhdGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-stately/checkbox/dist/import.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-stately/collections/dist/import.mjs":
/*!*****************************************************************!*\
  !*** ./node_modules/@react-stately/collections/dist/import.mjs ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CollectionBuilder: () => (/* binding */ $eb2240fc39a57fa5$export$bf788dd355e3a401),\n/* harmony export */   Item: () => (/* binding */ $c1d7fb2ec91bae71$export$6d08773d2e66f8f2),\n/* harmony export */   Section: () => (/* binding */ $9fc4852771d079eb$export$6e2c8f0811a474ce),\n/* harmony export */   compareNodeOrder: () => (/* binding */ $c5a24bc478652b5f$export$8c434b3a7a4dad6),\n/* harmony export */   getChildNodes: () => (/* binding */ $c5a24bc478652b5f$export$1005530eda016c13),\n/* harmony export */   getFirstItem: () => (/* binding */ $c5a24bc478652b5f$export$fbdeaa6a76694f71),\n/* harmony export */   getItemCount: () => (/* binding */ $453cc9f0df89c0a5$export$77d5aafae4e095b2),\n/* harmony export */   getLastItem: () => (/* binding */ $c5a24bc478652b5f$export$7475b2c64539e4cf),\n/* harmony export */   getNthItem: () => (/* binding */ $c5a24bc478652b5f$export$5f3398f8733f90e2),\n/* harmony export */   useCollection: () => (/* binding */ $7613b1592d41b092$export$6cd28814d92fa9c9)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ function $c1d7fb2ec91bae71$var$Item(props) {\n    return null;\n}\n$c1d7fb2ec91bae71$var$Item.getCollectionNode = function* getCollectionNode(props, context) {\n    let { childItems: childItems, title: title, children: children } = props;\n    let rendered = props.title || props.children;\n    let textValue = props.textValue || (typeof rendered === \"string\" ? rendered : \"\") || props[\"aria-label\"] || \"\";\n    // suppressTextValueWarning is used in components like Tabs, which don't have type to select support.\n    if (!textValue && !(context === null || context === void 0 ? void 0 : context.suppressTextValueWarning)) console.warn(\"<Item> with non-plain text contents is unsupported by type to select for accessibility. Please add a `textValue` prop.\");\n    yield {\n        type: \"item\",\n        props: props,\n        rendered: rendered,\n        textValue: textValue,\n        \"aria-label\": props[\"aria-label\"],\n        hasChildNodes: $c1d7fb2ec91bae71$var$hasChildItems(props),\n        *childNodes () {\n            if (childItems) for (let child of childItems)yield {\n                type: \"item\",\n                value: child\n            };\n            else if (title) {\n                let items = [];\n                (0, react__WEBPACK_IMPORTED_MODULE_0__).Children.forEach(children, (child)=>{\n                    items.push({\n                        type: \"item\",\n                        element: child\n                    });\n                });\n                yield* items;\n            }\n        }\n    };\n};\nfunction $c1d7fb2ec91bae71$var$hasChildItems(props) {\n    if (props.hasChildItems != null) return props.hasChildItems;\n    if (props.childItems) return true;\n    if (props.title && (0, react__WEBPACK_IMPORTED_MODULE_0__).Children.count(props.children) > 0) return true;\n    return false;\n}\n// We don't want getCollectionNode to show up in the type definition\nlet $c1d7fb2ec91bae71$export$6d08773d2e66f8f2 = $c1d7fb2ec91bae71$var$Item;\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ function $9fc4852771d079eb$var$Section(props) {\n    return null;\n}\n$9fc4852771d079eb$var$Section.getCollectionNode = function* getCollectionNode(props) {\n    let { children: children, title: title, items: items } = props;\n    yield {\n        type: \"section\",\n        props: props,\n        hasChildNodes: true,\n        rendered: title,\n        \"aria-label\": props[\"aria-label\"],\n        *childNodes () {\n            if (typeof children === \"function\") {\n                if (!items) throw new Error(\"props.children was a function but props.items is missing\");\n                for (let item of items)yield {\n                    type: \"item\",\n                    value: item,\n                    renderer: children\n                };\n            } else {\n                let items = [];\n                (0, react__WEBPACK_IMPORTED_MODULE_0__).Children.forEach(children, (child)=>{\n                    items.push({\n                        type: \"item\",\n                        element: child\n                    });\n                });\n                yield* items;\n            }\n        }\n    };\n};\n// We don't want getCollectionNode to show up in the type definition\nlet $9fc4852771d079eb$export$6e2c8f0811a474ce = $9fc4852771d079eb$var$Section;\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ class $eb2240fc39a57fa5$export$bf788dd355e3a401 {\n    build(props, context) {\n        this.context = context;\n        return $eb2240fc39a57fa5$var$iterable(()=>this.iterateCollection(props));\n    }\n    *iterateCollection(props) {\n        let { children: children, items: items } = props;\n        if (typeof children === \"function\") {\n            if (!items) throw new Error(\"props.children was a function but props.items is missing\");\n            for (let item of props.items)yield* this.getFullNode({\n                value: item\n            }, {\n                renderer: children\n            });\n        } else {\n            let items = [];\n            (0, react__WEBPACK_IMPORTED_MODULE_0__).Children.forEach(children, (child)=>{\n                items.push(child);\n            });\n            let index = 0;\n            for (let item of items){\n                let nodes = this.getFullNode({\n                    element: item,\n                    index: index\n                }, {});\n                for (let node of nodes){\n                    index++;\n                    yield node;\n                }\n            }\n        }\n    }\n    getKey(item, partialNode, state, parentKey) {\n        if (item.key != null) return item.key;\n        if (partialNode.type === \"cell\" && partialNode.key != null) return `${parentKey}${partialNode.key}`;\n        let v = partialNode.value;\n        if (v != null) {\n            var _v_key;\n            let key = (_v_key = v.key) !== null && _v_key !== void 0 ? _v_key : v.id;\n            if (key == null) throw new Error(\"No key found for item\");\n            return key;\n        }\n        return parentKey ? `${parentKey}.${partialNode.index}` : `$.${partialNode.index}`;\n    }\n    getChildState(state, partialNode) {\n        return {\n            renderer: partialNode.renderer || state.renderer\n        };\n    }\n    *getFullNode(partialNode, state, parentKey, parentNode) {\n        // If there's a value instead of an element on the node, and a parent renderer function is available,\n        // use it to render an element for the value.\n        let element = partialNode.element;\n        if (!element && partialNode.value && state && state.renderer) {\n            let cached = this.cache.get(partialNode.value);\n            if (cached && (!cached.shouldInvalidate || !cached.shouldInvalidate(this.context))) {\n                cached.index = partialNode.index;\n                cached.parentKey = parentNode ? parentNode.key : null;\n                yield cached;\n                return;\n            }\n            element = state.renderer(partialNode.value);\n        }\n        // If there's an element with a getCollectionNode function on its type, then it's a supported component.\n        // Call this function to get a partial node, and recursively build a full node from there.\n        if ((0, react__WEBPACK_IMPORTED_MODULE_0__).isValidElement(element)) {\n            let type = element.type;\n            if (typeof type !== \"function\" && typeof type.getCollectionNode !== \"function\") {\n                let name = typeof element.type === \"function\" ? element.type.name : element.type;\n                throw new Error(`Unknown element <${name}> in collection.`);\n            }\n            let childNodes = type.getCollectionNode(element.props, this.context);\n            let index = partialNode.index;\n            let result = childNodes.next();\n            while(!result.done && result.value){\n                let childNode = result.value;\n                partialNode.index = index;\n                let nodeKey = childNode.key;\n                if (!nodeKey) nodeKey = childNode.element ? null : this.getKey(element, partialNode, state, parentKey);\n                let nodes = this.getFullNode({\n                    ...childNode,\n                    key: nodeKey,\n                    index: index,\n                    wrapper: $eb2240fc39a57fa5$var$compose(partialNode.wrapper, childNode.wrapper)\n                }, this.getChildState(state, childNode), parentKey ? `${parentKey}${element.key}` : element.key, parentNode);\n                let children = [\n                    ...nodes\n                ];\n                for (let node of children){\n                    // Cache the node based on its value\n                    node.value = childNode.value || partialNode.value;\n                    if (node.value) this.cache.set(node.value, node);\n                    // The partial node may have specified a type for the child in order to specify a constraint.\n                    // Verify that the full node that was built recursively matches this type.\n                    if (partialNode.type && node.type !== partialNode.type) throw new Error(`Unsupported type <${$eb2240fc39a57fa5$var$capitalize(node.type)}> in <${$eb2240fc39a57fa5$var$capitalize(parentNode.type)}>. Only <${$eb2240fc39a57fa5$var$capitalize(partialNode.type)}> is supported.`);\n                    index++;\n                    yield node;\n                }\n                result = childNodes.next(children);\n            }\n            return;\n        }\n        // Ignore invalid elements\n        if (partialNode.key == null) return;\n        // Create full node\n        let builder = this;\n        let node = {\n            type: partialNode.type,\n            props: partialNode.props,\n            key: partialNode.key,\n            parentKey: parentNode ? parentNode.key : null,\n            value: partialNode.value,\n            level: parentNode ? parentNode.level + 1 : 0,\n            index: partialNode.index,\n            rendered: partialNode.rendered,\n            textValue: partialNode.textValue,\n            \"aria-label\": partialNode[\"aria-label\"],\n            wrapper: partialNode.wrapper,\n            shouldInvalidate: partialNode.shouldInvalidate,\n            hasChildNodes: partialNode.hasChildNodes,\n            childNodes: $eb2240fc39a57fa5$var$iterable(function*() {\n                if (!partialNode.hasChildNodes) return;\n                let index = 0;\n                for (let child of partialNode.childNodes()){\n                    // Ensure child keys are globally unique by prepending the parent node's key\n                    if (child.key != null) // Currently this line will have issues when a parent has a key `a` and a child with key `bc`\n                    // but another parent has key `ab` and its child has a key `c`. The combined keys would result in both\n                    // children having a key of `abc`.\n                    child.key = `${node.key}${child.key}`;\n                    child.index = index;\n                    let nodes = builder.getFullNode(child, builder.getChildState(state, child), node.key, node);\n                    for (let node of nodes){\n                        index++;\n                        yield node;\n                    }\n                }\n            })\n        };\n        yield node;\n    }\n    constructor(){\n        this.cache = new WeakMap();\n    }\n}\n// Wraps an iterator function as an iterable object, and caches the results.\nfunction $eb2240fc39a57fa5$var$iterable(iterator) {\n    let cache = [];\n    let iterable = null;\n    return {\n        *[Symbol.iterator] () {\n            for (let item of cache)yield item;\n            if (!iterable) iterable = iterator();\n            for (let item of iterable){\n                cache.push(item);\n                yield item;\n            }\n        }\n    };\n}\nfunction $eb2240fc39a57fa5$var$compose(outer, inner) {\n    if (outer && inner) return (element)=>outer(inner(element));\n    if (outer) return outer;\n    if (inner) return inner;\n}\nfunction $eb2240fc39a57fa5$var$capitalize(str) {\n    return str[0].toUpperCase() + str.slice(1);\n}\nfunction $7613b1592d41b092$export$6cd28814d92fa9c9(props, factory, context) {\n    let builder = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>new (0, $eb2240fc39a57fa5$export$bf788dd355e3a401)(), []);\n    let { children: children, items: items, collection: collection } = props;\n    let result = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        if (collection) return collection;\n        let nodes = builder.build({\n            children: children,\n            items: items\n        }, context);\n        return factory(nodes);\n    }, [\n        builder,\n        children,\n        items,\n        collection,\n        context,\n        factory\n    ]);\n    return result;\n}\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ function $c5a24bc478652b5f$export$1005530eda016c13(node, collection) {\n    // New API: call collection.getChildren with the node key.\n    if (typeof collection.getChildren === \"function\") return collection.getChildren(node.key);\n    // Old API: access childNodes directly.\n    return node.childNodes;\n}\nfunction $c5a24bc478652b5f$export$fbdeaa6a76694f71(iterable) {\n    return $c5a24bc478652b5f$export$5f3398f8733f90e2(iterable, 0);\n}\nfunction $c5a24bc478652b5f$export$5f3398f8733f90e2(iterable, index) {\n    if (index < 0) return undefined;\n    let i = 0;\n    for (let item of iterable){\n        if (i === index) return item;\n        i++;\n    }\n}\nfunction $c5a24bc478652b5f$export$7475b2c64539e4cf(iterable) {\n    let lastItem = undefined;\n    for (let value of iterable)lastItem = value;\n    return lastItem;\n}\nfunction $c5a24bc478652b5f$export$8c434b3a7a4dad6(collection, a, b) {\n    // If the two nodes have the same parent, compare their indices.\n    if (a.parentKey === b.parentKey) return a.index - b.index;\n    // Otherwise, collect all of the ancestors from each node, and find the first one that doesn't match starting from the root.\n    // Include the base nodes in case we are comparing nodes of different levels so that we can compare the higher node to the lower level node's\n    // ancestor of the same level\n    let aAncestors = [\n        ...$c5a24bc478652b5f$var$getAncestors(collection, a),\n        a\n    ];\n    let bAncestors = [\n        ...$c5a24bc478652b5f$var$getAncestors(collection, b),\n        b\n    ];\n    let firstNonMatchingAncestor = aAncestors.slice(0, bAncestors.length).findIndex((a, i)=>a !== bAncestors[i]);\n    if (firstNonMatchingAncestor !== -1) {\n        // Compare the indices of two children within the common ancestor.\n        a = aAncestors[firstNonMatchingAncestor];\n        b = bAncestors[firstNonMatchingAncestor];\n        return a.index - b.index;\n    }\n    // If there isn't a non matching ancestor, we might be in a case where one of the nodes is the ancestor of the other.\n    if (aAncestors.findIndex((node)=>node === b) >= 0) return 1;\n    else if (bAncestors.findIndex((node)=>node === a) >= 0) return -1;\n    // ðŸ¤·\n    return -1;\n}\nfunction $c5a24bc478652b5f$var$getAncestors(collection, node) {\n    let parents = [];\n    while((node === null || node === void 0 ? void 0 : node.parentKey) != null){\n        node = collection.getItem(node.parentKey);\n        parents.unshift(node);\n    }\n    return parents;\n}\nconst $453cc9f0df89c0a5$var$cache = new WeakMap();\nfunction $453cc9f0df89c0a5$export$77d5aafae4e095b2(collection) {\n    let count = $453cc9f0df89c0a5$var$cache.get(collection);\n    if (count != null) return count;\n    count = 0;\n    let countItems = (items)=>{\n        for (let item of items)if (item.type === \"section\") countItems((0, $c5a24bc478652b5f$export$1005530eda016c13)(item, collection));\n        else count++;\n    };\n    countItems(collection);\n    $453cc9f0df89c0a5$var$cache.set(collection, count);\n    return count;\n}\n //# sourceMappingURL=module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXN0YXRlbHkvY29sbGVjdGlvbnMvZGlzdC9pbXBvcnQubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQThEO0FBRTlEOzs7Ozs7Ozs7O0NBVUMsR0FBRzs7Ozs7Ozs7OztDQVVILEdBQ0QsU0FBU0csMkJBQTJCQyxLQUFLO0lBQ3JDLE9BQU87QUFDWDtBQUNBRCwyQkFBMkJFLGlCQUFpQixHQUFHLFVBQVVBLGtCQUFrQkQsS0FBSyxFQUFFRSxPQUFPO0lBQ3JGLElBQUksRUFBRUMsWUFBWUEsVUFBVSxFQUFFQyxPQUFPQSxLQUFLLEVBQUVDLFVBQVVBLFFBQVEsRUFBRSxHQUFHTDtJQUNuRSxJQUFJTSxXQUFXTixNQUFNSSxLQUFLLElBQUlKLE1BQU1LLFFBQVE7SUFDNUMsSUFBSUUsWUFBWVAsTUFBTU8sU0FBUyxJQUFLLFFBQU9ELGFBQWEsV0FBV0EsV0FBVyxFQUFDLEtBQU1OLEtBQUssQ0FBQyxhQUFhLElBQUk7SUFDNUcscUdBQXFHO0lBQ3JHLElBQUksQ0FBQ08sYUFBYSxDQUFFTCxDQUFBQSxZQUFZLFFBQVFBLFlBQVksS0FBSyxJQUFJLEtBQUssSUFBSUEsUUFBUU0sd0JBQXdCLEdBQUdDLFFBQVFDLElBQUksQ0FBQztJQUN0SCxNQUFNO1FBQ0ZDLE1BQU07UUFDTlgsT0FBT0E7UUFDUE0sVUFBVUE7UUFDVkMsV0FBV0E7UUFDWCxjQUFjUCxLQUFLLENBQUMsYUFBYTtRQUNqQ1ksZUFBZUMsb0NBQW9DYjtRQUNuRCxDQUFDYztZQUNHLElBQUlYLFlBQVksS0FBSyxJQUFJWSxTQUFTWixXQUFXLE1BQU07Z0JBQy9DUSxNQUFNO2dCQUNOSyxPQUFPRDtZQUNYO2lCQUNLLElBQUlYLE9BQU87Z0JBQ1osSUFBSWEsUUFBUSxFQUFFO2dCQUNiLElBQUdyQixrQ0FBVyxFQUFHc0IsUUFBUSxDQUFDQyxPQUFPLENBQUNkLFVBQVUsQ0FBQ1U7b0JBQzFDRSxNQUFNRyxJQUFJLENBQUM7d0JBQ1BULE1B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d2VicGFjazovL25leHQtZmxhc2svLi9ub2RlX21vZHVsZXMvQHJlYWN0LXN0YXRlbHkvY29sbGVjdGlvbnMvZGlzdC9pbXBvcnQubWpzPzFlMDYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICR0eVc2QSRyZWFjdCwge3VzZU1lbW8gYXMgJHR5VzZBJHVzZU1lbW99IGZyb20gXCJyZWFjdFwiO1xuXG4vKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIFxuZnVuY3Rpb24gJGMxZDdmYjJlYzkxYmFlNzEkdmFyJEl0ZW0ocHJvcHMpIHtcbiAgICByZXR1cm4gbnVsbDtcbn1cbiRjMWQ3ZmIyZWM5MWJhZTcxJHZhciRJdGVtLmdldENvbGxlY3Rpb25Ob2RlID0gZnVuY3Rpb24qIGdldENvbGxlY3Rpb25Ob2RlKHByb3BzLCBjb250ZXh0KSB7XG4gICAgbGV0IHsgY2hpbGRJdGVtczogY2hpbGRJdGVtcywgdGl0bGU6IHRpdGxlLCBjaGlsZHJlbjogY2hpbGRyZW4gfSA9IHByb3BzO1xuICAgIGxldCByZW5kZXJlZCA9IHByb3BzLnRpdGxlIHx8IHByb3BzLmNoaWxkcmVuO1xuICAgIGxldCB0ZXh0VmFsdWUgPSBwcm9wcy50ZXh0VmFsdWUgfHwgKHR5cGVvZiByZW5kZXJlZCA9PT0gXCJzdHJpbmdcIiA/IHJlbmRlcmVkIDogXCJcIikgfHwgcHJvcHNbXCJhcmlhLWxhYmVsXCJdIHx8IFwiXCI7XG4gICAgLy8gc3VwcHJlc3NUZXh0VmFsdWVXYXJuaW5nIGlzIHVzZWQgaW4gY29tcG9uZW50cyBsaWtlIFRhYnMsIHdoaWNoIGRvbid0IGhhdmUgdHlwZSB0byBzZWxlY3Qgc3VwcG9ydC5cbiAgICBpZiAoIXRleHRWYWx1ZSAmJiAhKGNvbnRleHQgPT09IG51bGwgfHwgY29udGV4dCA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29udGV4dC5zdXBwcmVzc1RleHRWYWx1ZVdhcm5pbmcpKSBjb25zb2xlLndhcm4oXCI8SXRlbT4gd2l0aCBub24tcGxhaW4gdGV4dCBjb250ZW50cyBpcyB1bnN1cHBvcnRlZCBieSB0eXBlIHRvIHNlbGVjdCBmb3IgYWNjZXNzaWJpbGl0eS4gUGxlYXNlIGFkZCBhIGB0ZXh0VmFsdWVgIHByb3AuXCIpO1xuICAgIHlpZWxkIHtcbiAgICAgICAgdHlwZTogXCJpdGVtXCIsXG4gICAgICAgIHByb3BzOiBwcm9wcyxcbiAgICAgICAgcmVuZGVyZWQ6IHJlbmRlcmVkLFxuICAgICAgICB0ZXh0VmFsdWU6IHRleHRWYWx1ZSxcbiAgICAgICAgXCJhcmlhLWxhYmVsXCI6IHByb3BzW1wiYXJpYS1sYWJlbFwiXSxcbiAgICAgICAgaGFzQ2hpbGROb2RlczogJGMxZDdmYjJlYzkxYmFlNzEkdmFyJGhhc0NoaWxkSXRlbXMocHJvcHMpLFxuICAgICAgICAqY2hpbGROb2RlcyAoKSB7XG4gICAgICAgICAgICBpZiAoY2hpbGRJdGVtcykgZm9yIChsZXQgY2hpbGQgb2YgY2hpbGRJdGVtcyl5aWVsZCB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJpdGVtXCIsXG4gICAgICAgICAgICAgICAgdmFsdWU6IGNoaWxkXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZWxzZSBpZiAodGl0bGUpIHtcbiAgICAgICAgICAgICAgICBsZXQgaXRlbXMgPSBbXTtcbiAgICAgICAgICAgICAgICAoMCwgJHR5VzZBJHJlYWN0KS5DaGlsZHJlbi5mb3JFYWNoKGNoaWxkcmVuLCAoY2hpbGQpPT57XG4gICAgICAgICAgICAgICAgICAgIGl0ZW1zLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJpdGVtXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50OiBjaGlsZFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB5aWVsZCogaXRlbXM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xufTtcbmZ1bmN0aW9uICRjMWQ3ZmIyZWM5MWJhZTcxJHZhciRoYXNDaGlsZEl0ZW1zKHByb3BzKSB7XG4gICAgaWYgKHByb3BzLmhhc0NoaWxkSXRlbXMgIT0gbnVsbCkgcmV0dXJuIHByb3BzLmhhc0NoaWxkSXRlbXM7XG4gICAgaWYgKHByb3BzLmNoaWxkSXRlbXMpIHJldHVybiB0cnVlO1xuICAgIGlmIChwcm9wcy50aXRsZSAmJiAoMCwgJHR5VzZBJHJlYWN0KS5DaGlsZHJlbi5jb3VudChwcm9wcy5jaGlsZHJlbikgPiAwKSByZXR1cm4gdHJ1ZTtcbiAgICByZXR1cm4gZmFsc2U7XG59XG4vLyBXZSBkb24ndCB3YW50IGdldENvbGxlY3Rpb25Ob2RlIHRvIHNob3cgdXAgaW4gdGhlIHR5cGUgZGVmaW5pdGlvblxubGV0ICRjMWQ3ZmIyZWM5MWJhZTcxJGV4cG9ydCQ2ZDA4NzczZDJlNjZmOGYyID0gJGMxZDdmYjJlYzkxYmFlNzEkdmFyJEl0ZW07XG5cblxuLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIFxuZnVuY3Rpb24gJDlmYzQ4NTI3NzFkMDc5ZWIkdmFyJFNlY3Rpb24ocHJvcHMpIHtcbiAgICByZXR1cm4gbnVsbDtcbn1cbiQ5ZmM0ODUyNzcxZDA3OWViJHZhciRTZWN0aW9uLmdldENvbGxlY3Rpb25Ob2RlID0gZnVuY3Rpb24qIGdldENvbGxlY3Rpb25Ob2RlKHByb3BzKSB7XG4gICAgbGV0IHsgY2hpbGRyZW46IGNoaWxkcmVuLCB0aXRsZTogdGl0bGUsIGl0ZW1zOiBpdGVtcyB9ID0gcHJvcHM7XG4gICAgeWllbGQge1xuICAgICAgICB0eXBlOiBcInNlY3Rpb25cIixcbiAgICAgICAgcHJvcHM6IHByb3BzLFxuICAgICAgICBoYXNDaGlsZE5vZGVzOiB0cnVlLFxuICAgICAgICByZW5kZXJlZDogdGl0bGUsXG4gICAgICAgIFwiYXJpYS1sYWJlbFwiOiBwcm9wc1tcImFyaWEtbGFiZWxcIl0sXG4gICAgICAgICpjaGlsZE5vZGVzICgpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY2hpbGRyZW4gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIGlmICghaXRlbXMpIHRocm93IG5ldyBFcnJvcihcInByb3BzLmNoaWxkcmVuIHdhcyBhIGZ1bmN0aW9uIGJ1dCBwcm9wcy5pdGVtcyBpcyBtaXNzaW5nXCIpO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGl0ZW0gb2YgaXRlbXMpeWllbGQge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcIml0ZW1cIixcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGl0ZW0sXG4gICAgICAgICAgICAgICAgICAgIHJlbmRlcmVyOiBjaGlsZHJlblxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBpdGVtcyA9IFtdO1xuICAgICAgICAgICAgICAgICgwLCAkdHlXNkEkcmVhY3QpLkNoaWxkcmVuLmZvckVhY2goY2hpbGRyZW4sIChjaGlsZCk9PntcbiAgICAgICAgICAgICAgICAgICAgaXRlbXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcIml0ZW1cIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQ6IGNoaWxkXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHlpZWxkKiBpdGVtcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG59O1xuLy8gV2UgZG9uJ3Qgd2FudCBnZXRDb2xsZWN0aW9uTm9kZSB0byBzaG93IHVwIGluIHRoZSB0eXBlIGRlZmluaXRpb25cbmxldCAkOWZjNDg1Mjc3MWQwNzllYiRleHBvcnQkNmUyYzhmMDgxMWE0NzRjZSA9ICQ5ZmM0ODUyNzcxZDA3OWViJHZhciRTZWN0aW9uO1xuXG5cbi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyAvKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gXG5jbGFzcyAkZWIyMjQwZmMzOWE1N2ZhNSRleHBvcnQkYmY3ODhkZDM1NWUzYTQwMSB7XG4gICAgYnVpbGQocHJvcHMsIGNvbnRleHQpIHtcbiAgICAgICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICAgICAgcmV0dXJuICRlYjIyNDBmYzM5YTU3ZmE1JHZhciRpdGVyYWJsZSgoKT0+dGhpcy5pdGVyYXRlQ29sbGVjdGlvbihwcm9wcykpO1xuICAgIH1cbiAgICAqaXRlcmF0ZUNvbGxlY3Rpb24ocHJvcHMpIHtcbiAgICAgICAgbGV0IHsgY2hpbGRyZW46IGNoaWxkcmVuLCBpdGVtczogaXRlbXMgfSA9IHByb3BzO1xuICAgICAgICBpZiAodHlwZW9mIGNoaWxkcmVuID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIGlmICghaXRlbXMpIHRocm93IG5ldyBFcnJvcihcInByb3BzLmNoaWxkcmVuIHdhcyBhIGZ1bmN0aW9uIGJ1dCBwcm9wcy5pdGVtcyBpcyBtaXNzaW5nXCIpO1xuICAgICAgICAgICAgZm9yIChsZXQgaXRlbSBvZiBwcm9wcy5pdGVtcyl5aWVsZCogdGhpcy5nZXRGdWxsTm9kZSh7XG4gICAgICAgICAgICAgICAgdmFsdWU6IGl0ZW1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICByZW5kZXJlcjogY2hpbGRyZW5cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGV0IGl0ZW1zID0gW107XG4gICAgICAgICAgICAoMCwgJHR5VzZBJHJlYWN0KS5DaGlsZHJlbi5mb3JFYWNoKGNoaWxkcmVuLCAoY2hpbGQpPT57XG4gICAgICAgICAgICAgICAgaXRlbXMucHVzaChjaGlsZCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGxldCBpbmRleCA9IDA7XG4gICAgICAgICAgICBmb3IgKGxldCBpdGVtIG9mIGl0ZW1zKXtcbiAgICAgICAgICAgICAgICBsZXQgbm9kZXMgPSB0aGlzLmdldEZ1bGxOb2RlKHtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudDogaXRlbSxcbiAgICAgICAgICAgICAgICAgICAgaW5kZXg6IGluZGV4XG4gICAgICAgICAgICAgICAgfSwge30pO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IG5vZGUgb2Ygbm9kZXMpe1xuICAgICAgICAgICAgICAgICAgICBpbmRleCsrO1xuICAgICAgICAgICAgICAgICAgICB5aWVsZCBub2RlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRLZXkoaXRlbSwgcGFydGlhbE5vZGUsIHN0YXRlLCBwYXJlbnRLZXkpIHtcbiAgICAgICAgaWYgKGl0ZW0ua2V5ICE9IG51bGwpIHJldHVybiBpdGVtLmtleTtcbiAgICAgICAgaWYgKHBhcnRpYWxOb2RlLnR5cGUgPT09IFwiY2VsbFwiICYmIHBhcnRpYWxOb2RlLmtleSAhPSBudWxsKSByZXR1cm4gYCR7cGFyZW50S2V5fSR7cGFydGlhbE5vZGUua2V5fWA7XG4gICAgICAgIGxldCB2ID0gcGFydGlhbE5vZGUudmFsdWU7XG4gICAgICAgIGlmICh2ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBfdl9rZXk7XG4gICAgICAgICAgICBsZXQga2V5ID0gKF92X2tleSA9IHYua2V5KSAhPT0gbnVsbCAmJiBfdl9rZXkgIT09IHZvaWQgMCA/IF92X2tleSA6IHYuaWQ7XG4gICAgICAgICAgICBpZiAoa2V5ID09IG51bGwpIHRocm93IG5ldyBFcnJvcihcIk5vIGtleSBmb3VuZCBmb3IgaXRlbVwiKTtcbiAgICAgICAgICAgIHJldHVybiBrZXk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhcmVudEtleSA/IGAke3BhcmVudEtleX0uJHtwYXJ0aWFsTm9kZS5pbmRleH1gIDogYCQuJHtwYXJ0aWFsTm9kZS5pbmRleH1gO1xuICAgIH1cbiAgICBnZXRDaGlsZFN0YXRlKHN0YXRlLCBwYXJ0aWFsTm9kZSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmVuZGVyZXI6IHBhcnRpYWxOb2RlLnJlbmRlcmVyIHx8IHN0YXRlLnJlbmRlcmVyXG4gICAgICAgIH07XG4gICAgfVxuICAgICpnZXRGdWxsTm9kZShwYXJ0aWFsTm9kZSwgc3RhdGUsIHBhcmVudEtleSwgcGFyZW50Tm9kZSkge1xuICAgICAgICAvLyBJZiB0aGVyZSdzIGEgdmFsdWUgaW5zdGVhZCBvZiBhbiBlbGVtZW50IG9uIHRoZSBub2RlLCBhbmQgYSBwYXJlbnQgcmVuZGVyZXIgZnVuY3Rpb24gaXMgYXZhaWxhYmxlLFxuICAgICAgICAvLyB1c2UgaXQgdG8gcmVuZGVyIGFuIGVsZW1lbnQgZm9yIHRoZSB2YWx1ZS5cbiAgICAgICAgbGV0IGVsZW1lbnQgPSBwYXJ0aWFsTm9kZS5lbGVtZW50O1xuICAgICAgICBpZiAoIWVsZW1lbnQgJiYgcGFydGlhbE5vZGUudmFsdWUgJiYgc3RhdGUgJiYgc3RhdGUucmVuZGVyZXIpIHtcbiAgICAgICAgICAgIGxldCBjYWNoZWQgPSB0aGlzLmNhY2hlLmdldChwYXJ0aWFsTm9kZS52YWx1ZSk7XG4gICAgICAgICAgICBpZiAoY2FjaGVkICYmICghY2FjaGVkLnNob3VsZEludmFsaWRhdGUgfHwgIWNhY2hlZC5zaG91bGRJbnZhbGlkYXRlKHRoaXMuY29udGV4dCkpKSB7XG4gICAgICAgICAgICAgICAgY2FjaGVkLmluZGV4ID0gcGFydGlhbE5vZGUuaW5kZXg7XG4gICAgICAgICAgICAgICAgY2FjaGVkLnBhcmVudEtleSA9IHBhcmVudE5vZGUgPyBwYXJlbnROb2RlLmtleSA6IG51bGw7XG4gICAgICAgICAgICAgICAgeWllbGQgY2FjaGVkO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsZW1lbnQgPSBzdGF0ZS5yZW5kZXJlcihwYXJ0aWFsTm9kZS52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgdGhlcmUncyBhbiBlbGVtZW50IHdpdGggYSBnZXRDb2xsZWN0aW9uTm9kZSBmdW5jdGlvbiBvbiBpdHMgdHlwZSwgdGhlbiBpdCdzIGEgc3VwcG9ydGVkIGNvbXBvbmVudC5cbiAgICAgICAgLy8gQ2FsbCB0aGlzIGZ1bmN0aW9uIHRvIGdldCBhIHBhcnRpYWwgbm9kZSwgYW5kIHJlY3Vyc2l2ZWx5IGJ1aWxkIGEgZnVsbCBub2RlIGZyb20gdGhlcmUuXG4gICAgICAgIGlmICgoMCwgJHR5VzZBJHJlYWN0KS5pc1ZhbGlkRWxlbWVudChlbGVtZW50KSkge1xuICAgICAgICAgICAgbGV0IHR5cGUgPSBlbGVtZW50LnR5cGU7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHR5cGUgIT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgdHlwZS5nZXRDb2xsZWN0aW9uTm9kZSAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgbGV0IG5hbWUgPSB0eXBlb2YgZWxlbWVudC50eXBlID09PSBcImZ1bmN0aW9uXCIgPyBlbGVtZW50LnR5cGUubmFtZSA6IGVsZW1lbnQudHlwZTtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gZWxlbWVudCA8JHtuYW1lfT4gaW4gY29sbGVjdGlvbi5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBjaGlsZE5vZGVzID0gdHlwZS5nZXRDb2xsZWN0aW9uTm9kZShlbGVtZW50LnByb3BzLCB0aGlzLmNvbnRleHQpO1xuICAgICAgICAgICAgbGV0IGluZGV4ID0gcGFydGlhbE5vZGUuaW5kZXg7XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gY2hpbGROb2Rlcy5uZXh0KCk7XG4gICAgICAgICAgICB3aGlsZSghcmVzdWx0LmRvbmUgJiYgcmVzdWx0LnZhbHVlKXtcbiAgICAgICAgICAgICAgICBsZXQgY2hpbGROb2RlID0gcmVzdWx0LnZhbHVlO1xuICAgICAgICAgICAgICAgIHBhcnRpYWxOb2RlLmluZGV4ID0gaW5kZXg7XG4gICAgICAgICAgICAgICAgbGV0IG5vZGVLZXkgPSBjaGlsZE5vZGUua2V5O1xuICAgICAgICAgICAgICAgIGlmICghbm9kZUtleSkgbm9kZUtleSA9IGNoaWxkTm9kZS5lbGVtZW50ID8gbnVsbCA6IHRoaXMuZ2V0S2V5KGVsZW1lbnQsIHBhcnRpYWxOb2RlLCBzdGF0ZSwgcGFyZW50S2V5KTtcbiAgICAgICAgICAgICAgICBsZXQgbm9kZXMgPSB0aGlzLmdldEZ1bGxOb2RlKHtcbiAgICAgICAgICAgICAgICAgICAgLi4uY2hpbGROb2RlLFxuICAgICAgICAgICAgICAgICAgICBrZXk6IG5vZGVLZXksXG4gICAgICAgICAgICAgICAgICAgIGluZGV4OiBpbmRleCxcbiAgICAgICAgICAgICAgICAgICAgd3JhcHBlcjogJGViMjI0MGZjMzlhNTdmYTUkdmFyJGNvbXBvc2UocGFydGlhbE5vZGUud3JhcHBlciwgY2hpbGROb2RlLndyYXBwZXIpXG4gICAgICAgICAgICAgICAgfSwgdGhpcy5nZXRDaGlsZFN0YXRlKHN0YXRlLCBjaGlsZE5vZGUpLCBwYXJlbnRLZXkgPyBgJHtwYXJlbnRLZXl9JHtlbGVtZW50LmtleX1gIDogZWxlbWVudC5rZXksIHBhcmVudE5vZGUpO1xuICAgICAgICAgICAgICAgIGxldCBjaGlsZHJlbiA9IFtcbiAgICAgICAgICAgICAgICAgICAgLi4ubm9kZXNcbiAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IG5vZGUgb2YgY2hpbGRyZW4pe1xuICAgICAgICAgICAgICAgICAgICAvLyBDYWNoZSB0aGUgbm9kZSBiYXNlZCBvbiBpdHMgdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgbm9kZS52YWx1ZSA9IGNoaWxkTm9kZS52YWx1ZSB8fCBwYXJ0aWFsTm9kZS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUudmFsdWUpIHRoaXMuY2FjaGUuc2V0KG5vZGUudmFsdWUsIG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgcGFydGlhbCBub2RlIG1heSBoYXZlIHNwZWNpZmllZCBhIHR5cGUgZm9yIHRoZSBjaGlsZCBpbiBvcmRlciB0byBzcGVjaWZ5IGEgY29uc3RyYWludC5cbiAgICAgICAgICAgICAgICAgICAgLy8gVmVyaWZ5IHRoYXQgdGhlIGZ1bGwgbm9kZSB0aGF0IHdhcyBidWlsdCByZWN1cnNpdmVseSBtYXRjaGVzIHRoaXMgdHlwZS5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnRpYWxOb2RlLnR5cGUgJiYgbm9kZS50eXBlICE9PSBwYXJ0aWFsTm9kZS50eXBlKSB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIHR5cGUgPCR7JGViMjI0MGZjMzlhNTdmYTUkdmFyJGNhcGl0YWxpemUobm9kZS50eXBlKX0+IGluIDwkeyRlYjIyNDBmYzM5YTU3ZmE1JHZhciRjYXBpdGFsaXplKHBhcmVudE5vZGUudHlwZSl9Pi4gT25seSA8JHskZWIyMjQwZmMzOWE1N2ZhNSR2YXIkY2FwaXRhbGl6ZShwYXJ0aWFsTm9kZS50eXBlKX0+IGlzIHN1cHBvcnRlZC5gKTtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXgrKztcbiAgICAgICAgICAgICAgICAgICAgeWllbGQgbm9kZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gY2hpbGROb2Rlcy5uZXh0KGNoaWxkcmVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZ25vcmUgaW52YWxpZCBlbGVtZW50c1xuICAgICAgICBpZiAocGFydGlhbE5vZGUua2V5ID09IG51bGwpIHJldHVybjtcbiAgICAgICAgLy8gQ3JlYXRlIGZ1bGwgbm9kZVxuICAgICAgICBsZXQgYnVpbGRlciA9IHRoaXM7XG4gICAgICAgIGxldCBub2RlID0ge1xuICAgICAgICAgICAgdHlwZTogcGFydGlhbE5vZGUudHlwZSxcbiAgICAgICAgICAgIHByb3BzOiBwYXJ0aWFsTm9kZS5wcm9wcyxcbiAgICAgICAgICAgIGtleTogcGFydGlhbE5vZGUua2V5LFxuICAgICAgICAgICAgcGFyZW50S2V5OiBwYXJlbnROb2RlID8gcGFyZW50Tm9kZS5rZXkgOiBudWxsLFxuICAgICAgICAgICAgdmFsdWU6IHBhcnRpYWxOb2RlLnZhbHVlLFxuICAgICAgICAgICAgbGV2ZWw6IHBhcmVudE5vZGUgPyBwYXJlbnROb2RlLmxldmVsICsgMSA6IDAsXG4gICAgICAgICAgICBpbmRleDogcGFydGlhbE5vZGUuaW5kZXgsXG4gICAgICAgICAgICByZW5kZXJlZDogcGFydGlhbE5vZGUucmVuZGVyZWQsXG4gICAgICAgICAgICB0ZXh0VmFsdWU6IHBhcnRpYWxOb2RlLnRleHRWYWx1ZSxcbiAgICAgICAgICAgIFwiYXJpYS1sYWJlbFwiOiBwYXJ0aWFsTm9kZVtcImFyaWEtbGFiZWxcIl0sXG4gICAgICAgICAgICB3cmFwcGVyOiBwYXJ0aWFsTm9kZS53cmFwcGVyLFxuICAgICAgICAgICAgc2hvdWxkSW52YWxpZGF0ZTogcGFydGlhbE5vZGUuc2hvdWxkSW52YWxpZGF0ZSxcbiAgICAgICAgICAgIGhhc0NoaWxkTm9kZXM6IHBhcnRpYWxOb2RlLmhhc0NoaWxkTm9kZXMsXG4gICAgICAgICAgICBjaGlsZE5vZGVzOiAkZWIyMjQwZmMzOWE1N2ZhNSR2YXIkaXRlcmFibGUoZnVuY3Rpb24qKCkge1xuICAgICAgICAgICAgICAgIGlmICghcGFydGlhbE5vZGUuaGFzQ2hpbGROb2RlcykgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGxldCBpbmRleCA9IDA7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgY2hpbGQgb2YgcGFydGlhbE5vZGUuY2hpbGROb2RlcygpKXtcbiAgICAgICAgICAgICAgICAgICAgLy8gRW5zdXJlIGNoaWxkIGtleXMgYXJlIGdsb2JhbGx5IHVuaXF1ZSBieSBwcmVwZW5kaW5nIHRoZSBwYXJlbnQgbm9kZSdzIGtleVxuICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGQua2V5ICE9IG51bGwpIC8vIFRPRE86IFJlbW92ZSB0aGlzIGxpbmUgZW50aXJlbHkgYW5kIGVuZm9yY2UgdGhhdCB1c2VycyBhbHdheXMgcHJvdmlkZSB1bmlxdWUga2V5cy5cbiAgICAgICAgICAgICAgICAgICAgLy8gQ3VycmVudGx5IHRoaXMgbGluZSB3aWxsIGhhdmUgaXNzdWVzIHdoZW4gYSBwYXJlbnQgaGFzIGEga2V5IGBhYCBhbmQgYSBjaGlsZCB3aXRoIGtleSBgYmNgXG4gICAgICAgICAgICAgICAgICAgIC8vIGJ1dCBhbm90aGVyIHBhcmVudCBoYXMga2V5IGBhYmAgYW5kIGl0cyBjaGlsZCBoYXMgYSBrZXkgYGNgLiBUaGUgY29tYmluZWQga2V5cyB3b3VsZCByZXN1bHQgaW4gYm90aFxuICAgICAgICAgICAgICAgICAgICAvLyBjaGlsZHJlbiBoYXZpbmcgYSBrZXkgb2YgYGFiY2AuXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkLmtleSA9IGAke25vZGUua2V5fSR7Y2hpbGQua2V5fWA7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkLmluZGV4ID0gaW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIGxldCBub2RlcyA9IGJ1aWxkZXIuZ2V0RnVsbE5vZGUoY2hpbGQsIGJ1aWxkZXIuZ2V0Q2hpbGRTdGF0ZShzdGF0ZSwgY2hpbGQpLCBub2RlLmtleSwgbm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IG5vZGUgb2Ygbm9kZXMpe1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXgrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIHlpZWxkIG5vZGU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICB9O1xuICAgICAgICB5aWVsZCBub2RlO1xuICAgIH1cbiAgICBjb25zdHJ1Y3Rvcigpe1xuICAgICAgICB0aGlzLmNhY2hlID0gbmV3IFdlYWtNYXAoKTtcbiAgICB9XG59XG4vLyBXcmFwcyBhbiBpdGVyYXRvciBmdW5jdGlvbiBhcyBhbiBpdGVyYWJsZSBvYmplY3QsIGFuZCBjYWNoZXMgdGhlIHJlc3VsdHMuXG5mdW5jdGlvbiAkZWIyMjQwZmMzOWE1N2ZhNSR2YXIkaXRlcmFibGUoaXRlcmF0b3IpIHtcbiAgICBsZXQgY2FjaGUgPSBbXTtcbiAgICBsZXQgaXRlcmFibGUgPSBudWxsO1xuICAgIHJldHVybiB7XG4gICAgICAgICpbU3ltYm9sLml0ZXJhdG9yXSAoKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpdGVtIG9mIGNhY2hlKXlpZWxkIGl0ZW07XG4gICAgICAgICAgICBpZiAoIWl0ZXJhYmxlKSBpdGVyYWJsZSA9IGl0ZXJhdG9yKCk7XG4gICAgICAgICAgICBmb3IgKGxldCBpdGVtIG9mIGl0ZXJhYmxlKXtcbiAgICAgICAgICAgICAgICBjYWNoZS5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgICAgIHlpZWxkIGl0ZW07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xufVxuZnVuY3Rpb24gJGViMjI0MGZjMzlhNTdmYTUkdmFyJGNvbXBvc2Uob3V0ZXIsIGlubmVyKSB7XG4gICAgaWYgKG91dGVyICYmIGlubmVyKSByZXR1cm4gKGVsZW1lbnQpPT5vdXRlcihpbm5lcihlbGVtZW50KSk7XG4gICAgaWYgKG91dGVyKSByZXR1cm4gb3V0ZXI7XG4gICAgaWYgKGlubmVyKSByZXR1cm4gaW5uZXI7XG59XG5mdW5jdGlvbiAkZWIyMjQwZmMzOWE1N2ZhNSR2YXIkY2FwaXRhbGl6ZShzdHIpIHtcbiAgICByZXR1cm4gc3RyWzBdLnRvVXBwZXJDYXNlKCkgKyBzdHIuc2xpY2UoMSk7XG59XG5cblxuXG5mdW5jdGlvbiAkNzYxM2IxNTkyZDQxYjA5MiRleHBvcnQkNmNkMjg4MTRkOTJmYTljOShwcm9wcywgZmFjdG9yeSwgY29udGV4dCkge1xuICAgIGxldCBidWlsZGVyID0gKDAsICR0eVc2QSR1c2VNZW1vKSgoKT0+bmV3ICgwLCAkZWIyMjQwZmMzOWE1N2ZhNSRleHBvcnQkYmY3ODhkZDM1NWUzYTQwMSkoKSwgW10pO1xuICAgIGxldCB7IGNoaWxkcmVuOiBjaGlsZHJlbiwgaXRlbXM6IGl0ZW1zLCBjb2xsZWN0aW9uOiBjb2xsZWN0aW9uIH0gPSBwcm9wcztcbiAgICBsZXQgcmVzdWx0ID0gKDAsICR0eVc2QSR1c2VNZW1vKSgoKT0+e1xuICAgICAgICBpZiAoY29sbGVjdGlvbikgcmV0dXJuIGNvbGxlY3Rpb247XG4gICAgICAgIGxldCBub2RlcyA9IGJ1aWxkZXIuYnVpbGQoe1xuICAgICAgICAgICAgY2hpbGRyZW46IGNoaWxkcmVuLFxuICAgICAgICAgICAgaXRlbXM6IGl0ZW1zXG4gICAgICAgIH0sIGNvbnRleHQpO1xuICAgICAgICByZXR1cm4gZmFjdG9yeShub2Rlcyk7XG4gICAgfSwgW1xuICAgICAgICBidWlsZGVyLFxuICAgICAgICBjaGlsZHJlbixcbiAgICAgICAgaXRlbXMsXG4gICAgICAgIGNvbGxlY3Rpb24sXG4gICAgICAgIGNvbnRleHQsXG4gICAgICAgIGZhY3RvcnlcbiAgICBdKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG5cbi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyAvKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gZnVuY3Rpb24gJGM1YTI0YmM0Nzg2NTJiNWYkZXhwb3J0JDEwMDU1MzBlZGEwMTZjMTMobm9kZSwgY29sbGVjdGlvbikge1xuICAgIC8vIE5ldyBBUEk6IGNhbGwgY29sbGVjdGlvbi5nZXRDaGlsZHJlbiB3aXRoIHRoZSBub2RlIGtleS5cbiAgICBpZiAodHlwZW9mIGNvbGxlY3Rpb24uZ2V0Q2hpbGRyZW4gPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIGNvbGxlY3Rpb24uZ2V0Q2hpbGRyZW4obm9kZS5rZXkpO1xuICAgIC8vIE9sZCBBUEk6IGFjY2VzcyBjaGlsZE5vZGVzIGRpcmVjdGx5LlxuICAgIHJldHVybiBub2RlLmNoaWxkTm9kZXM7XG59XG5mdW5jdGlvbiAkYzVhMjRiYzQ3ODY1MmI1ZiRleHBvcnQkZmJkZWFhNmE3NjY5NGY3MShpdGVyYWJsZSkge1xuICAgIHJldHVybiAkYzVhMjRiYzQ3ODY1MmI1ZiRleHBvcnQkNWYzMzk4Zjg3MzNmOTBlMihpdGVyYWJsZSwgMCk7XG59XG5mdW5jdGlvbiAkYzVhMjRiYzQ3ODY1MmI1ZiRleHBvcnQkNWYzMzk4Zjg3MzNmOTBlMihpdGVyYWJsZSwgaW5kZXgpIHtcbiAgICBpZiAoaW5kZXggPCAwKSByZXR1cm4gdW5kZWZpbmVkO1xuICAgIGxldCBpID0gMDtcbiAgICBmb3IgKGxldCBpdGVtIG9mIGl0ZXJhYmxlKXtcbiAgICAgICAgaWYgKGkgPT09IGluZGV4KSByZXR1cm4gaXRlbTtcbiAgICAgICAgaSsrO1xuICAgIH1cbn1cbmZ1bmN0aW9uICRjNWEyNGJjNDc4NjUyYjVmJGV4cG9ydCQ3NDc1YjJjNjQ1MzllNGNmKGl0ZXJhYmxlKSB7XG4gICAgbGV0IGxhc3RJdGVtID0gdW5kZWZpbmVkO1xuICAgIGZvciAobGV0IHZhbHVlIG9mIGl0ZXJhYmxlKWxhc3RJdGVtID0gdmFsdWU7XG4gICAgcmV0dXJuIGxhc3RJdGVtO1xufVxuZnVuY3Rpb24gJGM1YTI0YmM0Nzg2NTJiNWYkZXhwb3J0JDhjNDM0YjNhN2E0ZGFkNihjb2xsZWN0aW9uLCBhLCBiKSB7XG4gICAgLy8gSWYgdGhlIHR3byBub2RlcyBoYXZlIHRoZSBzYW1lIHBhcmVudCwgY29tcGFyZSB0aGVpciBpbmRpY2VzLlxuICAgIGlmIChhLnBhcmVudEtleSA9PT0gYi5wYXJlbnRLZXkpIHJldHVybiBhLmluZGV4IC0gYi5pbmRleDtcbiAgICAvLyBPdGhlcndpc2UsIGNvbGxlY3QgYWxsIG9mIHRoZSBhbmNlc3RvcnMgZnJvbSBlYWNoIG5vZGUsIGFuZCBmaW5kIHRoZSBmaXJzdCBvbmUgdGhhdCBkb2Vzbid0IG1hdGNoIHN0YXJ0aW5nIGZyb20gdGhlIHJvb3QuXG4gICAgLy8gSW5jbHVkZSB0aGUgYmFzZSBub2RlcyBpbiBjYXNlIHdlIGFyZSBjb21wYXJpbmcgbm9kZXMgb2YgZGlmZmVyZW50IGxldmVscyBzbyB0aGF0IHdlIGNhbiBjb21wYXJlIHRoZSBoaWdoZXIgbm9kZSB0byB0aGUgbG93ZXIgbGV2ZWwgbm9kZSdzXG4gICAgLy8gYW5jZXN0b3Igb2YgdGhlIHNhbWUgbGV2ZWxcbiAgICBsZXQgYUFuY2VzdG9ycyA9IFtcbiAgICAgICAgLi4uJGM1YTI0YmM0Nzg2NTJiNWYkdmFyJGdldEFuY2VzdG9ycyhjb2xsZWN0aW9uLCBhKSxcbiAgICAgICAgYVxuICAgIF07XG4gICAgbGV0IGJBbmNlc3RvcnMgPSBbXG4gICAgICAgIC4uLiRjNWEyNGJjNDc4NjUyYjVmJHZhciRnZXRBbmNlc3RvcnMoY29sbGVjdGlvbiwgYiksXG4gICAgICAgIGJcbiAgICBdO1xuICAgIGxldCBmaXJzdE5vbk1hdGNoaW5nQW5jZXN0b3IgPSBhQW5jZXN0b3JzLnNsaWNlKDAsIGJBbmNlc3RvcnMubGVuZ3RoKS5maW5kSW5kZXgoKGEsIGkpPT5hICE9PSBiQW5jZXN0b3JzW2ldKTtcbiAgICBpZiAoZmlyc3ROb25NYXRjaGluZ0FuY2VzdG9yICE9PSAtMSkge1xuICAgICAgICAvLyBDb21wYXJlIHRoZSBpbmRpY2VzIG9mIHR3byBjaGlsZHJlbiB3aXRoaW4gdGhlIGNvbW1vbiBhbmNlc3Rvci5cbiAgICAgICAgYSA9IGFBbmNlc3RvcnNbZmlyc3ROb25NYXRjaGluZ0FuY2VzdG9yXTtcbiAgICAgICAgYiA9IGJBbmNlc3RvcnNbZmlyc3ROb25NYXRjaGluZ0FuY2VzdG9yXTtcbiAgICAgICAgcmV0dXJuIGEuaW5kZXggLSBiLmluZGV4O1xuICAgIH1cbiAgICAvLyBJZiB0aGVyZSBpc24ndCBhIG5vbiBtYXRjaGluZyBhbmNlc3Rvciwgd2UgbWlnaHQgYmUgaW4gYSBjYXNlIHdoZXJlIG9uZSBvZiB0aGUgbm9kZXMgaXMgdGhlIGFuY2VzdG9yIG9mIHRoZSBvdGhlci5cbiAgICBpZiAoYUFuY2VzdG9ycy5maW5kSW5kZXgoKG5vZGUpPT5ub2RlID09PSBiKSA+PSAwKSByZXR1cm4gMTtcbiAgICBlbHNlIGlmIChiQW5jZXN0b3JzLmZpbmRJbmRleCgobm9kZSk9Pm5vZGUgPT09IGEpID49IDApIHJldHVybiAtMTtcbiAgICAvLyDwn6S3XG4gICAgcmV0dXJuIC0xO1xufVxuZnVuY3Rpb24gJGM1YTI0YmM0Nzg2NTJiNWYkdmFyJGdldEFuY2VzdG9ycyhjb2xsZWN0aW9uLCBub2RlKSB7XG4gICAgbGV0IHBhcmVudHMgPSBbXTtcbiAgICB3aGlsZSgobm9kZSA9PT0gbnVsbCB8fCBub2RlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBub2RlLnBhcmVudEtleSkgIT0gbnVsbCl7XG4gICAgICAgIG5vZGUgPSBjb2xsZWN0aW9uLmdldEl0ZW0obm9kZS5wYXJlbnRLZXkpO1xuICAgICAgICBwYXJlbnRzLnVuc2hpZnQobm9kZSk7XG4gICAgfVxuICAgIHJldHVybiBwYXJlbnRzO1xufVxuXG5cbmNvbnN0ICQ0NTNjYzlmMGRmODljMGE1JHZhciRjYWNoZSA9IG5ldyBXZWFrTWFwKCk7XG5mdW5jdGlvbiAkNDUzY2M5ZjBkZjg5YzBhNSRleHBvcnQkNzdkNWFhZmFlNGUwOTViMihjb2xsZWN0aW9uKSB7XG4gICAgbGV0IGNvdW50ID0gJDQ1M2NjOWYwZGY4OWMwYTUkdmFyJGNhY2hlLmdldChjb2xsZWN0aW9uKTtcbiAgICBpZiAoY291bnQgIT0gbnVsbCkgcmV0dXJuIGNvdW50O1xuICAgIGNvdW50ID0gMDtcbiAgICBsZXQgY291bnRJdGVtcyA9IChpdGVtcyk9PntcbiAgICAgICAgZm9yIChsZXQgaXRlbSBvZiBpdGVtcylpZiAoaXRlbS50eXBlID09PSBcInNlY3Rpb25cIikgY291bnRJdGVtcygoMCwgJGM1YTI0YmM0Nzg2NTJiNWYkZXhwb3J0JDEwMDU1MzBlZGEwMTZjMTMpKGl0ZW0sIGNvbGxlY3Rpb24pKTtcbiAgICAgICAgZWxzZSBjb3VudCsrO1xuICAgIH07XG4gICAgY291bnRJdGVtcyhjb2xsZWN0aW9uKTtcbiAgICAkNDUzY2M5ZjBkZjg5YzBhNSR2YXIkY2FjaGUuc2V0KGNvbGxlY3Rpb24sIGNvdW50KTtcbiAgICByZXR1cm4gY291bnQ7XG59XG5cblxuXG5cblxuXG5leHBvcnQgeyRjMWQ3ZmIyZWM5MWJhZTcxJGV4cG9ydCQ2ZDA4NzczZDJlNjZmOGYyIGFzIEl0ZW0sICQ5ZmM0ODUyNzcxZDA3OWViJGV4cG9ydCQ2ZTJjOGYwODExYTQ3NGNlIGFzIFNlY3Rpb24sICQ3NjEzYjE1OTJkNDFiMDkyJGV4cG9ydCQ2Y2QyODgxNGQ5MmZhOWM5IGFzIHVzZUNvbGxlY3Rpb24sICQ0NTNjYzlmMGRmODljMGE1JGV4cG9ydCQ3N2Q1YWFmYWU0ZTA5NWIyIGFzIGdldEl0ZW1Db3VudCwgJGM1YTI0YmM0Nzg2NTJiNWYkZXhwb3J0JDEwMDU1MzBlZGEwMTZjMTMgYXMgZ2V0Q2hpbGROb2RlcywgJGM1YTI0YmM0Nzg2NTJiNWYkZXhwb3J0JGZiZGVhYTZhNzY2OTRmNzEgYXMgZ2V0Rmlyc3RJdGVtLCAkYzVhMjRiYzQ3ODY1MmI1ZiRleHBvcnQkNzQ3NWIyYzY0NTM5ZTRjZiBhcyBnZXRMYXN0SXRlbSwgJGM1YTI0YmM0Nzg2NTJiNWYkZXhwb3J0JDVmMzM5OGY4NzMzZjkwZTIgYXMgZ2V0TnRoSXRlbSwgJGM1YTI0YmM0Nzg2NTJiNWYkZXhwb3J0JDhjNDM0YjNhN2E0ZGFkNiBhcyBjb21wYXJlTm9kZU9yZGVyLCAkZWIyMjQwZmMzOWE1N2ZhNSRleHBvcnQkYmY3ODhkZDM1NWUzYTQwMSBhcyBDb2xsZWN0aW9uQnVpbGRlcn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tb2R1bGUuanMubWFwXG4iXSwibmFtZXMiOlsiJHR5VzZBJHJlYWN0IiwidXNlTWVtbyIsIiR0eVc2QSR1c2VNZW1vIiwiJGMxZDdmYjJlYzkxYmFlNzEkdmFyJEl0ZW0iLCJwcm9wcyIsImdldENvbGxlY3Rpb25Ob2RlIiwiY29udGV4dCIsImNoaWxkSXRlbXMiLCJ0aXRsZSIsImNoaWxkcmVuIiwicmVuZGVyZWQiLCJ0ZXh0VmFsdWUiLCJzdXBwcmVzc1RleHRWYWx1ZVdhcm5pbmciLCJjb25zb2xlIiwid2FybiIsInR5cGUiLCJoYXNDaGlsZE5vZGVzIiwiJGMxZDdmYjJlYzkxYmFlNzEkdmFyJGhhc0NoaWxkSXRlbXMiLCJjaGlsZE5vZGVzIiwiY2hpbGQiLCJ2YWx1ZSIsIml0ZW1zIiwiQ2hpbGRyZW4iLCJmb3JFYWNoIiwicHVzaCIsImVsZW1lbnQiLCJoYXNDaGlsZEl0ZW1zIiwiY291bnQiLCIkYzFkN2ZiMmVjOTFiYWU3MSRleHBvcnQkNmQwODc3M2QyZTY2ZjhmMiIsIiQ5ZmM0ODUyNzcxZDA3OWViJHZhciRTZWN0aW9uIiwiRXJyb3IiLCJpdGVtIiwicmVuZGVyZXIiLCIkOWZjNDg1Mjc3MWQwNzllYiRleHBvcnQkNmUyYzhmMDgxMWE0NzRjZSIsIiRlYjIyNDBmYzM5YTU3ZmE1JGV4cG9ydCRiZjc4OGRkMzU1ZTNhNDAxIiwiYnVpbGQiLCIkZWIyMjQwZmMzOWE1N2ZhNSR2YXIkaXRlcmFibGUiLCJpdGVyYXRlQ29sbGVjdGlvbiIsImdldEZ1bGxOb2RlIiwiaW5kZXgiLCJub2RlcyIsIm5vZGUiLCJnZXRLZXkiLCJwYXJ0aWFsTm9kZSIsInN0YXRlIiwicGFyZW50S2V5Iiwia2V5IiwidiIsIl92X2tleSIsImlkIiwiZ2V0Q2hpbGRTdGF0ZSIsInBhcmVudE5vZGUiLCJjYWNoZWQiLCJjYWNoZSIsImdldCIsInNob3VsZEludmFsaWRhdGUiLCJpc1ZhbGlkRWxlbWVudCIsIm5hbWUiLCJyZXN1bHQiLCJuZXh0IiwiZG9uZSIsImNoaWxkTm9kZSIsIm5vZGVLZXkiLCJ3cmFwcGVyIiwiJGViMjI0MGZjMzlhNTdmYTUkdmFyJGNvbXBvc2UiLCJzZXQiLCIkZWIyMjQwZmMzOWE1N2ZhNSR2YXIkY2FwaXRhbGl6ZSIsImJ1aWxkZXIiLCJsZXZlbCIsImNvbnN0cnVjdG9yIiwiV2Vha01hcCIsIml0ZXJhdG9yIiwiaXRlcmFibGUiLCJTeW1ib2wiLCJvdXRlciIsImlubmVyIiwic3RyIiwidG9VcHBlckNhc2UiLCJzbGljZSIsIiQ3NjEzYjE1OTJkNDFiMDkyJGV4cG9ydCQ2Y2QyODgxNGQ5MmZhOWM5IiwiZmFjdG9yeSIsImNvbGxlY3Rpb24iLCIkYzVhMjRiYzQ3ODY1MmI1ZiRleHBvcnQkMTAwNTUzMGVkYTAxNmMxMyIsImdldENoaWxkcmVuIiwiJGM1YTI0YmM0Nzg2NTJiNWYkZXhwb3J0JGZiZGVhYTZhNzY2OTRmNzEiLCIkYzVhMjRiYzQ3ODY1MmI1ZiRleHBvcnQkNWYzMzk4Zjg3MzNmOTBlMiIsInVuZGVmaW5lZCIsImkiLCIkYzVhMjRiYzQ3ODY1MmI1ZiRleHBvcnQkNzQ3NWIyYzY0NTM5ZTRjZiIsImxhc3RJdGVtIiwiJGM1YTI0YmM0Nzg2NTJiNWYkZXhwb3J0JDhjNDM0YjNhN2E0ZGFkNiIsImEiLCJiIiwiYUFuY2VzdG9ycyIsIiRjNWEyNGJjNDc4NjUyYjVmJHZhciRnZXRBbmNlc3RvcnMiLCJiQW5jZXN0b3JzIiwiZmlyc3ROb25NYXRjaGluZ0FuY2VzdG9yIiwibGVuZ3RoIiwiZmluZEluZGV4IiwicGFyZW50cyIsImdldEl0ZW0iLCJ1bnNoaWZ0IiwiJDQ1M2NjOWYwZGY4OWMwYTUkdmFyJGNhY2hlIiwiJDQ1M2NjOWYwZGY4OWMwYTUkZXhwb3J0JDc3ZDVhYWZhZTRlMDk1YjIiLCJjb3VudEl0ZW1zIiwiSXRlbSIsIlNlY3Rpb24iLCJ1c2VDb2xsZWN0aW9uIiwiZ2V0SXRlbUNvdW50IiwiZ2V0Q2hpbGROb2RlcyIsImdldEZpcnN0SXRlbSIsImdldExhc3RJdGVtIiwiZ2V0TnRoSXRlbSIsImNvbXBhcmVOb2RlT3JkZXIiLCJDb2xsZWN0aW9uQnVpbGRlciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-stately/collections/dist/import.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-stately/combobox/dist/import.mjs":
/*!**************************************************************!*\
  !*** ./node_modules/@react-stately/combobox/dist/import.mjs ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useComboBoxState: () => (/* binding */ $a9e7382a7d111cb5$export$b453a3bfd4a5fa9e)\n/* harmony export */ });\n/* harmony import */ var _react_stately_form__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @react-stately/form */ \"(ssr)/./node_modules/@react-stately/form/dist/import.mjs\");\n/* harmony import */ var _react_stately_collections__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @react-stately/collections */ \"(ssr)/./node_modules/@react-stately/collections/dist/import.mjs\");\n/* harmony import */ var _react_stately_list__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @react-stately/list */ \"(ssr)/./node_modules/@react-stately/list/dist/import.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _react_stately_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @react-stately/utils */ \"(ssr)/./node_modules/@react-stately/utils/dist/import.mjs\");\n/* harmony import */ var _react_stately_overlays__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @react-stately/overlays */ \"(ssr)/./node_modules/@react-stately/overlays/dist/import.mjs\");\n\n\n\n\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n * \n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ function $a9e7382a7d111cb5$export$b453a3bfd4a5fa9e(props) {\n    var _collection_getItem, _collection_getItem1;\n    let { defaultFilter: defaultFilter, menuTrigger: menuTrigger = \"input\", allowsEmptyCollection: allowsEmptyCollection = false, allowsCustomValue: allowsCustomValue, shouldCloseOnBlur: shouldCloseOnBlur = true } = props;\n    let [showAllItems, setShowAllItems] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    let [isFocused, setFocusedState] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    let [focusStrategy, setFocusStrategy] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    let onSelectionChange = (key)=>{\n        if (props.onSelectionChange) props.onSelectionChange(key);\n        // If key is the same, reset the inputValue and close the menu\n        // (scenario: user clicks on already selected option)\n        if (key === selectedKey) {\n            resetInputValue();\n            closeMenu();\n        }\n    };\n    var _props_items;\n    let { collection: collection, selectionManager: selectionManager, selectedKey: selectedKey, setSelectedKey: setSelectedKey, selectedItem: selectedItem, disabledKeys: disabledKeys } = (0, _react_stately_list__WEBPACK_IMPORTED_MODULE_1__.useSingleSelectListState)({\n        ...props,\n        onSelectionChange: onSelectionChange,\n        items: (_props_items = props.items) !== null && _props_items !== void 0 ? _props_items : props.defaultItems\n    });\n    var _props_defaultInputValue, _ref;\n    let [inputValue, setInputValue] = (0, _react_stately_utils__WEBPACK_IMPORTED_MODULE_2__.useControlledState)(props.inputValue, (_ref = (_props_defaultInputValue = props.defaultInputValue) !== null && _props_defaultInputValue !== void 0 ? _props_defaultInputValue : (_collection_getItem = collection.getItem(selectedKey)) === null || _collection_getItem === void 0 ? void 0 : _collection_getItem.textValue) !== null && _ref !== void 0 ? _ref : \"\", props.onInputChange);\n    // Preserve original collection so we can show all items on demand\n    let originalCollection = collection;\n    let filteredCollection = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>props.items != null || !defaultFilter ? collection : $a9e7382a7d111cb5$var$filterCollection(collection, inputValue, defaultFilter), [\n        collection,\n        inputValue,\n        defaultFilter,\n        props.items\n    ]);\n    let [lastCollection, setLastCollection] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(filteredCollection);\n    // Track what action is attempting to open the menu\n    let menuOpenTrigger = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)(\"focus\");\n    let onOpenChange = (open)=>{\n        if (props.onOpenChange) props.onOpenChange(open, open ? menuOpenTrigger.current : undefined);\n        selectionManager.setFocused(open);\n        if (!open) selectionManager.setFocusedKey(null);\n    };\n    let triggerState = (0, _react_stately_overlays__WEBPACK_IMPORTED_MODULE_3__.useOverlayTriggerState)({\n        ...props,\n        onOpenChange: onOpenChange,\n        isOpen: undefined,\n        defaultOpen: undefined\n    });\n    let open = (focusStrategy = null, trigger)=>{\n        let displayAllItems = trigger === \"manual\" || trigger === \"focus\" && menuTrigger === \"focus\";\n        // Prevent open operations from triggering if there is nothing to display\n        // Also prevent open operations from triggering if items are uncontrolled but defaultItems is empty, even if displayAllItems is true.\n        // This is to prevent comboboxes with empty defaultItems from opening but allow controlled items comboboxes to open even if the inital list is empty (assumption is user will provide swap the empty list with a base list via onOpenChange returning `menuTrigger` manual)\n        if (allowsEmptyCollection || filteredCollection.size > 0 || displayAllItems && originalCollection.size > 0 || props.items) {\n            if (displayAllItems && !triggerState.isOpen && props.items === undefined) setShowAllItems(true);\n            menuOpenTrigger.current = trigger;\n            setFocusStrategy(focusStrategy);\n            triggerState.open();\n        }\n    };\n    let toggle = (focusStrategy = null, trigger)=>{\n        let displayAllItems = trigger === \"manual\" || trigger === \"focus\" && menuTrigger === \"focus\";\n        // If the menu is closed and there is nothing to display, early return so toggle isn't called to prevent extraneous onOpenChange\n        if (!(allowsEmptyCollection || filteredCollection.size > 0 || displayAllItems && originalCollection.size > 0 || props.items) && !triggerState.isOpen) return;\n        if (displayAllItems && !triggerState.isOpen && props.items === undefined) setShowAllItems(true);\n        // Only update the menuOpenTrigger if menu is currently closed\n        if (!triggerState.isOpen) menuOpenTrigger.current = trigger;\n        toggleMenu(focusStrategy);\n    };\n    let updateLastCollection = (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        setLastCollection(showAllItems ? originalCollection : filteredCollection);\n    }, [\n        showAllItems,\n        originalCollection,\n        filteredCollection\n    ]);\n    // If menu is going to close, save the current collection so we can freeze the displayed collection when the\n    // user clicks outside the popover to close the menu. Prevents the menu contents from updating as the menu closes.\n    let toggleMenu = (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((focusStrategy = null)=>{\n        if (triggerState.isOpen) updateLastCollection();\n        setFocusStrategy(focusStrategy);\n        triggerState.toggle();\n    }, [\n        triggerState,\n        updateLastCollection\n    ]);\n    let closeMenu = (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        if (triggerState.isOpen) {\n            updateLastCollection();\n            triggerState.close();\n        }\n    }, [\n        triggerState,\n        updateLastCollection\n    ]);\n    let [lastValue, setLastValue] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(inputValue);\n    let resetInputValue = ()=>{\n        var _collection_getItem;\n        var _collection_getItem_textValue;\n        let itemText = (_collection_getItem_textValue = (_collection_getItem = collection.getItem(selectedKey)) === null || _collection_getItem === void 0 ? void 0 : _collection_getItem.textValue) !== null && _collection_getItem_textValue !== void 0 ? _collection_getItem_textValue : \"\";\n        setLastValue(itemText);\n        setInputValue(itemText);\n    };\n    var _props_selectedKey, _ref1;\n    let lastSelectedKey = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)((_ref1 = (_props_selectedKey = props.selectedKey) !== null && _props_selectedKey !== void 0 ? _props_selectedKey : props.defaultSelectedKey) !== null && _ref1 !== void 0 ? _ref1 : null);\n    var _collection_getItem_textValue;\n    let lastSelectedKeyText = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)((_collection_getItem_textValue = (_collection_getItem1 = collection.getItem(selectedKey)) === null || _collection_getItem1 === void 0 ? void 0 : _collection_getItem1.textValue) !== null && _collection_getItem_textValue !== void 0 ? _collection_getItem_textValue : \"\");\n    // intentional omit dependency array, want this to happen on every render\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    (0, react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        var _collection_getItem;\n        // Open and close menu automatically when the input value changes if the input is focused,\n        // and there are items in the collection or allowEmptyCollection is true.\n        if (isFocused && (filteredCollection.size > 0 || allowsEmptyCollection) && !triggerState.isOpen && inputValue !== lastValue && menuTrigger !== \"manual\") open(null, \"input\");\n        // Close the menu if the collection is empty. Don't close menu if filtered collection size is 0\n        // but we are currently showing all items via button press\n        if (!showAllItems && !allowsEmptyCollection && triggerState.isOpen && filteredCollection.size === 0) closeMenu();\n        // Close when an item is selected.\n        if (selectedKey != null && selectedKey !== lastSelectedKey.current) closeMenu();\n        // Clear focused key when input value changes and display filtered collection again.\n        if (inputValue !== lastValue) {\n            selectionManager.setFocusedKey(null);\n            setShowAllItems(false);\n            // Set selectedKey to null when the user clears the input.\n            // If controlled, this is the application developer's responsibility.\n            if (inputValue === \"\" && (props.inputValue === undefined || props.selectedKey === undefined)) setSelectedKey(null);\n        }\n        // If the selectedKey changed, update the input value.\n        // Do nothing if both inputValue and selectedKey are controlled.\n        // In this case, it's the user's responsibility to update inputValue in onSelectionChange.\n        if (selectedKey !== lastSelectedKey.current && (props.inputValue === undefined || props.selectedKey === undefined)) resetInputValue();\n        else if (lastValue !== inputValue) setLastValue(inputValue);\n        var _collection_getItem_textValue;\n        // Update the inputValue if the selected item's text changes from its last tracked value.\n        // This is to handle cases where a selectedKey is specified but the items aren't available (async loading) or the selected item's text value updates.\n        // Only reset if the user isn't currently within the field so we don't erroneously modify user input.\n        // If inputValue is controlled, it is the user's responsibility to update the inputValue when items change.\n        let selectedItemText = (_collection_getItem_textValue = (_collection_getItem = collection.getItem(selectedKey)) === null || _collection_getItem === void 0 ? void 0 : _collection_getItem.textValue) !== null && _collection_getItem_textValue !== void 0 ? _collection_getItem_textValue : \"\";\n        if (!isFocused && selectedKey != null && props.inputValue === undefined && selectedKey === lastSelectedKey.current) {\n            if (lastSelectedKeyText.current !== selectedItemText) {\n                setLastValue(selectedItemText);\n                setInputValue(selectedItemText);\n            }\n        }\n        lastSelectedKey.current = selectedKey;\n        lastSelectedKeyText.current = selectedItemText;\n    });\n    let validation = (0, _react_stately_form__WEBPACK_IMPORTED_MODULE_4__.useFormValidationState)({\n        ...props,\n        value: (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>({\n                inputValue: inputValue,\n                selectedKey: selectedKey\n            }), [\n            inputValue,\n            selectedKey\n        ])\n    });\n    // Revert input value and close menu\n    let revert = ()=>{\n        if (allowsCustomValue && selectedKey == null) commitCustomValue();\n        else commitSelection();\n    };\n    let commitCustomValue = ()=>{\n        lastSelectedKey.current = null;\n        setSelectedKey(null);\n        closeMenu();\n    };\n    let commitSelection = ()=>{\n        // If multiple things are controlled, call onSelectionChange\n        if (props.selectedKey !== undefined && props.inputValue !== undefined) {\n            var _collection_getItem;\n            props.onSelectionChange(selectedKey);\n            var _collection_getItem_textValue;\n            // Stop menu from reopening from useEffect\n            let itemText = (_collection_getItem_textValue = (_collection_getItem = collection.getItem(selectedKey)) === null || _collection_getItem === void 0 ? void 0 : _collection_getItem.textValue) !== null && _collection_getItem_textValue !== void 0 ? _collection_getItem_textValue : \"\";\n            setLastValue(itemText);\n            closeMenu();\n        } else {\n            // If only a single aspect of combobox is controlled, reset input value and close menu for the user\n            resetInputValue();\n            closeMenu();\n        }\n    };\n    const commitValue = ()=>{\n        if (allowsCustomValue) {\n            var _collection_getItem;\n            var _collection_getItem_textValue;\n            const itemText = (_collection_getItem_textValue = (_collection_getItem = collection.getItem(selectedKey)) === null || _collection_getItem === void 0 ? void 0 : _collection_getItem.textValue) !== null && _collection_getItem_textValue !== void 0 ? _collection_getItem_textValue : \"\";\n            inputValue === itemText ? commitSelection() : commitCustomValue();\n        } else commitSelection();\n    };\n    let commit = ()=>{\n        if (triggerState.isOpen && selectionManager.focusedKey != null) {\n            // Reset inputValue and close menu here if the selected key is already the focused key. Otherwise\n            // fire onSelectionChange to allow the application to control the closing.\n            if (selectedKey === selectionManager.focusedKey) commitSelection();\n            else setSelectedKey(selectionManager.focusedKey);\n        } else commitValue();\n    };\n    let valueOnFocus = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)(inputValue);\n    let setFocused = (isFocused)=>{\n        if (isFocused) {\n            valueOnFocus.current = inputValue;\n            if (menuTrigger === \"focus\") open(null, \"focus\");\n        } else {\n            if (shouldCloseOnBlur) commitValue();\n            if (inputValue !== valueOnFocus.current) validation.commitValidation();\n        }\n        setFocusedState(isFocused);\n    };\n    let displayedCollection = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        if (triggerState.isOpen) {\n            if (showAllItems) return originalCollection;\n            else return filteredCollection;\n        } else return lastCollection;\n    }, [\n        triggerState.isOpen,\n        originalCollection,\n        filteredCollection,\n        showAllItems,\n        lastCollection\n    ]);\n    return {\n        ...validation,\n        ...triggerState,\n        focusStrategy: focusStrategy,\n        toggle: toggle,\n        open: open,\n        close: commitValue,\n        selectionManager: selectionManager,\n        selectedKey: selectedKey,\n        setSelectedKey: setSelectedKey,\n        disabledKeys: disabledKeys,\n        isFocused: isFocused,\n        setFocused: setFocused,\n        selectedItem: selectedItem,\n        collection: displayedCollection,\n        inputValue: inputValue,\n        setInputValue: setInputValue,\n        commit: commit,\n        revert: revert\n    };\n}\nfunction $a9e7382a7d111cb5$var$filterCollection(collection, inputValue, filter) {\n    return new (0, _react_stately_list__WEBPACK_IMPORTED_MODULE_1__.ListCollection)($a9e7382a7d111cb5$var$filterNodes(collection, collection, inputValue, filter));\n}\nfunction $a9e7382a7d111cb5$var$filterNodes(collection, nodes, inputValue, filter) {\n    let filteredNode = [];\n    for (let node of nodes){\n        if (node.type === \"section\" && node.hasChildNodes) {\n            let filtered = $a9e7382a7d111cb5$var$filterNodes(collection, (0, _react_stately_collections__WEBPACK_IMPORTED_MODULE_5__.getChildNodes)(node, collection), inputValue, filter);\n            if ([\n                ...filtered\n            ].some((node)=>node.type === \"item\")) filteredNode.push({\n                ...node,\n                childNodes: filtered\n            });\n        } else if (node.type === \"item\" && filter(node.textValue, inputValue)) filteredNode.push({\n            ...node\n        });\n        else if (node.type !== \"item\") filteredNode.push({\n            ...node\n        });\n    }\n    return filteredNode;\n}\n //# sourceMappingURL=module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXN0YXRlbHkvY29tYm9ib3gvZGlzdC9pbXBvcnQubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBNEY7QUFDWDtBQUN3RDtBQUMrQjtBQUNuRjtBQUNXO0FBRWhHOzs7Ozs7Ozs7O0NBVUMsR0FBRzs7Ozs7Ozs7OztDQVVILEdBTUQsU0FBU3NCLDBDQUEwQ0MsS0FBSztJQUNwRCxJQUFJQyxxQkFBcUJDO0lBQ3pCLElBQUksRUFBRUMsZUFBZUEsYUFBYSxFQUFFQyxhQUFhQSxjQUFjLE9BQU8sRUFBRUMsdUJBQXVCQSx3QkFBd0IsS0FBSyxFQUFFQyxtQkFBbUJBLGlCQUFpQixFQUFFQyxtQkFBbUJBLG9CQUFvQixJQUFJLEVBQUUsR0FBR1A7SUFDcE4sSUFBSSxDQUFDUSxjQUFjQyxnQkFBZ0IsR0FBRyxDQUFDLEdBQUd2QiwyQ0FBYyxFQUFHO0lBQzNELElBQUksQ0FBQ3dCLFdBQVdDLGdCQUFnQixHQUFHLENBQUMsR0FBR3pCLDJDQUFjLEVBQUc7SUFDeEQsSUFBSSxDQUFDMEIsZUFBZUMsaUJBQWlCLEdBQUcsQ0FBQyxHQUFHM0IsMkNBQWMsRUFBRztJQUM3RCxJQUFJNEIsb0JBQW9CLENBQUNDO1FBQ3JCLElBQUlmLE1BQU1jLGlCQUFpQixFQUFFZCxNQUFNYyxpQkFBaUIsQ0FBQ0M7UUFDckQsOERBQThEO1FBQzlELHFEQUFxRDtRQUNyRCxJQUFJQSxRQUFRQyxhQUFhO1lBQ3JCQztZQUNBQztRQUNKO0lBQ0o7SUFDQSxJQUFJQztJQUNKLElBQUksRUFBRUMsWUFBWUEsVUFBVSxFQUFFQyxrQkFBa0JBLGdCQUFnQixFQUFFTCxhQUFhQSxXQUFXLEVBQUVNLGdCQUFnQkEsY0FBYyxFQUFFQyxjQUFjQSxZQUFZLEVBQUVDLGNBQWNBLFlBQVksRUFBRSxHQUFHLENBQUMsR0FBRzFDLHlFQUE4QixFQUFHO1FBQ3hOLEdBQUdrQixLQUFLO1FBQ1JjLG1CQUFtQkE7UUFDbkJXLE9BQU8sQ0FBQ04sZUFBZW5C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QUMsQ0FBQ0osT0FBT0EsS0FBS0MsSUFBSSxLQUFLLFNBQVNGLGFBQWFNLElBQUksQ0FBQztnQkFDcEQsR0FBR0wsSUFBSTtnQkFDUE0sWUFBWUg7WUFDaEI7UUFDSixPQUFPLElBQUlILEtBQUtDLElBQUksS0FBSyxVQUFVTCxPQUFPSSxLQUFLakQsU0FBUyxFQUFFSixhQUFhb0QsYUFBYU0sSUFBSSxDQUFDO1lBQ3JGLEdBQUdMLElBQUk7UUFDWDthQUNLLElBQUlBLEtBQUtDLElBQUksS0FBSyxRQUFRRixhQUFhTSxJQUFJLENBQUM7WUFDN0MsR0FBR0wsSUFBSTtRQUNYO0lBQ0o7SUFDQSxPQUFPRDtBQUNYO0FBS3VFLENBQ3ZFLGtDQUFrQyIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtZmxhc2svLi9ub2RlX21vZHVsZXMvQHJlYWN0LXN0YXRlbHkvY29tYm9ib3gvZGlzdC9pbXBvcnQubWpzP2NiODAiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHt1c2VGb3JtVmFsaWRhdGlvblN0YXRlIGFzICRrNlBwdSR1c2VGb3JtVmFsaWRhdGlvblN0YXRlfSBmcm9tIFwiQHJlYWN0LXN0YXRlbHkvZm9ybVwiO1xuaW1wb3J0IHtnZXRDaGlsZE5vZGVzIGFzICRrNlBwdSRnZXRDaGlsZE5vZGVzfSBmcm9tIFwiQHJlYWN0LXN0YXRlbHkvY29sbGVjdGlvbnNcIjtcbmltcG9ydCB7dXNlU2luZ2xlU2VsZWN0TGlzdFN0YXRlIGFzICRrNlBwdSR1c2VTaW5nbGVTZWxlY3RMaXN0U3RhdGUsIExpc3RDb2xsZWN0aW9uIGFzICRrNlBwdSRMaXN0Q29sbGVjdGlvbn0gZnJvbSBcIkByZWFjdC1zdGF0ZWx5L2xpc3RcIjtcbmltcG9ydCB7dXNlU3RhdGUgYXMgJGs2UHB1JHVzZVN0YXRlLCB1c2VNZW1vIGFzICRrNlBwdSR1c2VNZW1vLCB1c2VSZWYgYXMgJGs2UHB1JHVzZVJlZiwgdXNlQ2FsbGJhY2sgYXMgJGs2UHB1JHVzZUNhbGxiYWNrLCB1c2VFZmZlY3QgYXMgJGs2UHB1JHVzZUVmZmVjdH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQge3VzZUNvbnRyb2xsZWRTdGF0ZSBhcyAkazZQcHUkdXNlQ29udHJvbGxlZFN0YXRlfSBmcm9tIFwiQHJlYWN0LXN0YXRlbHkvdXRpbHNcIjtcbmltcG9ydCB7dXNlT3ZlcmxheVRyaWdnZXJTdGF0ZSBhcyAkazZQcHUkdXNlT3ZlcmxheVRyaWdnZXJTdGF0ZX0gZnJvbSBcIkByZWFjdC1zdGF0ZWx5L292ZXJsYXlzXCI7XG5cbi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqIFxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIFxuXG5cblxuXG5cbmZ1bmN0aW9uICRhOWU3MzgyYTdkMTExY2I1JGV4cG9ydCRiNDUzYTNiZmQ0YTVmYTllKHByb3BzKSB7XG4gICAgdmFyIF9jb2xsZWN0aW9uX2dldEl0ZW0sIF9jb2xsZWN0aW9uX2dldEl0ZW0xO1xuICAgIGxldCB7IGRlZmF1bHRGaWx0ZXI6IGRlZmF1bHRGaWx0ZXIsIG1lbnVUcmlnZ2VyOiBtZW51VHJpZ2dlciA9IFwiaW5wdXRcIiwgYWxsb3dzRW1wdHlDb2xsZWN0aW9uOiBhbGxvd3NFbXB0eUNvbGxlY3Rpb24gPSBmYWxzZSwgYWxsb3dzQ3VzdG9tVmFsdWU6IGFsbG93c0N1c3RvbVZhbHVlLCBzaG91bGRDbG9zZU9uQmx1cjogc2hvdWxkQ2xvc2VPbkJsdXIgPSB0cnVlIH0gPSBwcm9wcztcbiAgICBsZXQgW3Nob3dBbGxJdGVtcywgc2V0U2hvd0FsbEl0ZW1zXSA9ICgwLCAkazZQcHUkdXNlU3RhdGUpKGZhbHNlKTtcbiAgICBsZXQgW2lzRm9jdXNlZCwgc2V0Rm9jdXNlZFN0YXRlXSA9ICgwLCAkazZQcHUkdXNlU3RhdGUpKGZhbHNlKTtcbiAgICBsZXQgW2ZvY3VzU3RyYXRlZ3ksIHNldEZvY3VzU3RyYXRlZ3ldID0gKDAsICRrNlBwdSR1c2VTdGF0ZSkobnVsbCk7XG4gICAgbGV0IG9uU2VsZWN0aW9uQ2hhbmdlID0gKGtleSk9PntcbiAgICAgICAgaWYgKHByb3BzLm9uU2VsZWN0aW9uQ2hhbmdlKSBwcm9wcy5vblNlbGVjdGlvbkNoYW5nZShrZXkpO1xuICAgICAgICAvLyBJZiBrZXkgaXMgdGhlIHNhbWUsIHJlc2V0IHRoZSBpbnB1dFZhbHVlIGFuZCBjbG9zZSB0aGUgbWVudVxuICAgICAgICAvLyAoc2NlbmFyaW86IHVzZXIgY2xpY2tzIG9uIGFscmVhZHkgc2VsZWN0ZWQgb3B0aW9uKVxuICAgICAgICBpZiAoa2V5ID09PSBzZWxlY3RlZEtleSkge1xuICAgICAgICAgICAgcmVzZXRJbnB1dFZhbHVlKCk7XG4gICAgICAgICAgICBjbG9zZU1lbnUoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgdmFyIF9wcm9wc19pdGVtcztcbiAgICBsZXQgeyBjb2xsZWN0aW9uOiBjb2xsZWN0aW9uLCBzZWxlY3Rpb25NYW5hZ2VyOiBzZWxlY3Rpb25NYW5hZ2VyLCBzZWxlY3RlZEtleTogc2VsZWN0ZWRLZXksIHNldFNlbGVjdGVkS2V5OiBzZXRTZWxlY3RlZEtleSwgc2VsZWN0ZWRJdGVtOiBzZWxlY3RlZEl0ZW0sIGRpc2FibGVkS2V5czogZGlzYWJsZWRLZXlzIH0gPSAoMCwgJGs2UHB1JHVzZVNpbmdsZVNlbGVjdExpc3RTdGF0ZSkoe1xuICAgICAgICAuLi5wcm9wcyxcbiAgICAgICAgb25TZWxlY3Rpb25DaGFuZ2U6IG9uU2VsZWN0aW9uQ2hhbmdlLFxuICAgICAgICBpdGVtczogKF9wcm9wc19pdGVtcyA9IHByb3BzLml0ZW1zKSAhPT0gbnVsbCAmJiBfcHJvcHNfaXRlbXMgIT09IHZvaWQgMCA/IF9wcm9wc19pdGVtcyA6IHByb3BzLmRlZmF1bHRJdGVtc1xuICAgIH0pO1xuICAgIHZhciBfcHJvcHNfZGVmYXVsdElucHV0VmFsdWUsIF9yZWY7XG4gICAgbGV0IFtpbnB1dFZhbHVlLCBzZXRJbnB1dFZhbHVlXSA9ICgwLCAkazZQcHUkdXNlQ29udHJvbGxlZFN0YXRlKShwcm9wcy5pbnB1dFZhbHVlLCAoX3JlZiA9IChfcHJvcHNfZGVmYXVsdElucHV0VmFsdWUgPSBwcm9wcy5kZWZhdWx0SW5wdXRWYWx1ZSkgIT09IG51bGwgJiYgX3Byb3BzX2RlZmF1bHRJbnB1dFZhbHVlICE9PSB2b2lkIDAgPyBfcHJvcHNfZGVmYXVsdElucHV0VmFsdWUgOiAoX2NvbGxlY3Rpb25fZ2V0SXRlbSA9IGNvbGxlY3Rpb24uZ2V0SXRlbShzZWxlY3RlZEtleSkpID09PSBudWxsIHx8IF9jb2xsZWN0aW9uX2dldEl0ZW0gPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jb2xsZWN0aW9uX2dldEl0ZW0udGV4dFZhbHVlKSAhPT0gbnVsbCAmJiBfcmVmICE9PSB2b2lkIDAgPyBfcmVmIDogXCJcIiwgcHJvcHMub25JbnB1dENoYW5nZSk7XG4gICAgLy8gUHJlc2VydmUgb3JpZ2luYWwgY29sbGVjdGlvbiBzbyB3ZSBjYW4gc2hvdyBhbGwgaXRlbXMgb24gZGVtYW5kXG4gICAgbGV0IG9yaWdpbmFsQ29sbGVjdGlvbiA9IGNvbGxlY3Rpb247XG4gICAgbGV0IGZpbHRlcmVkQ29sbGVjdGlvbiA9ICgwLCAkazZQcHUkdXNlTWVtbykoKCk9Pi8vIE5vIGRlZmF1bHQgZmlsdGVyIGlmIGl0ZW1zIGFyZSBjb250cm9sbGVkLlxuICAgICAgICBwcm9wcy5pdGVtcyAhPSBudWxsIHx8ICFkZWZhdWx0RmlsdGVyID8gY29sbGVjdGlvbiA6ICRhOWU3MzgyYTdkMTExY2I1JHZhciRmaWx0ZXJDb2xsZWN0aW9uKGNvbGxlY3Rpb24sIGlucHV0VmFsdWUsIGRlZmF1bHRGaWx0ZXIpLCBbXG4gICAgICAgIGNvbGxlY3Rpb24sXG4gICAgICAgIGlucHV0VmFsdWUsXG4gICAgICAgIGRlZmF1bHRGaWx0ZXIsXG4gICAgICAgIHByb3BzLml0ZW1zXG4gICAgXSk7XG4gICAgbGV0IFtsYXN0Q29sbGVjdGlvbiwgc2V0TGFzdENvbGxlY3Rpb25dID0gKDAsICRrNlBwdSR1c2VTdGF0ZSkoZmlsdGVyZWRDb2xsZWN0aW9uKTtcbiAgICAvLyBUcmFjayB3aGF0IGFjdGlvbiBpcyBhdHRlbXB0aW5nIHRvIG9wZW4gdGhlIG1lbnVcbiAgICBsZXQgbWVudU9wZW5UcmlnZ2VyID0gKDAsICRrNlBwdSR1c2VSZWYpKFwiZm9jdXNcIik7XG4gICAgbGV0IG9uT3BlbkNoYW5nZSA9IChvcGVuKT0+e1xuICAgICAgICBpZiAocHJvcHMub25PcGVuQ2hhbmdlKSBwcm9wcy5vbk9wZW5DaGFuZ2Uob3Blbiwgb3BlbiA/IG1lbnVPcGVuVHJpZ2dlci5jdXJyZW50IDogdW5kZWZpbmVkKTtcbiAgICAgICAgc2VsZWN0aW9uTWFuYWdlci5zZXRGb2N1c2VkKG9wZW4pO1xuICAgICAgICBpZiAoIW9wZW4pIHNlbGVjdGlvbk1hbmFnZXIuc2V0Rm9jdXNlZEtleShudWxsKTtcbiAgICB9O1xuICAgIGxldCB0cmlnZ2VyU3RhdGUgPSAoMCwgJGs2UHB1JHVzZU92ZXJsYXlUcmlnZ2VyU3RhdGUpKHtcbiAgICAgICAgLi4ucHJvcHMsXG4gICAgICAgIG9uT3BlbkNoYW5nZTogb25PcGVuQ2hhbmdlLFxuICAgICAgICBpc09wZW46IHVuZGVmaW5lZCxcbiAgICAgICAgZGVmYXVsdE9wZW46IHVuZGVmaW5lZFxuICAgIH0pO1xuICAgIGxldCBvcGVuID0gKGZvY3VzU3RyYXRlZ3kgPSBudWxsLCB0cmlnZ2VyKT0+e1xuICAgICAgICBsZXQgZGlzcGxheUFsbEl0ZW1zID0gdHJpZ2dlciA9PT0gXCJtYW51YWxcIiB8fCB0cmlnZ2VyID09PSBcImZvY3VzXCIgJiYgbWVudVRyaWdnZXIgPT09IFwiZm9jdXNcIjtcbiAgICAgICAgLy8gUHJldmVudCBvcGVuIG9wZXJhdGlvbnMgZnJvbSB0cmlnZ2VyaW5nIGlmIHRoZXJlIGlzIG5vdGhpbmcgdG8gZGlzcGxheVxuICAgICAgICAvLyBBbHNvIHByZXZlbnQgb3BlbiBvcGVyYXRpb25zIGZyb20gdHJpZ2dlcmluZyBpZiBpdGVtcyBhcmUgdW5jb250cm9sbGVkIGJ1dCBkZWZhdWx0SXRlbXMgaXMgZW1wdHksIGV2ZW4gaWYgZGlzcGxheUFsbEl0ZW1zIGlzIHRydWUuXG4gICAgICAgIC8vIFRoaXMgaXMgdG8gcHJldmVudCBjb21ib2JveGVzIHdpdGggZW1wdHkgZGVmYXVsdEl0ZW1zIGZyb20gb3BlbmluZyBidXQgYWxsb3cgY29udHJvbGxlZCBpdGVtcyBjb21ib2JveGVzIHRvIG9wZW4gZXZlbiBpZiB0aGUgaW5pdGFsIGxpc3QgaXMgZW1wdHkgKGFzc3VtcHRpb24gaXMgdXNlciB3aWxsIHByb3ZpZGUgc3dhcCB0aGUgZW1wdHkgbGlzdCB3aXRoIGEgYmFzZSBsaXN0IHZpYSBvbk9wZW5DaGFuZ2UgcmV0dXJuaW5nIGBtZW51VHJpZ2dlcmAgbWFudWFsKVxuICAgICAgICBpZiAoYWxsb3dzRW1wdHlDb2xsZWN0aW9uIHx8IGZpbHRlcmVkQ29sbGVjdGlvbi5zaXplID4gMCB8fCBkaXNwbGF5QWxsSXRlbXMgJiYgb3JpZ2luYWxDb2xsZWN0aW9uLnNpemUgPiAwIHx8IHByb3BzLml0ZW1zKSB7XG4gICAgICAgICAgICBpZiAoZGlzcGxheUFsbEl0ZW1zICYmICF0cmlnZ2VyU3RhdGUuaXNPcGVuICYmIHByb3BzLml0ZW1zID09PSB1bmRlZmluZWQpIC8vIFNob3cgYWxsIGl0ZW1zIGlmIG1lbnUgaXMgbWFudWFsbHkgb3BlbmVkLiBPbmx5IGNhcmUgYWJvdXQgdGhpcyBpZiBpdGVtcyBhcmUgdW5kZWZpbmVkXG4gICAgICAgICAgICBzZXRTaG93QWxsSXRlbXModHJ1ZSk7XG4gICAgICAgICAgICBtZW51T3BlblRyaWdnZXIuY3VycmVudCA9IHRyaWdnZXI7XG4gICAgICAgICAgICBzZXRGb2N1c1N0cmF0ZWd5KGZvY3VzU3RyYXRlZ3kpO1xuICAgICAgICAgICAgdHJpZ2dlclN0YXRlLm9wZW4oKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgbGV0IHRvZ2dsZSA9IChmb2N1c1N0cmF0ZWd5ID0gbnVsbCwgdHJpZ2dlcik9PntcbiAgICAgICAgbGV0IGRpc3BsYXlBbGxJdGVtcyA9IHRyaWdnZXIgPT09IFwibWFudWFsXCIgfHwgdHJpZ2dlciA9PT0gXCJmb2N1c1wiICYmIG1lbnVUcmlnZ2VyID09PSBcImZvY3VzXCI7XG4gICAgICAgIC8vIElmIHRoZSBtZW51IGlzIGNsb3NlZCBhbmQgdGhlcmUgaXMgbm90aGluZyB0byBkaXNwbGF5LCBlYXJseSByZXR1cm4gc28gdG9nZ2xlIGlzbid0IGNhbGxlZCB0byBwcmV2ZW50IGV4dHJhbmVvdXMgb25PcGVuQ2hhbmdlXG4gICAgICAgIGlmICghKGFsbG93c0VtcHR5Q29sbGVjdGlvbiB8fCBmaWx0ZXJlZENvbGxlY3Rpb24uc2l6ZSA+IDAgfHwgZGlzcGxheUFsbEl0ZW1zICYmIG9yaWdpbmFsQ29sbGVjdGlvbi5zaXplID4gMCB8fCBwcm9wcy5pdGVtcykgJiYgIXRyaWdnZXJTdGF0ZS5pc09wZW4pIHJldHVybjtcbiAgICAgICAgaWYgKGRpc3BsYXlBbGxJdGVtcyAmJiAhdHJpZ2dlclN0YXRlLmlzT3BlbiAmJiBwcm9wcy5pdGVtcyA9PT0gdW5kZWZpbmVkKSAvLyBTaG93IGFsbCBpdGVtcyBpZiBtZW51IGlzIHRvZ2dsZWQgb3Blbi4gT25seSBjYXJlIGFib3V0IHRoaXMgaWYgaXRlbXMgYXJlIHVuZGVmaW5lZFxuICAgICAgICBzZXRTaG93QWxsSXRlbXModHJ1ZSk7XG4gICAgICAgIC8vIE9ubHkgdXBkYXRlIHRoZSBtZW51T3BlblRyaWdnZXIgaWYgbWVudSBpcyBjdXJyZW50bHkgY2xvc2VkXG4gICAgICAgIGlmICghdHJpZ2dlclN0YXRlLmlzT3BlbikgbWVudU9wZW5UcmlnZ2VyLmN1cnJlbnQgPSB0cmlnZ2VyO1xuICAgICAgICB0b2dnbGVNZW51KGZvY3VzU3RyYXRlZ3kpO1xuICAgIH07XG4gICAgbGV0IHVwZGF0ZUxhc3RDb2xsZWN0aW9uID0gKDAsICRrNlBwdSR1c2VDYWxsYmFjaykoKCk9PntcbiAgICAgICAgc2V0TGFzdENvbGxlY3Rpb24oc2hvd0FsbEl0ZW1zID8gb3JpZ2luYWxDb2xsZWN0aW9uIDogZmlsdGVyZWRDb2xsZWN0aW9uKTtcbiAgICB9LCBbXG4gICAgICAgIHNob3dBbGxJdGVtcyxcbiAgICAgICAgb3JpZ2luYWxDb2xsZWN0aW9uLFxuICAgICAgICBmaWx0ZXJlZENvbGxlY3Rpb25cbiAgICBdKTtcbiAgICAvLyBJZiBtZW51IGlzIGdvaW5nIHRvIGNsb3NlLCBzYXZlIHRoZSBjdXJyZW50IGNvbGxlY3Rpb24gc28gd2UgY2FuIGZyZWV6ZSB0aGUgZGlzcGxheWVkIGNvbGxlY3Rpb24gd2hlbiB0aGVcbiAgICAvLyB1c2VyIGNsaWNrcyBvdXRzaWRlIHRoZSBwb3BvdmVyIHRvIGNsb3NlIHRoZSBtZW51LiBQcmV2ZW50cyB0aGUgbWVudSBjb250ZW50cyBmcm9tIHVwZGF0aW5nIGFzIHRoZSBtZW51IGNsb3Nlcy5cbiAgICBsZXQgdG9nZ2xlTWVudSA9ICgwLCAkazZQcHUkdXNlQ2FsbGJhY2spKChmb2N1c1N0cmF0ZWd5ID0gbnVsbCk9PntcbiAgICAgICAgaWYgKHRyaWdnZXJTdGF0ZS5pc09wZW4pIHVwZGF0ZUxhc3RDb2xsZWN0aW9uKCk7XG4gICAgICAgIHNldEZvY3VzU3RyYXRlZ3koZm9jdXNTdHJhdGVneSk7XG4gICAgICAgIHRyaWdnZXJTdGF0ZS50b2dnbGUoKTtcbiAgICB9LCBbXG4gICAgICAgIHRyaWdnZXJTdGF0ZSxcbiAgICAgICAgdXBkYXRlTGFzdENvbGxlY3Rpb25cbiAgICBdKTtcbiAgICBsZXQgY2xvc2VNZW51ID0gKDAsICRrNlBwdSR1c2VDYWxsYmFjaykoKCk9PntcbiAgICAgICAgaWYgKHRyaWdnZXJTdGF0ZS5pc09wZW4pIHtcbiAgICAgICAgICAgIHVwZGF0ZUxhc3RDb2xsZWN0aW9uKCk7XG4gICAgICAgICAgICB0cmlnZ2VyU3RhdGUuY2xvc2UoKTtcbiAgICAgICAgfVxuICAgIH0sIFtcbiAgICAgICAgdHJpZ2dlclN0YXRlLFxuICAgICAgICB1cGRhdGVMYXN0Q29sbGVjdGlvblxuICAgIF0pO1xuICAgIGxldCBbbGFzdFZhbHVlLCBzZXRMYXN0VmFsdWVdID0gKDAsICRrNlBwdSR1c2VTdGF0ZSkoaW5wdXRWYWx1ZSk7XG4gICAgbGV0IHJlc2V0SW5wdXRWYWx1ZSA9ICgpPT57XG4gICAgICAgIHZhciBfY29sbGVjdGlvbl9nZXRJdGVtO1xuICAgICAgICB2YXIgX2NvbGxlY3Rpb25fZ2V0SXRlbV90ZXh0VmFsdWU7XG4gICAgICAgIGxldCBpdGVtVGV4dCA9IChfY29sbGVjdGlvbl9nZXRJdGVtX3RleHRWYWx1ZSA9IChfY29sbGVjdGlvbl9nZXRJdGVtID0gY29sbGVjdGlvbi5nZXRJdGVtKHNlbGVjdGVkS2V5KSkgPT09IG51bGwgfHwgX2NvbGxlY3Rpb25fZ2V0SXRlbSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2NvbGxlY3Rpb25fZ2V0SXRlbS50ZXh0VmFsdWUpICE9PSBudWxsICYmIF9jb2xsZWN0aW9uX2dldEl0ZW1fdGV4dFZhbHVlICE9PSB2b2lkIDAgPyBfY29sbGVjdGlvbl9nZXRJdGVtX3RleHRWYWx1ZSA6IFwiXCI7XG4gICAgICAgIHNldExhc3RWYWx1ZShpdGVtVGV4dCk7XG4gICAgICAgIHNldElucHV0VmFsdWUoaXRlbVRleHQpO1xuICAgIH07XG4gICAgdmFyIF9wcm9wc19zZWxlY3RlZEtleSwgX3JlZjE7XG4gICAgbGV0IGxhc3RTZWxlY3RlZEtleSA9ICgwLCAkazZQcHUkdXNlUmVmKSgoX3JlZjEgPSAoX3Byb3BzX3NlbGVjdGVkS2V5ID0gcHJvcHMuc2VsZWN0ZWRLZXkpICE9PSBudWxsICYmIF9wcm9wc19zZWxlY3RlZEtleSAhPT0gdm9pZCAwID8gX3Byb3BzX3NlbGVjdGVkS2V5IDogcHJvcHMuZGVmYXVsdFNlbGVjdGVkS2V5KSAhPT0gbnVsbCAmJiBfcmVmMSAhPT0gdm9pZCAwID8gX3JlZjEgOiBudWxsKTtcbiAgICB2YXIgX2NvbGxlY3Rpb25fZ2V0SXRlbV90ZXh0VmFsdWU7XG4gICAgbGV0IGxhc3RTZWxlY3RlZEtleVRleHQgPSAoMCwgJGs2UHB1JHVzZVJlZikoKF9jb2xsZWN0aW9uX2dldEl0ZW1fdGV4dFZhbHVlID0gKF9jb2xsZWN0aW9uX2dldEl0ZW0xID0gY29sbGVjdGlvbi5nZXRJdGVtKHNlbGVjdGVkS2V5KSkgPT09IG51bGwgfHwgX2NvbGxlY3Rpb25fZ2V0SXRlbTEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jb2xsZWN0aW9uX2dldEl0ZW0xLnRleHRWYWx1ZSkgIT09IG51bGwgJiYgX2NvbGxlY3Rpb25fZ2V0SXRlbV90ZXh0VmFsdWUgIT09IHZvaWQgMCA/IF9jb2xsZWN0aW9uX2dldEl0ZW1fdGV4dFZhbHVlIDogXCJcIik7XG4gICAgLy8gaW50ZW50aW9uYWwgb21pdCBkZXBlbmRlbmN5IGFycmF5LCB3YW50IHRoaXMgdG8gaGFwcGVuIG9uIGV2ZXJ5IHJlbmRlclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgICAoMCwgJGs2UHB1JHVzZUVmZmVjdCkoKCk9PntcbiAgICAgICAgdmFyIF9jb2xsZWN0aW9uX2dldEl0ZW07XG4gICAgICAgIC8vIE9wZW4gYW5kIGNsb3NlIG1lbnUgYXV0b21hdGljYWxseSB3aGVuIHRoZSBpbnB1dCB2YWx1ZSBjaGFuZ2VzIGlmIHRoZSBpbnB1dCBpcyBmb2N1c2VkLFxuICAgICAgICAvLyBhbmQgdGhlcmUgYXJlIGl0ZW1zIGluIHRoZSBjb2xsZWN0aW9uIG9yIGFsbG93RW1wdHlDb2xsZWN0aW9uIGlzIHRydWUuXG4gICAgICAgIGlmIChpc0ZvY3VzZWQgJiYgKGZpbHRlcmVkQ29sbGVjdGlvbi5zaXplID4gMCB8fCBhbGxvd3NFbXB0eUNvbGxlY3Rpb24pICYmICF0cmlnZ2VyU3RhdGUuaXNPcGVuICYmIGlucHV0VmFsdWUgIT09IGxhc3RWYWx1ZSAmJiBtZW51VHJpZ2dlciAhPT0gXCJtYW51YWxcIikgb3BlbihudWxsLCBcImlucHV0XCIpO1xuICAgICAgICAvLyBDbG9zZSB0aGUgbWVudSBpZiB0aGUgY29sbGVjdGlvbiBpcyBlbXB0eS4gRG9uJ3QgY2xvc2UgbWVudSBpZiBmaWx0ZXJlZCBjb2xsZWN0aW9uIHNpemUgaXMgMFxuICAgICAgICAvLyBidXQgd2UgYXJlIGN1cnJlbnRseSBzaG93aW5nIGFsbCBpdGVtcyB2aWEgYnV0dG9uIHByZXNzXG4gICAgICAgIGlmICghc2hvd0FsbEl0ZW1zICYmICFhbGxvd3NFbXB0eUNvbGxlY3Rpb24gJiYgdHJpZ2dlclN0YXRlLmlzT3BlbiAmJiBmaWx0ZXJlZENvbGxlY3Rpb24uc2l6ZSA9PT0gMCkgY2xvc2VNZW51KCk7XG4gICAgICAgIC8vIENsb3NlIHdoZW4gYW4gaXRlbSBpcyBzZWxlY3RlZC5cbiAgICAgICAgaWYgKHNlbGVjdGVkS2V5ICE9IG51bGwgJiYgc2VsZWN0ZWRLZXkgIT09IGxhc3RTZWxlY3RlZEtleS5jdXJyZW50KSBjbG9zZU1lbnUoKTtcbiAgICAgICAgLy8gQ2xlYXIgZm9jdXNlZCBrZXkgd2hlbiBpbnB1dCB2YWx1ZSBjaGFuZ2VzIGFuZCBkaXNwbGF5IGZpbHRlcmVkIGNvbGxlY3Rpb24gYWdhaW4uXG4gICAgICAgIGlmIChpbnB1dFZhbHVlICE9PSBsYXN0VmFsdWUpIHtcbiAgICAgICAgICAgIHNlbGVjdGlvbk1hbmFnZXIuc2V0Rm9jdXNlZEtleShudWxsKTtcbiAgICAgICAgICAgIHNldFNob3dBbGxJdGVtcyhmYWxzZSk7XG4gICAgICAgICAgICAvLyBTZXQgc2VsZWN0ZWRLZXkgdG8gbnVsbCB3aGVuIHRoZSB1c2VyIGNsZWFycyB0aGUgaW5wdXQuXG4gICAgICAgICAgICAvLyBJZiBjb250cm9sbGVkLCB0aGlzIGlzIHRoZSBhcHBsaWNhdGlvbiBkZXZlbG9wZXIncyByZXNwb25zaWJpbGl0eS5cbiAgICAgICAgICAgIGlmIChpbnB1dFZhbHVlID09PSBcIlwiICYmIChwcm9wcy5pbnB1dFZhbHVlID09PSB1bmRlZmluZWQgfHwgcHJvcHMuc2VsZWN0ZWRLZXkgPT09IHVuZGVmaW5lZCkpIHNldFNlbGVjdGVkS2V5KG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHRoZSBzZWxlY3RlZEtleSBjaGFuZ2VkLCB1cGRhdGUgdGhlIGlucHV0IHZhbHVlLlxuICAgICAgICAvLyBEbyBub3RoaW5nIGlmIGJvdGggaW5wdXRWYWx1ZSBhbmQgc2VsZWN0ZWRLZXkgYXJlIGNvbnRyb2xsZWQuXG4gICAgICAgIC8vIEluIHRoaXMgY2FzZSwgaXQncyB0aGUgdXNlcidzIHJlc3BvbnNpYmlsaXR5IHRvIHVwZGF0ZSBpbnB1dFZhbHVlIGluIG9uU2VsZWN0aW9uQ2hhbmdlLlxuICAgICAgICBpZiAoc2VsZWN0ZWRLZXkgIT09IGxhc3RTZWxlY3RlZEtleS5jdXJyZW50ICYmIChwcm9wcy5pbnB1dFZhbHVlID09PSB1bmRlZmluZWQgfHwgcHJvcHMuc2VsZWN0ZWRLZXkgPT09IHVuZGVmaW5lZCkpIHJlc2V0SW5wdXRWYWx1ZSgpO1xuICAgICAgICBlbHNlIGlmIChsYXN0VmFsdWUgIT09IGlucHV0VmFsdWUpIHNldExhc3RWYWx1ZShpbnB1dFZhbHVlKTtcbiAgICAgICAgdmFyIF9jb2xsZWN0aW9uX2dldEl0ZW1fdGV4dFZhbHVlO1xuICAgICAgICAvLyBVcGRhdGUgdGhlIGlucHV0VmFsdWUgaWYgdGhlIHNlbGVjdGVkIGl0ZW0ncyB0ZXh0IGNoYW5nZXMgZnJvbSBpdHMgbGFzdCB0cmFja2VkIHZhbHVlLlxuICAgICAgICAvLyBUaGlzIGlzIHRvIGhhbmRsZSBjYXNlcyB3aGVyZSBhIHNlbGVjdGVkS2V5IGlzIHNwZWNpZmllZCBidXQgdGhlIGl0ZW1zIGFyZW4ndCBhdmFpbGFibGUgKGFzeW5jIGxvYWRpbmcpIG9yIHRoZSBzZWxlY3RlZCBpdGVtJ3MgdGV4dCB2YWx1ZSB1cGRhdGVzLlxuICAgICAgICAvLyBPbmx5IHJlc2V0IGlmIHRoZSB1c2VyIGlzbid0IGN1cnJlbnRseSB3aXRoaW4gdGhlIGZpZWxkIHNvIHdlIGRvbid0IGVycm9uZW91c2x5IG1vZGlmeSB1c2VyIGlucHV0LlxuICAgICAgICAvLyBJZiBpbnB1dFZhbHVlIGlzIGNvbnRyb2xsZWQsIGl0IGlzIHRoZSB1c2VyJ3MgcmVzcG9uc2liaWxpdHkgdG8gdXBkYXRlIHRoZSBpbnB1dFZhbHVlIHdoZW4gaXRlbXMgY2hhbmdlLlxuICAgICAgICBsZXQgc2VsZWN0ZWRJdGVtVGV4dCA9IChfY29sbGVjdGlvbl9nZXRJdGVtX3RleHRWYWx1ZSA9IChfY29sbGVjdGlvbl9nZXRJdGVtID0gY29sbGVjdGlvbi5nZXRJdGVtKHNlbGVjdGVkS2V5KSkgPT09IG51bGwgfHwgX2NvbGxlY3Rpb25fZ2V0SXRlbSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2NvbGxlY3Rpb25fZ2V0SXRlbS50ZXh0VmFsdWUpICE9PSBudWxsICYmIF9jb2xsZWN0aW9uX2dldEl0ZW1fdGV4dFZhbHVlICE9PSB2b2lkIDAgPyBfY29sbGVjdGlvbl9nZXRJdGVtX3RleHRWYWx1ZSA6IFwiXCI7XG4gICAgICAgIGlmICghaXNGb2N1c2VkICYmIHNlbGVjdGVkS2V5ICE9IG51bGwgJiYgcHJvcHMuaW5wdXRWYWx1ZSA9PT0gdW5kZWZpbmVkICYmIHNlbGVjdGVkS2V5ID09PSBsYXN0U2VsZWN0ZWRLZXkuY3VycmVudCkge1xuICAgICAgICAgICAgaWYgKGxhc3RTZWxlY3RlZEtleVRleHQuY3VycmVudCAhPT0gc2VsZWN0ZWRJdGVtVGV4dCkge1xuICAgICAgICAgICAgICAgIHNldExhc3RWYWx1ZShzZWxlY3RlZEl0ZW1UZXh0KTtcbiAgICAgICAgICAgICAgICBzZXRJbnB1dFZhbHVlKHNlbGVjdGVkSXRlbVRleHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxhc3RTZWxlY3RlZEtleS5jdXJyZW50ID0gc2VsZWN0ZWRLZXk7XG4gICAgICAgIGxhc3RTZWxlY3RlZEtleVRleHQuY3VycmVudCA9IHNlbGVjdGVkSXRlbVRleHQ7XG4gICAgfSk7XG4gICAgbGV0IHZhbGlkYXRpb24gPSAoMCwgJGs2UHB1JHVzZUZvcm1WYWxpZGF0aW9uU3RhdGUpKHtcbiAgICAgICAgLi4ucHJvcHMsXG4gICAgICAgIHZhbHVlOiAoMCwgJGs2UHB1JHVzZU1lbW8pKCgpPT4oe1xuICAgICAgICAgICAgICAgIGlucHV0VmFsdWU6IGlucHV0VmFsdWUsXG4gICAgICAgICAgICAgICAgc2VsZWN0ZWRLZXk6IHNlbGVjdGVkS2V5XG4gICAgICAgICAgICB9KSwgW1xuICAgICAgICAgICAgaW5wdXRWYWx1ZSxcbiAgICAgICAgICAgIHNlbGVjdGVkS2V5XG4gICAgICAgIF0pXG4gICAgfSk7XG4gICAgLy8gUmV2ZXJ0IGlucHV0IHZhbHVlIGFuZCBjbG9zZSBtZW51XG4gICAgbGV0IHJldmVydCA9ICgpPT57XG4gICAgICAgIGlmIChhbGxvd3NDdXN0b21WYWx1ZSAmJiBzZWxlY3RlZEtleSA9PSBudWxsKSBjb21taXRDdXN0b21WYWx1ZSgpO1xuICAgICAgICBlbHNlIGNvbW1pdFNlbGVjdGlvbigpO1xuICAgIH07XG4gICAgbGV0IGNvbW1pdEN1c3RvbVZhbHVlID0gKCk9PntcbiAgICAgICAgbGFzdFNlbGVjdGVkS2V5LmN1cnJlbnQgPSBudWxsO1xuICAgICAgICBzZXRTZWxlY3RlZEtleShudWxsKTtcbiAgICAgICAgY2xvc2VNZW51KCk7XG4gICAgfTtcbiAgICBsZXQgY29tbWl0U2VsZWN0aW9uID0gKCk9PntcbiAgICAgICAgLy8gSWYgbXVsdGlwbGUgdGhpbmdzIGFyZSBjb250cm9sbGVkLCBjYWxsIG9uU2VsZWN0aW9uQ2hhbmdlXG4gICAgICAgIGlmIChwcm9wcy5zZWxlY3RlZEtleSAhPT0gdW5kZWZpbmVkICYmIHByb3BzLmlucHV0VmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdmFyIF9jb2xsZWN0aW9uX2dldEl0ZW07XG4gICAgICAgICAgICBwcm9wcy5vblNlbGVjdGlvbkNoYW5nZShzZWxlY3RlZEtleSk7XG4gICAgICAgICAgICB2YXIgX2NvbGxlY3Rpb25fZ2V0SXRlbV90ZXh0VmFsdWU7XG4gICAgICAgICAgICAvLyBTdG9wIG1lbnUgZnJvbSByZW9wZW5pbmcgZnJvbSB1c2VFZmZlY3RcbiAgICAgICAgICAgIGxldCBpdGVtVGV4dCA9IChfY29sbGVjdGlvbl9nZXRJdGVtX3RleHRWYWx1ZSA9IChfY29sbGVjdGlvbl9nZXRJdGVtID0gY29sbGVjdGlvbi5nZXRJdGVtKHNlbGVjdGVkS2V5KSkgPT09IG51bGwgfHwgX2NvbGxlY3Rpb25fZ2V0SXRlbSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2NvbGxlY3Rpb25fZ2V0SXRlbS50ZXh0VmFsdWUpICE9PSBudWxsICYmIF9jb2xsZWN0aW9uX2dldEl0ZW1fdGV4dFZhbHVlICE9PSB2b2lkIDAgPyBfY29sbGVjdGlvbl9nZXRJdGVtX3RleHRWYWx1ZSA6IFwiXCI7XG4gICAgICAgICAgICBzZXRMYXN0VmFsdWUoaXRlbVRleHQpO1xuICAgICAgICAgICAgY2xvc2VNZW51KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBJZiBvbmx5IGEgc2luZ2xlIGFzcGVjdCBvZiBjb21ib2JveCBpcyBjb250cm9sbGVkLCByZXNldCBpbnB1dCB2YWx1ZSBhbmQgY2xvc2UgbWVudSBmb3IgdGhlIHVzZXJcbiAgICAgICAgICAgIHJlc2V0SW5wdXRWYWx1ZSgpO1xuICAgICAgICAgICAgY2xvc2VNZW51KCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGNvbW1pdFZhbHVlID0gKCk9PntcbiAgICAgICAgaWYgKGFsbG93c0N1c3RvbVZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgX2NvbGxlY3Rpb25fZ2V0SXRlbTtcbiAgICAgICAgICAgIHZhciBfY29sbGVjdGlvbl9nZXRJdGVtX3RleHRWYWx1ZTtcbiAgICAgICAgICAgIGNvbnN0IGl0ZW1UZXh0ID0gKF9jb2xsZWN0aW9uX2dldEl0ZW1fdGV4dFZhbHVlID0gKF9jb2xsZWN0aW9uX2dldEl0ZW0gPSBjb2xsZWN0aW9uLmdldEl0ZW0oc2VsZWN0ZWRLZXkpKSA9PT0gbnVsbCB8fCBfY29sbGVjdGlvbl9nZXRJdGVtID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfY29sbGVjdGlvbl9nZXRJdGVtLnRleHRWYWx1ZSkgIT09IG51bGwgJiYgX2NvbGxlY3Rpb25fZ2V0SXRlbV90ZXh0VmFsdWUgIT09IHZvaWQgMCA/IF9jb2xsZWN0aW9uX2dldEl0ZW1fdGV4dFZhbHVlIDogXCJcIjtcbiAgICAgICAgICAgIGlucHV0VmFsdWUgPT09IGl0ZW1UZXh0ID8gY29tbWl0U2VsZWN0aW9uKCkgOiBjb21taXRDdXN0b21WYWx1ZSgpO1xuICAgICAgICB9IGVsc2UgLy8gUmVzZXQgaW5wdXRWYWx1ZSBhbmQgY2xvc2UgbWVudVxuICAgICAgICBjb21taXRTZWxlY3Rpb24oKTtcbiAgICB9O1xuICAgIGxldCBjb21taXQgPSAoKT0+e1xuICAgICAgICBpZiAodHJpZ2dlclN0YXRlLmlzT3BlbiAmJiBzZWxlY3Rpb25NYW5hZ2VyLmZvY3VzZWRLZXkgIT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gUmVzZXQgaW5wdXRWYWx1ZSBhbmQgY2xvc2UgbWVudSBoZXJlIGlmIHRoZSBzZWxlY3RlZCBrZXkgaXMgYWxyZWFkeSB0aGUgZm9jdXNlZCBrZXkuIE90aGVyd2lzZVxuICAgICAgICAgICAgLy8gZmlyZSBvblNlbGVjdGlvbkNoYW5nZSB0byBhbGxvdyB0aGUgYXBwbGljYXRpb24gdG8gY29udHJvbCB0aGUgY2xvc2luZy5cbiAgICAgICAgICAgIGlmIChzZWxlY3RlZEtleSA9PT0gc2VsZWN0aW9uTWFuYWdlci5mb2N1c2VkS2V5KSBjb21taXRTZWxlY3Rpb24oKTtcbiAgICAgICAgICAgIGVsc2Ugc2V0U2VsZWN0ZWRLZXkoc2VsZWN0aW9uTWFuYWdlci5mb2N1c2VkS2V5KTtcbiAgICAgICAgfSBlbHNlIGNvbW1pdFZhbHVlKCk7XG4gICAgfTtcbiAgICBsZXQgdmFsdWVPbkZvY3VzID0gKDAsICRrNlBwdSR1c2VSZWYpKGlucHV0VmFsdWUpO1xuICAgIGxldCBzZXRGb2N1c2VkID0gKGlzRm9jdXNlZCk9PntcbiAgICAgICAgaWYgKGlzRm9jdXNlZCkge1xuICAgICAgICAgICAgdmFsdWVPbkZvY3VzLmN1cnJlbnQgPSBpbnB1dFZhbHVlO1xuICAgICAgICAgICAgaWYgKG1lbnVUcmlnZ2VyID09PSBcImZvY3VzXCIpIG9wZW4obnVsbCwgXCJmb2N1c1wiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChzaG91bGRDbG9zZU9uQmx1cikgY29tbWl0VmFsdWUoKTtcbiAgICAgICAgICAgIGlmIChpbnB1dFZhbHVlICE9PSB2YWx1ZU9uRm9jdXMuY3VycmVudCkgdmFsaWRhdGlvbi5jb21taXRWYWxpZGF0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0Rm9jdXNlZFN0YXRlKGlzRm9jdXNlZCk7XG4gICAgfTtcbiAgICBsZXQgZGlzcGxheWVkQ29sbGVjdGlvbiA9ICgwLCAkazZQcHUkdXNlTWVtbykoKCk9PntcbiAgICAgICAgaWYgKHRyaWdnZXJTdGF0ZS5pc09wZW4pIHtcbiAgICAgICAgICAgIGlmIChzaG93QWxsSXRlbXMpIHJldHVybiBvcmlnaW5hbENvbGxlY3Rpb247XG4gICAgICAgICAgICBlbHNlIHJldHVybiBmaWx0ZXJlZENvbGxlY3Rpb247XG4gICAgICAgIH0gZWxzZSByZXR1cm4gbGFzdENvbGxlY3Rpb247XG4gICAgfSwgW1xuICAgICAgICB0cmlnZ2VyU3RhdGUuaXNPcGVuLFxuICAgICAgICBvcmlnaW5hbENvbGxlY3Rpb24sXG4gICAgICAgIGZpbHRlcmVkQ29sbGVjdGlvbixcbiAgICAgICAgc2hvd0FsbEl0ZW1zLFxuICAgICAgICBsYXN0Q29sbGVjdGlvblxuICAgIF0pO1xuICAgIHJldHVybiB7XG4gICAgICAgIC4uLnZhbGlkYXRpb24sXG4gICAgICAgIC4uLnRyaWdnZXJTdGF0ZSxcbiAgICAgICAgZm9jdXNTdHJhdGVneTogZm9jdXNTdHJhdGVneSxcbiAgICAgICAgdG9nZ2xlOiB0b2dnbGUsXG4gICAgICAgIG9wZW46IG9wZW4sXG4gICAgICAgIGNsb3NlOiBjb21taXRWYWx1ZSxcbiAgICAgICAgc2VsZWN0aW9uTWFuYWdlcjogc2VsZWN0aW9uTWFuYWdlcixcbiAgICAgICAgc2VsZWN0ZWRLZXk6IHNlbGVjdGVkS2V5LFxuICAgICAgICBzZXRTZWxlY3RlZEtleTogc2V0U2VsZWN0ZWRLZXksXG4gICAgICAgIGRpc2FibGVkS2V5czogZGlzYWJsZWRLZXlzLFxuICAgICAgICBpc0ZvY3VzZWQ6IGlzRm9jdXNlZCxcbiAgICAgICAgc2V0Rm9jdXNlZDogc2V0Rm9jdXNlZCxcbiAgICAgICAgc2VsZWN0ZWRJdGVtOiBzZWxlY3RlZEl0ZW0sXG4gICAgICAgIGNvbGxlY3Rpb246IGRpc3BsYXllZENvbGxlY3Rpb24sXG4gICAgICAgIGlucHV0VmFsdWU6IGlucHV0VmFsdWUsXG4gICAgICAgIHNldElucHV0VmFsdWU6IHNldElucHV0VmFsdWUsXG4gICAgICAgIGNvbW1pdDogY29tbWl0LFxuICAgICAgICByZXZlcnQ6IHJldmVydFxuICAgIH07XG59XG5mdW5jdGlvbiAkYTllNzM4MmE3ZDExMWNiNSR2YXIkZmlsdGVyQ29sbGVjdGlvbihjb2xsZWN0aW9uLCBpbnB1dFZhbHVlLCBmaWx0ZXIpIHtcbiAgICByZXR1cm4gbmV3ICgwLCAkazZQcHUkTGlzdENvbGxlY3Rpb24pKCRhOWU3MzgyYTdkMTExY2I1JHZhciRmaWx0ZXJOb2Rlcyhjb2xsZWN0aW9uLCBjb2xsZWN0aW9uLCBpbnB1dFZhbHVlLCBmaWx0ZXIpKTtcbn1cbmZ1bmN0aW9uICRhOWU3MzgyYTdkMTExY2I1JHZhciRmaWx0ZXJOb2Rlcyhjb2xsZWN0aW9uLCBub2RlcywgaW5wdXRWYWx1ZSwgZmlsdGVyKSB7XG4gICAgbGV0IGZpbHRlcmVkTm9kZSA9IFtdO1xuICAgIGZvciAobGV0IG5vZGUgb2Ygbm9kZXMpe1xuICAgICAgICBpZiAobm9kZS50eXBlID09PSBcInNlY3Rpb25cIiAmJiBub2RlLmhhc0NoaWxkTm9kZXMpIHtcbiAgICAgICAgICAgIGxldCBmaWx0ZXJlZCA9ICRhOWU3MzgyYTdkMTExY2I1JHZhciRmaWx0ZXJOb2Rlcyhjb2xsZWN0aW9uLCAoMCwgJGs2UHB1JGdldENoaWxkTm9kZXMpKG5vZGUsIGNvbGxlY3Rpb24pLCBpbnB1dFZhbHVlLCBmaWx0ZXIpO1xuICAgICAgICAgICAgaWYgKFtcbiAgICAgICAgICAgICAgICAuLi5maWx0ZXJlZFxuICAgICAgICAgICAgXS5zb21lKChub2RlKT0+bm9kZS50eXBlID09PSBcIml0ZW1cIikpIGZpbHRlcmVkTm9kZS5wdXNoKHtcbiAgICAgICAgICAgICAgICAuLi5ub2RlLFxuICAgICAgICAgICAgICAgIGNoaWxkTm9kZXM6IGZpbHRlcmVkXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGlmIChub2RlLnR5cGUgPT09IFwiaXRlbVwiICYmIGZpbHRlcihub2RlLnRleHRWYWx1ZSwgaW5wdXRWYWx1ZSkpIGZpbHRlcmVkTm9kZS5wdXNoKHtcbiAgICAgICAgICAgIC4uLm5vZGVcbiAgICAgICAgfSk7XG4gICAgICAgIGVsc2UgaWYgKG5vZGUudHlwZSAhPT0gXCJpdGVtXCIpIGZpbHRlcmVkTm9kZS5wdXNoKHtcbiAgICAgICAgICAgIC4uLm5vZGVcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBmaWx0ZXJlZE5vZGU7XG59XG5cblxuXG5cbmV4cG9ydCB7JGE5ZTczODJhN2QxMTFjYjUkZXhwb3J0JGI0NTNhM2JmZDRhNWZhOWUgYXMgdXNlQ29tYm9Cb3hTdGF0ZX07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tb2R1bGUuanMubWFwXG4iXSwibmFtZXMiOlsidXNlRm9ybVZhbGlkYXRpb25TdGF0ZSIsIiRrNlBwdSR1c2VGb3JtVmFsaWRhdGlvblN0YXRlIiwiZ2V0Q2hpbGROb2RlcyIsIiRrNlBwdSRnZXRDaGlsZE5vZGVzIiwidXNlU2luZ2xlU2VsZWN0TGlzdFN0YXRlIiwiJGs2UHB1JHVzZVNpbmdsZVNlbGVjdExpc3RTdGF0ZSIsIkxpc3RDb2xsZWN0aW9uIiwiJGs2UHB1JExpc3RDb2xsZWN0aW9uIiwidXNlU3RhdGUiLCIkazZQcHUkdXNlU3RhdGUiLCJ1c2VNZW1vIiwiJGs2UHB1JHVzZU1lbW8iLCJ1c2VSZWYiLCIkazZQcHUkdXNlUmVmIiwidXNlQ2FsbGJhY2siLCIkazZQcHUkdXNlQ2FsbGJhY2siLCJ1c2VFZmZlY3QiLCIkazZQcHUkdXNlRWZmZWN0IiwidXNlQ29udHJvbGxlZFN0YXRlIiwiJGs2UHB1JHVzZUNvbnRyb2xsZWRTdGF0ZSIsInVzZU92ZXJsYXlUcmlnZ2VyU3RhdGUiLCIkazZQcHUkdXNlT3ZlcmxheVRyaWdnZXJTdGF0ZSIsIiRhOWU3MzgyYTdkMTExY2I1JGV4cG9ydCRiNDUzYTNiZmQ0YTVmYTllIiwicHJvcHMiLCJfY29sbGVjdGlvbl9nZXRJdGVtIiwiX2NvbGxlY3Rpb25fZ2V0SXRlbTEiLCJkZWZhdWx0RmlsdGVyIiwibWVudVRyaWdnZXIiLCJhbGxvd3NFbXB0eUNvbGxlY3Rpb24iLCJhbGxvd3NDdXN0b21WYWx1ZSIsInNob3VsZENsb3NlT25CbHVyIiwic2hvd0FsbEl0ZW1zIiwic2V0U2hvd0FsbEl0ZW1zIiwiaXNGb2N1c2VkIiwic2V0Rm9jdXNlZFN0YXRlIiwiZm9jdXNTdHJhdGVneSIsInNldEZvY3VzU3RyYXRlZ3kiLCJvblNlbGVjdGlvbkNoYW5nZSIsImtleSIsInNlbGVjdGVkS2V5IiwicmVzZXRJbnB1dFZhbHVlIiwiY2xvc2VNZW51IiwiX3Byb3BzX2l0ZW1zIiwiY29sbGVjdGlvbiIsInNlbGVjdGlvbk1hbmFnZXIiLCJzZXRTZWxlY3RlZEtleSIsInNlbGVjdGVkSXRlbSIsImRpc2FibGVkS2V5cyIsIml0ZW1zIiwiZGVmYXVsdEl0ZW1zIiwiX3Byb3BzX2RlZmF1bHRJbnB1dFZhbHVlIiwiX3JlZiIsImlucHV0VmFsdWUiLCJzZXRJbnB1dFZhbHVlIiwiZGVmYXVsdElucHV0VmFsdWUiLCJnZXRJdGVtIiwidGV4dFZhbHVlIiwib25JbnB1dENoYW5nZSIsIm9yaWdpbmFsQ29sbGVjdGlvbiIsImZpbHRlcmVkQ29sbGVjdGlvbiIsIiRhOWU3MzgyYTdkMTExY2I1JHZhciRmaWx0ZXJDb2xsZWN0aW9uIiwibGFzdENvbGxlY3Rpb24iLCJzZXRMYXN0Q29sbGVjdGlvbiIsIm1lbnVPcGVuVHJpZ2dlciIsIm9uT3BlbkNoYW5nZSIsIm9wZW4iLCJjdXJyZW50IiwidW5kZWZpbmVkIiwic2V0Rm9jdXNlZCIsInNldEZvY3VzZWRLZXkiLCJ0cmlnZ2VyU3RhdGUiLCJpc09wZW4iLCJkZWZhdWx0T3BlbiIsInRyaWdnZXIiLCJkaXNwbGF5QWxsSXRlbXMiLCJzaXplIiwidG9nZ2xlIiwidG9nZ2xlTWVudSIsInVwZGF0ZUxhc3RDb2xsZWN0aW9uIiwiY2xvc2UiLCJsYXN0VmFsdWUiLCJzZXRMYXN0VmFsdWUiLCJfY29sbGVjdGlvbl9nZXRJdGVtX3RleHRWYWx1ZSIsIml0ZW1UZXh0IiwiX3Byb3BzX3NlbGVjdGVkS2V5IiwiX3JlZjEiLCJsYXN0U2VsZWN0ZWRLZXkiLCJkZWZhdWx0U2VsZWN0ZWRLZXkiLCJsYXN0U2VsZWN0ZWRLZXlUZXh0Iiwic2VsZWN0ZWRJdGVtVGV4dCIsInZhbGlkYXRpb24iLCJ2YWx1ZSIsInJldmVydCIsImNvbW1pdEN1c3RvbVZhbHVlIiwiY29tbWl0U2VsZWN0aW9uIiwiY29tbWl0VmFsdWUiLCJjb21taXQiLCJmb2N1c2VkS2V5IiwidmFsdWVPbkZvY3VzIiwiY29tbWl0VmFsaWRhdGlvbiIsImRpc3BsYXllZENvbGxlY3Rpb24iLCJmaWx0ZXIiLCIkYTllNzM4MmE3ZDExMWNiNSR2YXIkZmlsdGVyTm9kZXMiLCJub2RlcyIsImZpbHRlcmVkTm9kZSIsIm5vZGUiLCJ0eXBlIiwiaGFzQ2hpbGROb2RlcyIsImZpbHRlcmVkIiwic29tZSIsInB1c2giLCJjaGlsZE5vZGVzIiwidXNlQ29tYm9Cb3hTdGF0ZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-stately/combobox/dist/import.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-stately/flags/dist/import.mjs":
/*!***********************************************************!*\
  !*** ./node_modules/@react-stately/flags/dist/import.mjs ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   enableTableNestedRows: () => (/* binding */ $f4e2df6bd15f8569$export$d9d8a0f82de49530),\n/* harmony export */   tableNestedRows: () => (/* binding */ $f4e2df6bd15f8569$export$1b00cb14a96194e6)\n/* harmony export */ });\n/*\n * Copyright 2023 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ let $f4e2df6bd15f8569$var$_tableNestedRows = false;\nfunction $f4e2df6bd15f8569$export$d9d8a0f82de49530() {\n    $f4e2df6bd15f8569$var$_tableNestedRows = true;\n}\nfunction $f4e2df6bd15f8569$export$1b00cb14a96194e6() {\n    return $f4e2df6bd15f8569$var$_tableNestedRows;\n}\n //# sourceMappingURL=module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXN0YXRlbHkvZmxhZ3MvZGlzdC9pbXBvcnQubWpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7Ozs7Ozs7Ozs7Q0FVQyxHQUFHLElBQUlBLHlDQUF5QztBQUNqRCxTQUFTQztJQUNMRCx5Q0FBeUM7QUFDN0M7QUFDQSxTQUFTRTtJQUNMLE9BQU9GO0FBQ1g7QUFHMEksQ0FDMUksa0NBQWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1mbGFzay8uL25vZGVfbW9kdWxlcy9AcmVhY3Qtc3RhdGVseS9mbGFncy9kaXN0L2ltcG9ydC5tanM/YTgwMCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICogQ29weXJpZ2h0IDIwMjMgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gbGV0ICRmNGUyZGY2YmQxNWY4NTY5JHZhciRfdGFibGVOZXN0ZWRSb3dzID0gZmFsc2U7XG5mdW5jdGlvbiAkZjRlMmRmNmJkMTVmODU2OSRleHBvcnQkZDlkOGEwZjgyZGU0OTUzMCgpIHtcbiAgICAkZjRlMmRmNmJkMTVmODU2OSR2YXIkX3RhYmxlTmVzdGVkUm93cyA9IHRydWU7XG59XG5mdW5jdGlvbiAkZjRlMmRmNmJkMTVmODU2OSRleHBvcnQkMWIwMGNiMTRhOTYxOTRlNigpIHtcbiAgICByZXR1cm4gJGY0ZTJkZjZiZDE1Zjg1NjkkdmFyJF90YWJsZU5lc3RlZFJvd3M7XG59XG5cblxuZXhwb3J0IHskZjRlMmRmNmJkMTVmODU2OSRleHBvcnQkZDlkOGEwZjgyZGU0OTUzMCBhcyBlbmFibGVUYWJsZU5lc3RlZFJvd3MsICRmNGUyZGY2YmQxNWY4NTY5JGV4cG9ydCQxYjAwY2IxNGE5NjE5NGU2IGFzIHRhYmxlTmVzdGVkUm93c307XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tb2R1bGUuanMubWFwXG4iXSwibmFtZXMiOlsiJGY0ZTJkZjZiZDE1Zjg1NjkkdmFyJF90YWJsZU5lc3RlZFJvd3MiLCIkZjRlMmRmNmJkMTVmODU2OSRleHBvcnQkZDlkOGEwZjgyZGU0OTUzMCIsIiRmNGUyZGY2YmQxNWY4NTY5JGV4cG9ydCQxYjAwY2IxNGE5NjE5NGU2IiwiZW5hYmxlVGFibGVOZXN0ZWRSb3dzIiwidGFibGVOZXN0ZWRSb3dzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-stately/flags/dist/import.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-stately/form/dist/import.mjs":
/*!**********************************************************!*\
  !*** ./node_modules/@react-stately/form/dist/import.mjs ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DEFAULT_VALIDATION_RESULT: () => (/* binding */ $e5be200c675c3b3a$export$dad6ae84456c676a),\n/* harmony export */   FormValidationContext: () => (/* binding */ $e5be200c675c3b3a$export$571b5131b7e65c11),\n/* harmony export */   VALID_VALIDITY_STATE: () => (/* binding */ $e5be200c675c3b3a$export$aca958c65c314e6c),\n/* harmony export */   mergeValidation: () => (/* binding */ $e5be200c675c3b3a$export$75ee7c75d68f5b0e),\n/* harmony export */   privateValidationStateProp: () => (/* binding */ $e5be200c675c3b3a$export$a763b9476acd3eb),\n/* harmony export */   useFormValidationState: () => (/* binding */ $e5be200c675c3b3a$export$fc1a364ae1f3ff10)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n\n/*\n * Copyright 2023 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n * Copyright 2023 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ const $e5be200c675c3b3a$export$aca958c65c314e6c = {\n    badInput: false,\n    customError: false,\n    patternMismatch: false,\n    rangeOverflow: false,\n    rangeUnderflow: false,\n    stepMismatch: false,\n    tooLong: false,\n    tooShort: false,\n    typeMismatch: false,\n    valueMissing: false,\n    valid: true\n};\nconst $e5be200c675c3b3a$var$CUSTOM_VALIDITY_STATE = {\n    ...$e5be200c675c3b3a$export$aca958c65c314e6c,\n    customError: true,\n    valid: false\n};\nconst $e5be200c675c3b3a$export$dad6ae84456c676a = {\n    isInvalid: false,\n    validationDetails: $e5be200c675c3b3a$export$aca958c65c314e6c,\n    validationErrors: []\n};\nconst $e5be200c675c3b3a$export$571b5131b7e65c11 = (0, react__WEBPACK_IMPORTED_MODULE_0__.createContext)({});\nconst $e5be200c675c3b3a$export$a763b9476acd3eb = \"__formValidationState\" + Date.now();\nfunction $e5be200c675c3b3a$export$fc1a364ae1f3ff10(props) {\n    // Private prop for parent components to pass state to children.\n    if (props[$e5be200c675c3b3a$export$a763b9476acd3eb]) {\n        let { realtimeValidation: realtimeValidation, displayValidation: displayValidation, updateValidation: updateValidation, resetValidation: resetValidation, commitValidation: commitValidation } = props[$e5be200c675c3b3a$export$a763b9476acd3eb];\n        return {\n            realtimeValidation: realtimeValidation,\n            displayValidation: displayValidation,\n            updateValidation: updateValidation,\n            resetValidation: resetValidation,\n            commitValidation: commitValidation\n        };\n    }\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    return $e5be200c675c3b3a$var$useFormValidationStateImpl(props);\n}\nfunction $e5be200c675c3b3a$var$useFormValidationStateImpl(props) {\n    let { isInvalid: isInvalid, validationState: validationState, name: name, value: value, builtinValidation: builtinValidation, validate: validate, validationBehavior: validationBehavior = \"aria\" } = props;\n    // backward compatibility.\n    if (validationState) isInvalid || (isInvalid = validationState === \"invalid\");\n    // If the isInvalid prop is true, update validation result in realtime (controlled).\n    let controlledError = isInvalid ? {\n        isInvalid: true,\n        validationErrors: [],\n        validationDetails: $e5be200c675c3b3a$var$CUSTOM_VALIDITY_STATE\n    } : null;\n    // Perform custom client side validation.\n    let clientError = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>$e5be200c675c3b3a$var$getValidationResult($e5be200c675c3b3a$var$runValidate(validate, value)), [\n        validate,\n        value\n    ]);\n    if (builtinValidation === null || builtinValidation === void 0 ? void 0 : builtinValidation.validationDetails.valid) builtinValidation = null;\n    // Get relevant server errors from the form.\n    let serverErrors = (0, react__WEBPACK_IMPORTED_MODULE_0__.useContext)($e5be200c675c3b3a$export$571b5131b7e65c11);\n    let serverErrorMessages = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        if (name) return Array.isArray(name) ? name.flatMap((name)=>$e5be200c675c3b3a$var$asArray(serverErrors[name])) : $e5be200c675c3b3a$var$asArray(serverErrors[name]);\n        return [];\n    }, [\n        serverErrors,\n        name\n    ]);\n    // Show server errors when the form gets a new value, and clear when the user changes the value.\n    let [lastServerErrors, setLastServerErrors] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(serverErrors);\n    let [isServerErrorCleared, setServerErrorCleared] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    if (serverErrors !== lastServerErrors) {\n        setLastServerErrors(serverErrors);\n        setServerErrorCleared(false);\n    }\n    let serverError = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>$e5be200c675c3b3a$var$getValidationResult(isServerErrorCleared ? [] : serverErrorMessages), [\n        isServerErrorCleared,\n        serverErrorMessages\n    ]);\n    // Track the next validation state in a ref until commitValidation is called.\n    let nextValidation = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)($e5be200c675c3b3a$export$dad6ae84456c676a);\n    let [currentValidity, setCurrentValidity] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)($e5be200c675c3b3a$export$dad6ae84456c676a);\n    let lastError = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)($e5be200c675c3b3a$export$dad6ae84456c676a);\n    let commitValidation = ()=>{\n        if (!commitQueued) return;\n        setCommitQueued(false);\n        let error = clientError || builtinValidation || nextValidation.current;\n        if (!$e5be200c675c3b3a$var$isEqualValidation(error, lastError.current)) {\n            lastError.current = error;\n            setCurrentValidity(error);\n        }\n    };\n    let [commitQueued, setCommitQueued] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    (0, react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(commitValidation);\n    // realtimeValidation is used to update the native input element's state based on custom validation logic.\n    // displayValidation is the currently displayed validation state that the user sees (e.g. on input change/form submit).\n    // With validationBehavior=\"aria\", all errors are displayed in realtime rather than on submit.\n    let realtimeValidation = controlledError || serverError || clientError || builtinValidation || $e5be200c675c3b3a$export$dad6ae84456c676a;\n    let displayValidation = validationBehavior === \"native\" ? controlledError || serverError || currentValidity : controlledError || serverError || clientError || builtinValidation || currentValidity;\n    return {\n        realtimeValidation: realtimeValidation,\n        displayValidation: displayValidation,\n        updateValidation (value) {\n            // If validationBehavior is 'aria', update in realtime. Otherwise, store in a ref until commit.\n            if (validationBehavior === \"aria\" && !$e5be200c675c3b3a$var$isEqualValidation(currentValidity, value)) setCurrentValidity(value);\n            else nextValidation.current = value;\n        },\n        resetValidation () {\n            // Update the currently displayed validation state to valid on form reset,\n            // even if the native validity says it isn't. It'll show again on the next form submit.\n            let error = $e5be200c675c3b3a$export$dad6ae84456c676a;\n            if (!$e5be200c675c3b3a$var$isEqualValidation(error, lastError.current)) {\n                lastError.current = error;\n                setCurrentValidity(error);\n            }\n            // Do not commit validation after the next render. This avoids a condition where\n            // useSelect calls commitValidation inside an onReset handler.\n            if (validationBehavior === \"native\") setCommitQueued(false);\n            setServerErrorCleared(true);\n        },\n        commitValidation () {\n            // Commit validation state so the user sees it on blur/change/submit. Also clear any server errors.\n            // Wait until after the next render to commit so that the latest value has been validated.\n            if (validationBehavior === \"native\") setCommitQueued(true);\n            setServerErrorCleared(true);\n        }\n    };\n}\nfunction $e5be200c675c3b3a$var$asArray(v) {\n    if (!v) return [];\n    return Array.isArray(v) ? v : [\n        v\n    ];\n}\nfunction $e5be200c675c3b3a$var$runValidate(validate, value) {\n    if (typeof validate === \"function\") {\n        let e = validate(value);\n        if (e && typeof e !== \"boolean\") return $e5be200c675c3b3a$var$asArray(e);\n    }\n    return [];\n}\nfunction $e5be200c675c3b3a$var$getValidationResult(errors) {\n    return errors.length ? {\n        isInvalid: true,\n        validationErrors: errors,\n        validationDetails: $e5be200c675c3b3a$var$CUSTOM_VALIDITY_STATE\n    } : null;\n}\nfunction $e5be200c675c3b3a$var$isEqualValidation(a, b) {\n    if (a === b) return true;\n    return a && b && a.isInvalid === b.isInvalid && a.validationErrors.length === b.validationErrors.length && a.validationErrors.every((a, i)=>a === b.validationErrors[i]) && Object.entries(a.validationDetails).every(([k, v])=>b.validationDetails[k] === v);\n}\nfunction $e5be200c675c3b3a$export$75ee7c75d68f5b0e(...results) {\n    let errors = new Set();\n    let isInvalid = false;\n    let validationDetails = {\n        ...$e5be200c675c3b3a$export$aca958c65c314e6c\n    };\n    for (let v of results){\n        var _validationDetails, _key;\n        for (let e of v.validationErrors)errors.add(e);\n        // Only these properties apply for checkboxes.\n        isInvalid || (isInvalid = v.isInvalid);\n        for(let key in validationDetails)(_validationDetails = validationDetails)[_key = key] || (_validationDetails[_key] = v.validationDetails[key]);\n    }\n    validationDetails.valid = !isInvalid;\n    return {\n        isInvalid: isInvalid,\n        validationErrors: [\n            ...errors\n        ],\n        validationDetails: validationDetails\n    };\n}\n //# sourceMappingURL=module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXN0YXRlbHkvZm9ybS9kaXN0L2ltcG9ydC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUE2TTtBQUU3TTs7Ozs7Ozs7OztDQVVDLEdBQUc7Ozs7Ozs7Ozs7Q0FVSCxHQUNELE1BQU1ZLDRDQUE0QztJQUM5Q0MsVUFBVTtJQUNWQyxhQUFhO0lBQ2JDLGlCQUFpQjtJQUNqQkMsZUFBZTtJQUNmQyxnQkFBZ0I7SUFDaEJDLGNBQWM7SUFDZEMsU0FBUztJQUNUQyxVQUFVO0lBQ1ZDLGNBQWM7SUFDZEMsY0FBYztJQUNkQyxPQUFPO0FBQ1g7QUFDQSxNQUFNQyw4Q0FBOEM7SUFDaEQsR0FBR1oseUNBQXlDO0lBQzVDRSxhQUFhO0lBQ2JTLE9BQU87QUFDWDtBQUNBLE1BQU1FLDRDQUE0QztJQUM5Q0MsV0FBVztJQUNYQyxtQkFBbUJmO0lBQ25CZ0Isa0JBQWtCLEVBQUU7QUFDeEI7QUFDQSxNQUFNQyw0Q0FBNEMsQ0FBQyxHQUFHNUIsZ0RBQW1CLEVBQUcsQ0FBQztBQUM3RSxNQUFNNkIsMkNBQTJDLDBCQUEwQkMsS0FBS0MsR0FBRztBQUNuRixTQUFTQywwQ0FBMENDLEtBQUs7SUFDcEQsZ0VBQWdFO0lBQ2hFLElBQUlBLEtBQUssQ0FBQ0oseUNBQXlDLEVBQUU7UUFDakQsSUFBSSxFQUFFSyxvQkFBb0JBLGtCQUFrQixFQUFFQyxtQkFBbUJBLGlCQUFpQixFQUFFQyxrQkFBa0JBLGdCQUFnQixFQUFFQyxpQkFBaUJBLGVBQWUsRUFBRUMsa0JBQWtCQSxnQkFBZ0IsRUFBRSxHQUFHTCxLQUFLLENBQUNKLHlDQUF5QztRQUNoUCxPQUFPO1lBQ0hLLG9CQUFvQkE7WUFDcEJDLG1CQUFtQkE7WUFDbkJDLGtCQUFrQkE7WUFDbEJDLGlCQUFpQkE7WUFDakJDLGtCQUFrQkE7UUFDdEI7SUFDSjtJQUNBLHNEQUFzRDtJQUN0RCxPQUFPQyxpREFBaUROO0FBQzVEO0FBQ0EsU0FBU00saURBQWlETixLQUFLO0lBQzNELElB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LGdCQUFnQixDQUFDOEMsTUFBTSxLQUFLRSxFQUFFaEQsZ0JBQWdCLENBQUM4QyxNQUFNLElBQUlDLEVBQUUvQyxnQkFBZ0IsQ0FBQ2lELEtBQUssQ0FBQyxDQUFDRixHQUFHRyxJQUFJSCxNQUFNQyxFQUFFaEQsZ0JBQWdCLENBQUNrRCxFQUFFLEtBQUtDLE9BQU9DLE9BQU8sQ0FBQ0wsRUFBRWhELGlCQUFpQixFQUFFa0QsS0FBSyxDQUFDLENBQUMsQ0FBQ0ksR0FBR1YsRUFBRSxHQUFHSyxFQUFFakQsaUJBQWlCLENBQUNzRCxFQUFFLEtBQUtWO0FBQy9QO0FBQ0EsU0FBU1csMENBQTBDLEdBQUdDLE9BQU87SUFDekQsSUFBSVYsU0FBUyxJQUFJVztJQUNqQixJQUFJMUQsWUFBWTtJQUNoQixJQUFJQyxvQkFBb0I7UUFDcEIsR0FBR2YseUNBQXlDO0lBQ2hEO0lBQ0EsS0FBSyxJQUFJMkQsS0FBS1ksUUFBUTtRQUNsQixJQUFJRSxvQkFBb0JDO1FBQ3hCLEtBQUssSUFBSWQsS0FBS0QsRUFBRTNDLGdCQUFnQixDQUFDNkMsT0FBT2MsR0FBRyxDQUFDZjtRQUM1Qyw4Q0FBOEM7UUFDOUM5QyxhQUFjQSxDQUFBQSxZQUFZNkMsRUFBRTdDLFNBQVM7UUFDckMsSUFBSSxJQUFJOEQsT0FBTzdELGtCQUFrQixDQUFDMEQscUJBQXFCMUQsaUJBQWdCLENBQUUsQ0FBQzJELE9BQU9FLElBQUksSUFBS0gsQ0FBQUEsa0JBQWtCLENBQUNDLEtBQUssR0FBR2YsRUFBRTVDLGlCQUFpQixDQUFDNkQsSUFBSTtJQUNqSjtJQUNBN0Qsa0JBQWtCSixLQUFLLEdBQUcsQ0FBQ0c7SUFDM0IsT0FBTztRQUNIQSxXQUFXQTtRQUNYRSxrQkFBa0I7ZUFDWDZDO1NBQ047UUFDRDlDLG1CQUFtQkE7SUFDdkI7QUFDSjtBQUtrYSxDQUNsYSxrQ0FBa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LWZsYXNrLy4vbm9kZV9tb2R1bGVzL0ByZWFjdC1zdGF0ZWx5L2Zvcm0vZGlzdC9pbXBvcnQubWpzP2Y1MDAiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtjcmVhdGVDb250ZXh0IGFzICRqY0lPdyRjcmVhdGVDb250ZXh0LCB1c2VNZW1vIGFzICRqY0lPdyR1c2VNZW1vLCB1c2VDb250ZXh0IGFzICRqY0lPdyR1c2VDb250ZXh0LCB1c2VTdGF0ZSBhcyAkamNJT3ckdXNlU3RhdGUsIHVzZVJlZiBhcyAkamNJT3ckdXNlUmVmLCB1c2VFZmZlY3QgYXMgJGpjSU93JHVzZUVmZmVjdH0gZnJvbSBcInJlYWN0XCI7XG5cbi8qXG4gKiBDb3B5cmlnaHQgMjAyMyBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyAvKlxuICogQ29weXJpZ2h0IDIwMjMgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gXG5jb25zdCAkZTViZTIwMGM2NzVjM2IzYSRleHBvcnQkYWNhOTU4YzY1YzMxNGU2YyA9IHtcbiAgICBiYWRJbnB1dDogZmFsc2UsXG4gICAgY3VzdG9tRXJyb3I6IGZhbHNlLFxuICAgIHBhdHRlcm5NaXNtYXRjaDogZmFsc2UsXG4gICAgcmFuZ2VPdmVyZmxvdzogZmFsc2UsXG4gICAgcmFuZ2VVbmRlcmZsb3c6IGZhbHNlLFxuICAgIHN0ZXBNaXNtYXRjaDogZmFsc2UsXG4gICAgdG9vTG9uZzogZmFsc2UsXG4gICAgdG9vU2hvcnQ6IGZhbHNlLFxuICAgIHR5cGVNaXNtYXRjaDogZmFsc2UsXG4gICAgdmFsdWVNaXNzaW5nOiBmYWxzZSxcbiAgICB2YWxpZDogdHJ1ZVxufTtcbmNvbnN0ICRlNWJlMjAwYzY3NWMzYjNhJHZhciRDVVNUT01fVkFMSURJVFlfU1RBVEUgPSB7XG4gICAgLi4uJGU1YmUyMDBjNjc1YzNiM2EkZXhwb3J0JGFjYTk1OGM2NWMzMTRlNmMsXG4gICAgY3VzdG9tRXJyb3I6IHRydWUsXG4gICAgdmFsaWQ6IGZhbHNlXG59O1xuY29uc3QgJGU1YmUyMDBjNjc1YzNiM2EkZXhwb3J0JGRhZDZhZTg0NDU2YzY3NmEgPSB7XG4gICAgaXNJbnZhbGlkOiBmYWxzZSxcbiAgICB2YWxpZGF0aW9uRGV0YWlsczogJGU1YmUyMDBjNjc1YzNiM2EkZXhwb3J0JGFjYTk1OGM2NWMzMTRlNmMsXG4gICAgdmFsaWRhdGlvbkVycm9yczogW11cbn07XG5jb25zdCAkZTViZTIwMGM2NzVjM2IzYSRleHBvcnQkNTcxYjUxMzFiN2U2NWMxMSA9ICgwLCAkamNJT3ckY3JlYXRlQ29udGV4dCkoe30pO1xuY29uc3QgJGU1YmUyMDBjNjc1YzNiM2EkZXhwb3J0JGE3NjNiOTQ3NmFjZDNlYiA9IFwiX19mb3JtVmFsaWRhdGlvblN0YXRlXCIgKyBEYXRlLm5vdygpO1xuZnVuY3Rpb24gJGU1YmUyMDBjNjc1YzNiM2EkZXhwb3J0JGZjMWEzNjRhZTFmM2ZmMTAocHJvcHMpIHtcbiAgICAvLyBQcml2YXRlIHByb3AgZm9yIHBhcmVudCBjb21wb25lbnRzIHRvIHBhc3Mgc3RhdGUgdG8gY2hpbGRyZW4uXG4gICAgaWYgKHByb3BzWyRlNWJlMjAwYzY3NWMzYjNhJGV4cG9ydCRhNzYzYjk0NzZhY2QzZWJdKSB7XG4gICAgICAgIGxldCB7IHJlYWx0aW1lVmFsaWRhdGlvbjogcmVhbHRpbWVWYWxpZGF0aW9uLCBkaXNwbGF5VmFsaWRhdGlvbjogZGlzcGxheVZhbGlkYXRpb24sIHVwZGF0ZVZhbGlkYXRpb246IHVwZGF0ZVZhbGlkYXRpb24sIHJlc2V0VmFsaWRhdGlvbjogcmVzZXRWYWxpZGF0aW9uLCBjb21taXRWYWxpZGF0aW9uOiBjb21taXRWYWxpZGF0aW9uIH0gPSBwcm9wc1skZTViZTIwMGM2NzVjM2IzYSRleHBvcnQkYTc2M2I5NDc2YWNkM2ViXTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJlYWx0aW1lVmFsaWRhdGlvbjogcmVhbHRpbWVWYWxpZGF0aW9uLFxuICAgICAgICAgICAgZGlzcGxheVZhbGlkYXRpb246IGRpc3BsYXlWYWxpZGF0aW9uLFxuICAgICAgICAgICAgdXBkYXRlVmFsaWRhdGlvbjogdXBkYXRlVmFsaWRhdGlvbixcbiAgICAgICAgICAgIHJlc2V0VmFsaWRhdGlvbjogcmVzZXRWYWxpZGF0aW9uLFxuICAgICAgICAgICAgY29tbWl0VmFsaWRhdGlvbjogY29tbWl0VmFsaWRhdGlvblxuICAgICAgICB9O1xuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvcnVsZXMtb2YtaG9va3NcbiAgICByZXR1cm4gJGU1YmUyMDBjNjc1YzNiM2EkdmFyJHVzZUZvcm1WYWxpZGF0aW9uU3RhdGVJbXBsKHByb3BzKTtcbn1cbmZ1bmN0aW9uICRlNWJlMjAwYzY3NWMzYjNhJHZhciR1c2VGb3JtVmFsaWRhdGlvblN0YXRlSW1wbChwcm9wcykge1xuICAgIGxldCB7IGlzSW52YWxpZDogaXNJbnZhbGlkLCB2YWxpZGF0aW9uU3RhdGU6IHZhbGlkYXRpb25TdGF0ZSwgbmFtZTogbmFtZSwgdmFsdWU6IHZhbHVlLCBidWlsdGluVmFsaWRhdGlvbjogYnVpbHRpblZhbGlkYXRpb24sIHZhbGlkYXRlOiB2YWxpZGF0ZSwgdmFsaWRhdGlvbkJlaGF2aW9yOiB2YWxpZGF0aW9uQmVoYXZpb3IgPSBcImFyaWFcIiB9ID0gcHJvcHM7XG4gICAgLy8gYmFja3dhcmQgY29tcGF0aWJpbGl0eS5cbiAgICBpZiAodmFsaWRhdGlvblN0YXRlKSBpc0ludmFsaWQgfHwgKGlzSW52YWxpZCA9IHZhbGlkYXRpb25TdGF0ZSA9PT0gXCJpbnZhbGlkXCIpO1xuICAgIC8vIElmIHRoZSBpc0ludmFsaWQgcHJvcCBpcyB0cnVlLCB1cGRhdGUgdmFsaWRhdGlvbiByZXN1bHQgaW4gcmVhbHRpbWUgKGNvbnRyb2xsZWQpLlxuICAgIGxldCBjb250cm9sbGVkRXJyb3IgPSBpc0ludmFsaWQgPyB7XG4gICAgICAgIGlzSW52YWxpZDogdHJ1ZSxcbiAgICAgICAgdmFsaWRhdGlvbkVycm9yczogW10sXG4gICAgICAgIHZhbGlkYXRpb25EZXRhaWxzOiAkZTViZTIwMGM2NzVjM2IzYSR2YXIkQ1VTVE9NX1ZBTElESVRZX1NUQVRFXG4gICAgfSA6IG51bGw7XG4gICAgLy8gUGVyZm9ybSBjdXN0b20gY2xpZW50IHNpZGUgdmFsaWRhdGlvbi5cbiAgICBsZXQgY2xpZW50RXJyb3IgPSAoMCwgJGpjSU93JHVzZU1lbW8pKCgpPT4kZTViZTIwMGM2NzVjM2IzYSR2YXIkZ2V0VmFsaWRhdGlvblJlc3VsdCgkZTViZTIwMGM2NzVjM2IzYSR2YXIkcnVuVmFsaWRhdGUodmFsaWRhdGUsIHZhbHVlKSksIFtcbiAgICAgICAgdmFsaWRhdGUsXG4gICAgICAgIHZhbHVlXG4gICAgXSk7XG4gICAgaWYgKGJ1aWx0aW5WYWxpZGF0aW9uID09PSBudWxsIHx8IGJ1aWx0aW5WYWxpZGF0aW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBidWlsdGluVmFsaWRhdGlvbi52YWxpZGF0aW9uRGV0YWlscy52YWxpZCkgYnVpbHRpblZhbGlkYXRpb24gPSBudWxsO1xuICAgIC8vIEdldCByZWxldmFudCBzZXJ2ZXIgZXJyb3JzIGZyb20gdGhlIGZvcm0uXG4gICAgbGV0IHNlcnZlckVycm9ycyA9ICgwLCAkamNJT3ckdXNlQ29udGV4dCkoJGU1YmUyMDBjNjc1YzNiM2EkZXhwb3J0JDU3MWI1MTMxYjdlNjVjMTEpO1xuICAgIGxldCBzZXJ2ZXJFcnJvck1lc3NhZ2VzID0gKDAsICRqY0lPdyR1c2VNZW1vKSgoKT0+e1xuICAgICAgICBpZiAobmFtZSkgcmV0dXJuIEFycmF5LmlzQXJyYXkobmFtZSkgPyBuYW1lLmZsYXRNYXAoKG5hbWUpPT4kZTViZTIwMGM2NzVjM2IzYSR2YXIkYXNBcnJheShzZXJ2ZXJFcnJvcnNbbmFtZV0pKSA6ICRlNWJlMjAwYzY3NWMzYjNhJHZhciRhc0FycmF5KHNlcnZlckVycm9yc1tuYW1lXSk7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9LCBbXG4gICAgICAgIHNlcnZlckVycm9ycyxcbiAgICAgICAgbmFtZVxuICAgIF0pO1xuICAgIC8vIFNob3cgc2VydmVyIGVycm9ycyB3aGVuIHRoZSBmb3JtIGdldHMgYSBuZXcgdmFsdWUsIGFuZCBjbGVhciB3aGVuIHRoZSB1c2VyIGNoYW5nZXMgdGhlIHZhbHVlLlxuICAgIGxldCBbbGFzdFNlcnZlckVycm9ycywgc2V0TGFzdFNlcnZlckVycm9yc10gPSAoMCwgJGpjSU93JHVzZVN0YXRlKShzZXJ2ZXJFcnJvcnMpO1xuICAgIGxldCBbaXNTZXJ2ZXJFcnJvckNsZWFyZWQsIHNldFNlcnZlckVycm9yQ2xlYXJlZF0gPSAoMCwgJGpjSU93JHVzZVN0YXRlKShmYWxzZSk7XG4gICAgaWYgKHNlcnZlckVycm9ycyAhPT0gbGFzdFNlcnZlckVycm9ycykge1xuICAgICAgICBzZXRMYXN0U2VydmVyRXJyb3JzKHNlcnZlckVycm9ycyk7XG4gICAgICAgIHNldFNlcnZlckVycm9yQ2xlYXJlZChmYWxzZSk7XG4gICAgfVxuICAgIGxldCBzZXJ2ZXJFcnJvciA9ICgwLCAkamNJT3ckdXNlTWVtbykoKCk9PiRlNWJlMjAwYzY3NWMzYjNhJHZhciRnZXRWYWxpZGF0aW9uUmVzdWx0KGlzU2VydmVyRXJyb3JDbGVhcmVkID8gW10gOiBzZXJ2ZXJFcnJvck1lc3NhZ2VzKSwgW1xuICAgICAgICBpc1NlcnZlckVycm9yQ2xlYXJlZCxcbiAgICAgICAgc2VydmVyRXJyb3JNZXNzYWdlc1xuICAgIF0pO1xuICAgIC8vIFRyYWNrIHRoZSBuZXh0IHZhbGlkYXRpb24gc3RhdGUgaW4gYSByZWYgdW50aWwgY29tbWl0VmFsaWRhdGlvbiBpcyBjYWxsZWQuXG4gICAgbGV0IG5leHRWYWxpZGF0aW9uID0gKDAsICRqY0lPdyR1c2VSZWYpKCRlNWJlMjAwYzY3NWMzYjNhJGV4cG9ydCRkYWQ2YWU4NDQ1NmM2NzZhKTtcbiAgICBsZXQgW2N1cnJlbnRWYWxpZGl0eSwgc2V0Q3VycmVudFZhbGlkaXR5XSA9ICgwLCAkamNJT3ckdXNlU3RhdGUpKCRlNWJlMjAwYzY3NWMzYjNhJGV4cG9ydCRkYWQ2YWU4NDQ1NmM2NzZhKTtcbiAgICBsZXQgbGFzdEVycm9yID0gKDAsICRqY0lPdyR1c2VSZWYpKCRlNWJlMjAwYzY3NWMzYjNhJGV4cG9ydCRkYWQ2YWU4NDQ1NmM2NzZhKTtcbiAgICBsZXQgY29tbWl0VmFsaWRhdGlvbiA9ICgpPT57XG4gICAgICAgIGlmICghY29tbWl0UXVldWVkKSByZXR1cm47XG4gICAgICAgIHNldENvbW1pdFF1ZXVlZChmYWxzZSk7XG4gICAgICAgIGxldCBlcnJvciA9IGNsaWVudEVycm9yIHx8IGJ1aWx0aW5WYWxpZGF0aW9uIHx8IG5leHRWYWxpZGF0aW9uLmN1cnJlbnQ7XG4gICAgICAgIGlmICghJGU1YmUyMDBjNjc1YzNiM2EkdmFyJGlzRXF1YWxWYWxpZGF0aW9uKGVycm9yLCBsYXN0RXJyb3IuY3VycmVudCkpIHtcbiAgICAgICAgICAgIGxhc3RFcnJvci5jdXJyZW50ID0gZXJyb3I7XG4gICAgICAgICAgICBzZXRDdXJyZW50VmFsaWRpdHkoZXJyb3IpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBsZXQgW2NvbW1pdFF1ZXVlZCwgc2V0Q29tbWl0UXVldWVkXSA9ICgwLCAkamNJT3ckdXNlU3RhdGUpKGZhbHNlKTtcbiAgICAoMCwgJGpjSU93JHVzZUVmZmVjdCkoY29tbWl0VmFsaWRhdGlvbik7XG4gICAgLy8gcmVhbHRpbWVWYWxpZGF0aW9uIGlzIHVzZWQgdG8gdXBkYXRlIHRoZSBuYXRpdmUgaW5wdXQgZWxlbWVudCdzIHN0YXRlIGJhc2VkIG9uIGN1c3RvbSB2YWxpZGF0aW9uIGxvZ2ljLlxuICAgIC8vIGRpc3BsYXlWYWxpZGF0aW9uIGlzIHRoZSBjdXJyZW50bHkgZGlzcGxheWVkIHZhbGlkYXRpb24gc3RhdGUgdGhhdCB0aGUgdXNlciBzZWVzIChlLmcuIG9uIGlucHV0IGNoYW5nZS9mb3JtIHN1Ym1pdCkuXG4gICAgLy8gV2l0aCB2YWxpZGF0aW9uQmVoYXZpb3I9XCJhcmlhXCIsIGFsbCBlcnJvcnMgYXJlIGRpc3BsYXllZCBpbiByZWFsdGltZSByYXRoZXIgdGhhbiBvbiBzdWJtaXQuXG4gICAgbGV0IHJlYWx0aW1lVmFsaWRhdGlvbiA9IGNvbnRyb2xsZWRFcnJvciB8fCBzZXJ2ZXJFcnJvciB8fCBjbGllbnRFcnJvciB8fCBidWlsdGluVmFsaWRhdGlvbiB8fCAkZTViZTIwMGM2NzVjM2IzYSRleHBvcnQkZGFkNmFlODQ0NTZjNjc2YTtcbiAgICBsZXQgZGlzcGxheVZhbGlkYXRpb24gPSB2YWxpZGF0aW9uQmVoYXZpb3IgPT09IFwibmF0aXZlXCIgPyBjb250cm9sbGVkRXJyb3IgfHwgc2VydmVyRXJyb3IgfHwgY3VycmVudFZhbGlkaXR5IDogY29udHJvbGxlZEVycm9yIHx8IHNlcnZlckVycm9yIHx8IGNsaWVudEVycm9yIHx8IGJ1aWx0aW5WYWxpZGF0aW9uIHx8IGN1cnJlbnRWYWxpZGl0eTtcbiAgICByZXR1cm4ge1xuICAgICAgICByZWFsdGltZVZhbGlkYXRpb246IHJlYWx0aW1lVmFsaWRhdGlvbixcbiAgICAgICAgZGlzcGxheVZhbGlkYXRpb246IGRpc3BsYXlWYWxpZGF0aW9uLFxuICAgICAgICB1cGRhdGVWYWxpZGF0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgLy8gSWYgdmFsaWRhdGlvbkJlaGF2aW9yIGlzICdhcmlhJywgdXBkYXRlIGluIHJlYWx0aW1lLiBPdGhlcndpc2UsIHN0b3JlIGluIGEgcmVmIHVudGlsIGNvbW1pdC5cbiAgICAgICAgICAgIGlmICh2YWxpZGF0aW9uQmVoYXZpb3IgPT09IFwiYXJpYVwiICYmICEkZTViZTIwMGM2NzVjM2IzYSR2YXIkaXNFcXVhbFZhbGlkYXRpb24oY3VycmVudFZhbGlkaXR5LCB2YWx1ZSkpIHNldEN1cnJlbnRWYWxpZGl0eSh2YWx1ZSk7XG4gICAgICAgICAgICBlbHNlIG5leHRWYWxpZGF0aW9uLmN1cnJlbnQgPSB2YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgcmVzZXRWYWxpZGF0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgY3VycmVudGx5IGRpc3BsYXllZCB2YWxpZGF0aW9uIHN0YXRlIHRvIHZhbGlkIG9uIGZvcm0gcmVzZXQsXG4gICAgICAgICAgICAvLyBldmVuIGlmIHRoZSBuYXRpdmUgdmFsaWRpdHkgc2F5cyBpdCBpc24ndC4gSXQnbGwgc2hvdyBhZ2FpbiBvbiB0aGUgbmV4dCBmb3JtIHN1Ym1pdC5cbiAgICAgICAgICAgIGxldCBlcnJvciA9ICRlNWJlMjAwYzY3NWMzYjNhJGV4cG9ydCRkYWQ2YWU4NDQ1NmM2NzZhO1xuICAgICAgICAgICAgaWYgKCEkZTViZTIwMGM2NzVjM2IzYSR2YXIkaXNFcXVhbFZhbGlkYXRpb24oZXJyb3IsIGxhc3RFcnJvci5jdXJyZW50KSkge1xuICAgICAgICAgICAgICAgIGxhc3RFcnJvci5jdXJyZW50ID0gZXJyb3I7XG4gICAgICAgICAgICAgICAgc2V0Q3VycmVudFZhbGlkaXR5KGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIERvIG5vdCBjb21taXQgdmFsaWRhdGlvbiBhZnRlciB0aGUgbmV4dCByZW5kZXIuIFRoaXMgYXZvaWRzIGEgY29uZGl0aW9uIHdoZXJlXG4gICAgICAgICAgICAvLyB1c2VTZWxlY3QgY2FsbHMgY29tbWl0VmFsaWRhdGlvbiBpbnNpZGUgYW4gb25SZXNldCBoYW5kbGVyLlxuICAgICAgICAgICAgaWYgKHZhbGlkYXRpb25CZWhhdmlvciA9PT0gXCJuYXRpdmVcIikgc2V0Q29tbWl0UXVldWVkKGZhbHNlKTtcbiAgICAgICAgICAgIHNldFNlcnZlckVycm9yQ2xlYXJlZCh0cnVlKTtcbiAgICAgICAgfSxcbiAgICAgICAgY29tbWl0VmFsaWRhdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBDb21taXQgdmFsaWRhdGlvbiBzdGF0ZSBzbyB0aGUgdXNlciBzZWVzIGl0IG9uIGJsdXIvY2hhbmdlL3N1Ym1pdC4gQWxzbyBjbGVhciBhbnkgc2VydmVyIGVycm9ycy5cbiAgICAgICAgICAgIC8vIFdhaXQgdW50aWwgYWZ0ZXIgdGhlIG5leHQgcmVuZGVyIHRvIGNvbW1pdCBzbyB0aGF0IHRoZSBsYXRlc3QgdmFsdWUgaGFzIGJlZW4gdmFsaWRhdGVkLlxuICAgICAgICAgICAgaWYgKHZhbGlkYXRpb25CZWhhdmlvciA9PT0gXCJuYXRpdmVcIikgc2V0Q29tbWl0UXVldWVkKHRydWUpO1xuICAgICAgICAgICAgc2V0U2VydmVyRXJyb3JDbGVhcmVkKHRydWUpO1xuICAgICAgICB9XG4gICAgfTtcbn1cbmZ1bmN0aW9uICRlNWJlMjAwYzY3NWMzYjNhJHZhciRhc0FycmF5KHYpIHtcbiAgICBpZiAoIXYpIHJldHVybiBbXTtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh2KSA/IHYgOiBbXG4gICAgICAgIHZcbiAgICBdO1xufVxuZnVuY3Rpb24gJGU1YmUyMDBjNjc1YzNiM2EkdmFyJHJ1blZhbGlkYXRlKHZhbGlkYXRlLCB2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsaWRhdGUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBsZXQgZSA9IHZhbGlkYXRlKHZhbHVlKTtcbiAgICAgICAgaWYgKGUgJiYgdHlwZW9mIGUgIT09IFwiYm9vbGVhblwiKSByZXR1cm4gJGU1YmUyMDBjNjc1YzNiM2EkdmFyJGFzQXJyYXkoZSk7XG4gICAgfVxuICAgIHJldHVybiBbXTtcbn1cbmZ1bmN0aW9uICRlNWJlMjAwYzY3NWMzYjNhJHZhciRnZXRWYWxpZGF0aW9uUmVzdWx0KGVycm9ycykge1xuICAgIHJldHVybiBlcnJvcnMubGVuZ3RoID8ge1xuICAgICAgICBpc0ludmFsaWQ6IHRydWUsXG4gICAgICAgIHZhbGlkYXRpb25FcnJvcnM6IGVycm9ycyxcbiAgICAgICAgdmFsaWRhdGlvbkRldGFpbHM6ICRlNWJlMjAwYzY3NWMzYjNhJHZhciRDVVNUT01fVkFMSURJVFlfU1RBVEVcbiAgICB9IDogbnVsbDtcbn1cbmZ1bmN0aW9uICRlNWJlMjAwYzY3NWMzYjNhJHZhciRpc0VxdWFsVmFsaWRhdGlvbihhLCBiKSB7XG4gICAgaWYgKGEgPT09IGIpIHJldHVybiB0cnVlO1xuICAgIHJldHVybiBhICYmIGIgJiYgYS5pc0ludmFsaWQgPT09IGIuaXNJbnZhbGlkICYmIGEudmFsaWRhdGlvbkVycm9ycy5sZW5ndGggPT09IGIudmFsaWRhdGlvbkVycm9ycy5sZW5ndGggJiYgYS52YWxpZGF0aW9uRXJyb3JzLmV2ZXJ5KChhLCBpKT0+YSA9PT0gYi52YWxpZGF0aW9uRXJyb3JzW2ldKSAmJiBPYmplY3QuZW50cmllcyhhLnZhbGlkYXRpb25EZXRhaWxzKS5ldmVyeSgoW2ssIHZdKT0+Yi52YWxpZGF0aW9uRGV0YWlsc1trXSA9PT0gdik7XG59XG5mdW5jdGlvbiAkZTViZTIwMGM2NzVjM2IzYSRleHBvcnQkNzVlZTdjNzVkNjhmNWIwZSguLi5yZXN1bHRzKSB7XG4gICAgbGV0IGVycm9ycyA9IG5ldyBTZXQoKTtcbiAgICBsZXQgaXNJbnZhbGlkID0gZmFsc2U7XG4gICAgbGV0IHZhbGlkYXRpb25EZXRhaWxzID0ge1xuICAgICAgICAuLi4kZTViZTIwMGM2NzVjM2IzYSRleHBvcnQkYWNhOTU4YzY1YzMxNGU2Y1xuICAgIH07XG4gICAgZm9yIChsZXQgdiBvZiByZXN1bHRzKXtcbiAgICAgICAgdmFyIF92YWxpZGF0aW9uRGV0YWlscywgX2tleTtcbiAgICAgICAgZm9yIChsZXQgZSBvZiB2LnZhbGlkYXRpb25FcnJvcnMpZXJyb3JzLmFkZChlKTtcbiAgICAgICAgLy8gT25seSB0aGVzZSBwcm9wZXJ0aWVzIGFwcGx5IGZvciBjaGVja2JveGVzLlxuICAgICAgICBpc0ludmFsaWQgfHwgKGlzSW52YWxpZCA9IHYuaXNJbnZhbGlkKTtcbiAgICAgICAgZm9yKGxldCBrZXkgaW4gdmFsaWRhdGlvbkRldGFpbHMpKF92YWxpZGF0aW9uRGV0YWlscyA9IHZhbGlkYXRpb25EZXRhaWxzKVtfa2V5ID0ga2V5XSB8fCAoX3ZhbGlkYXRpb25EZXRhaWxzW19rZXldID0gdi52YWxpZGF0aW9uRGV0YWlsc1trZXldKTtcbiAgICB9XG4gICAgdmFsaWRhdGlvbkRldGFpbHMudmFsaWQgPSAhaXNJbnZhbGlkO1xuICAgIHJldHVybiB7XG4gICAgICAgIGlzSW52YWxpZDogaXNJbnZhbGlkLFxuICAgICAgICB2YWxpZGF0aW9uRXJyb3JzOiBbXG4gICAgICAgICAgICAuLi5lcnJvcnNcbiAgICAgICAgXSxcbiAgICAgICAgdmFsaWRhdGlvbkRldGFpbHM6IHZhbGlkYXRpb25EZXRhaWxzXG4gICAgfTtcbn1cblxuXG5cblxuZXhwb3J0IHskZTViZTIwMGM2NzVjM2IzYSRleHBvcnQkNTcxYjUxMzFiN2U2NWMxMSBhcyBGb3JtVmFsaWRhdGlvbkNvbnRleHQsICRlNWJlMjAwYzY3NWMzYjNhJGV4cG9ydCRmYzFhMzY0YWUxZjNmZjEwIGFzIHVzZUZvcm1WYWxpZGF0aW9uU3RhdGUsICRlNWJlMjAwYzY3NWMzYjNhJGV4cG9ydCRkYWQ2YWU4NDQ1NmM2NzZhIGFzIERFRkFVTFRfVkFMSURBVElPTl9SRVNVTFQsICRlNWJlMjAwYzY3NWMzYjNhJGV4cG9ydCRhY2E5NThjNjVjMzE0ZTZjIGFzIFZBTElEX1ZBTElESVRZX1NUQVRFLCAkZTViZTIwMGM2NzVjM2IzYSRleHBvcnQkYTc2M2I5NDc2YWNkM2ViIGFzIHByaXZhdGVWYWxpZGF0aW9uU3RhdGVQcm9wLCAkZTViZTIwMGM2NzVjM2IzYSRleHBvcnQkNzVlZTdjNzVkNjhmNWIwZSBhcyBtZXJnZVZhbGlkYXRpb259O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bW9kdWxlLmpzLm1hcFxuIl0sIm5hbWVzIjpbImNyZWF0ZUNvbnRleHQiLCIkamNJT3ckY3JlYXRlQ29udGV4dCIsInVzZU1lbW8iLCIkamNJT3ckdXNlTWVtbyIsInVzZUNvbnRleHQiLCIkamNJT3ckdXNlQ29udGV4dCIsInVzZVN0YXRlIiwiJGpjSU93JHVzZVN0YXRlIiwidXNlUmVmIiwiJGpjSU93JHVzZVJlZiIsInVzZUVmZmVjdCIsIiRqY0lPdyR1c2VFZmZlY3QiLCIkZTViZTIwMGM2NzVjM2IzYSRleHBvcnQkYWNhOTU4YzY1YzMxNGU2YyIsImJhZElucHV0IiwiY3VzdG9tRXJyb3IiLCJwYXR0ZXJuTWlzbWF0Y2giLCJyYW5nZU92ZXJmbG93IiwicmFuZ2VVbmRlcmZsb3ciLCJzdGVwTWlzbWF0Y2giLCJ0b29Mb25nIiwidG9vU2hvcnQiLCJ0eXBlTWlzbWF0Y2giLCJ2YWx1ZU1pc3NpbmciLCJ2YWxpZCIsIiRlNWJlMjAwYzY3NWMzYjNhJHZhciRDVVNUT01fVkFMSURJVFlfU1RBVEUiLCIkZTViZTIwMGM2NzVjM2IzYSRleHBvcnQkZGFkNmFlODQ0NTZjNjc2YSIsImlzSW52YWxpZCIsInZhbGlkYXRpb25EZXRhaWxzIiwidmFsaWRhdGlvbkVycm9ycyIsIiRlNWJlMjAwYzY3NWMzYjNhJGV4cG9ydCQ1NzFiNTEzMWI3ZTY1YzExIiwiJGU1YmUyMDBjNjc1YzNiM2EkZXhwb3J0JGE3NjNiOTQ3NmFjZDNlYiIsIkRhdGUiLCJub3ciLCIkZTViZTIwMGM2NzVjM2IzYSRleHBvcnQkZmMxYTM2NGFlMWYzZmYxMCIsInByb3BzIiwicmVhbHRpbWVWYWxpZGF0aW9uIiwiZGlzcGxheVZhbGlkYXRpb24iLCJ1cGRhdGVWYWxpZGF0aW9uIiwicmVzZXRWYWxpZGF0aW9uIiwiY29tbWl0VmFsaWRhdGlvbiIsIiRlNWJlMjAwYzY3NWMzYjNhJHZhciR1c2VGb3JtVmFsaWRhdGlvblN0YXRlSW1wbCIsInZhbGlkYXRpb25TdGF0ZSIsIm5hbWUiLCJ2YWx1ZSIsImJ1aWx0aW5WYWxpZGF0aW9uIiwidmFsaWRhdGUiLCJ2YWxpZGF0aW9uQmVoYXZpb3IiLCJjb250cm9sbGVkRXJyb3IiLCJjbGllbnRFcnJvciIsIiRlNWJlMjAwYzY3NWMzYjNhJHZhciRnZXRWYWxpZGF0aW9uUmVzdWx0IiwiJGU1YmUyMDBjNjc1YzNiM2EkdmFyJHJ1blZhbGlkYXRlIiwic2VydmVyRXJyb3JzIiwic2VydmVyRXJyb3JNZXNzYWdlcyIsIkFycmF5IiwiaXNBcnJheSIsImZsYXRNYXAiLCIkZTViZTIwMGM2NzVjM2IzYSR2YXIkYXNBcnJheSIsImxhc3RTZXJ2ZXJFcnJvcnMiLCJzZXRMYXN0U2VydmVyRXJyb3JzIiwiaXNTZXJ2ZXJFcnJvckNsZWFyZWQiLCJzZXRTZXJ2ZXJFcnJvckNsZWFyZWQiLCJzZXJ2ZXJFcnJvciIsIm5leHRWYWxpZGF0aW9uIiwiY3VycmVudFZhbGlkaXR5Iiwic2V0Q3VycmVudFZhbGlkaXR5IiwibGFzdEVycm9yIiwiY29tbWl0UXVldWVkIiwic2V0Q29tbWl0UXVldWVkIiwiZXJyb3IiLCJjdXJyZW50IiwiJGU1YmUyMDBjNjc1YzNiM2EkdmFyJGlzRXF1YWxWYWxpZGF0aW9uIiwidiIsImUiLCJlcnJvcnMiLCJsZW5ndGgiLCJhIiwiYiIsImV2ZXJ5IiwiaSIsIk9iamVjdCIsImVudHJpZXMiLCJrIiwiJGU1YmUyMDBjNjc1YzNiM2EkZXhwb3J0JDc1ZWU3Yzc1ZDY4ZjViMGUiLCJyZXN1bHRzIiwiU2V0IiwiX3ZhbGlkYXRpb25EZXRhaWxzIiwiX2tleSIsImFkZCIsImtleSIsIkZvcm1WYWxpZGF0aW9uQ29udGV4dCIsInVzZUZvcm1WYWxpZGF0aW9uU3RhdGUiLCJERUZBVUxUX1ZBTElEQVRJT05fUkVTVUxUIiwiVkFMSURfVkFMSURJVFlfU1RBVEUiLCJwcml2YXRlVmFsaWRhdGlvblN0YXRlUHJvcCIsIm1lcmdlVmFsaWRhdGlvbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-stately/form/dist/import.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-stately/grid/dist/import.mjs":
/*!**********************************************************!*\
  !*** ./node_modules/@react-stately/grid/dist/import.mjs ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GridCollection: () => (/* binding */ $16805b1b18093c5f$export$de3fdf6493c353d),\n/* harmony export */   useGridState: () => (/* binding */ $62967d126f3aa823$export$4007ac09ff9c68ed)\n/* harmony export */ });\n/* harmony import */ var _react_stately_collections__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @react-stately/collections */ \"(ssr)/./node_modules/@react-stately/collections/dist/import.mjs\");\n/* harmony import */ var _react_stately_selection__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @react-stately/selection */ \"(ssr)/./node_modules/@react-stately/selection/dist/import.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ function $62967d126f3aa823$export$4007ac09ff9c68ed(props) {\n    let { collection: collection, focusMode: focusMode } = props;\n    let selectionState = (0, _react_stately_selection__WEBPACK_IMPORTED_MODULE_1__.useMultipleSelectionState)(props);\n    let disabledKeys = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>props.disabledKeys ? new Set(props.disabledKeys) : new Set(), [\n        props.disabledKeys\n    ]);\n    let setFocusedKey = selectionState.setFocusedKey;\n    selectionState.setFocusedKey = (key, child)=>{\n        // If focusMode is cell and an item is focused, focus a child cell instead.\n        if (focusMode === \"cell\" && key != null) {\n            let item = collection.getItem(key);\n            if ((item === null || item === void 0 ? void 0 : item.type) === \"item\") {\n                var _getLastItem, _getFirstItem;\n                let children = (0, _react_stately_collections__WEBPACK_IMPORTED_MODULE_2__.getChildNodes)(item, collection);\n                if (child === \"last\") key = (_getLastItem = (0, _react_stately_collections__WEBPACK_IMPORTED_MODULE_2__.getLastItem)(children)) === null || _getLastItem === void 0 ? void 0 : _getLastItem.key;\n                else key = (_getFirstItem = (0, _react_stately_collections__WEBPACK_IMPORTED_MODULE_2__.getFirstItem)(children)) === null || _getFirstItem === void 0 ? void 0 : _getFirstItem.key;\n            }\n        }\n        setFocusedKey(key, child);\n    };\n    let selectionManager = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>new (0, _react_stately_selection__WEBPACK_IMPORTED_MODULE_1__.SelectionManager)(collection, selectionState), [\n        collection,\n        selectionState\n    ]);\n    // Reset focused key if that item is deleted from the collection.\n    const cachedCollection = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    (0, react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (selectionState.focusedKey != null && !collection.getItem(selectionState.focusedKey)) {\n            const node = cachedCollection.current.getItem(selectionState.focusedKey);\n            const parentNode = node.parentKey != null && (node.type === \"cell\" || node.type === \"rowheader\" || node.type === \"column\") ? cachedCollection.current.getItem(node.parentKey) : node;\n            const cachedRows = cachedCollection.current.rows;\n            const rows = collection.rows;\n            const diff = cachedRows.length - rows.length;\n            let index = Math.min(diff > 1 ? Math.max(parentNode.index - diff + 1, 0) : parentNode.index, rows.length - 1);\n            let newRow;\n            while(index >= 0){\n                if (!selectionManager.isDisabled(rows[index].key) && rows[index].type !== \"headerrow\") {\n                    newRow = rows[index];\n                    break;\n                }\n                // Find next, not disabled row.\n                if (index < rows.length - 1) index++;\n                else {\n                    if (index > parentNode.index) index = parentNode.index;\n                    index--;\n                }\n            }\n            if (newRow) {\n                const childNodes = newRow.hasChildNodes ? [\n                    ...(0, _react_stately_collections__WEBPACK_IMPORTED_MODULE_2__.getChildNodes)(newRow, collection)\n                ] : [];\n                const keyToFocus = newRow.hasChildNodes && parentNode !== node && node.index < childNodes.length ? childNodes[node.index].key : newRow.key;\n                selectionState.setFocusedKey(keyToFocus);\n            } else selectionState.setFocusedKey(null);\n        }\n        cachedCollection.current = collection;\n    }, [\n        collection,\n        selectionManager,\n        selectionState,\n        selectionState.focusedKey\n    ]);\n    return {\n        collection: collection,\n        disabledKeys: disabledKeys,\n        isKeyboardNavigationDisabled: false,\n        selectionManager: selectionManager\n    };\n}\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ class $16805b1b18093c5f$export$de3fdf6493c353d {\n    *[Symbol.iterator]() {\n        yield* [\n            ...this.rows\n        ];\n    }\n    get size() {\n        return [\n            ...this.rows\n        ].length;\n    }\n    getKeys() {\n        return this.keyMap.keys();\n    }\n    getKeyBefore(key) {\n        let node = this.keyMap.get(key);\n        return node ? node.prevKey : null;\n    }\n    getKeyAfter(key) {\n        let node = this.keyMap.get(key);\n        return node ? node.nextKey : null;\n    }\n    getFirstKey() {\n        var _;\n        return (_ = [\n            ...this.rows\n        ][0]) === null || _ === void 0 ? void 0 : _.key;\n    }\n    getLastKey() {\n        var _rows_;\n        let rows = [\n            ...this.rows\n        ];\n        return (_rows_ = rows[rows.length - 1]) === null || _rows_ === void 0 ? void 0 : _rows_.key;\n    }\n    getItem(key) {\n        return this.keyMap.get(key);\n    }\n    at(idx) {\n        const keys = [\n            ...this.getKeys()\n        ];\n        return this.getItem(keys[idx]);\n    }\n    getChildren(key) {\n        let node = this.keyMap.get(key);\n        return (node === null || node === void 0 ? void 0 : node.childNodes) || [];\n    }\n    constructor(opts){\n        this.keyMap = new Map();\n        this.keyMap = new Map();\n        this.columnCount = opts === null || opts === void 0 ? void 0 : opts.columnCount;\n        this.rows = [];\n        let visit = (node)=>{\n            // If the node is the same object as the previous node for the same key,\n            // we can skip this node and its children. We always visit columns though,\n            // because we depend on order to build the columns array.\n            let prevNode = this.keyMap.get(node.key);\n            if (opts.visitNode) node = opts.visitNode(node);\n            this.keyMap.set(node.key, node);\n            let childKeys = new Set();\n            let last;\n            for (let child of node.childNodes){\n                if (child.type === \"cell\" && child.parentKey == null) child.parentKey = node.key;\n                childKeys.add(child.key);\n                if (last) {\n                    last.nextKey = child.key;\n                    child.prevKey = last.key;\n                } else child.prevKey = null;\n                visit(child);\n                last = child;\n            }\n            if (last) last.nextKey = null;\n            // Remove deleted nodes and their children from the key map\n            if (prevNode) {\n                for (let child of prevNode.childNodes)if (!childKeys.has(child.key)) remove(child);\n            }\n        };\n        let remove = (node)=>{\n            this.keyMap.delete(node.key);\n            for (let child of node.childNodes)if (this.keyMap.get(child.key) === child) remove(child);\n        };\n        let last;\n        opts.items.forEach((node, i)=>{\n            let rowNode = {\n                level: 0,\n                key: \"row-\" + i,\n                type: \"row\",\n                value: undefined,\n                hasChildNodes: true,\n                childNodes: [\n                    ...node.childNodes\n                ],\n                rendered: undefined,\n                textValue: undefined,\n                ...node\n            };\n            if (last) {\n                last.nextKey = rowNode.key;\n                rowNode.prevKey = last.key;\n            } else rowNode.prevKey = null;\n            this.rows.push(rowNode);\n            visit(rowNode);\n            last = rowNode;\n        });\n        if (last) last.nextKey = null;\n    }\n}\n //# sourceMappingURL=module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXN0YXRlbHkvZ3JpZC9kaXN0L2ltcG9ydC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBeUo7QUFDTDtBQUM1QztBQUV4Rzs7Ozs7Ozs7OztDQVVDLEdBR0QsU0FBU2dCLDBDQUEwQ0MsS0FBSztJQUNwRCxJQUFJLEVBQUVDLFlBQVlBLFVBQVUsRUFBRUMsV0FBV0EsU0FBUyxFQUFFLEdBQUdGO0lBQ3ZELElBQUlHLGlCQUFpQixDQUFDLEdBQUdiLCtFQUErQixFQUFHVTtJQUMzRCxJQUFJSSxlQUFlLENBQUMsR0FBR1YsMENBQWEsRUFBRyxJQUFJTSxNQUFNSSxZQUFZLEdBQUcsSUFBSUMsSUFBSUwsTUFBTUksWUFBWSxJQUFJLElBQUlDLE9BQU87UUFDckdMLE1BQU1JLFlBQVk7S0FDckI7SUFDRCxJQUFJRSxnQkFBZ0JILGVBQWVHLGFBQWE7SUFDaERILGVBQWVHLGFBQWEsR0FBRyxDQUFDQyxLQUFLQztRQUNqQywyRUFBMkU7UUFDM0UsSUFBSU4sY0FBYyxVQUFVSyxPQUFPLE1BQU07WUFDckMsSUFBSUUsT0FBT1IsV0FBV1MsT0FBTyxDQUFDSDtZQUM5QixJQUFJLENBQUNFLFNBQVMsUUFBUUEsU0FBUyxLQUFLLElBQUksS0FBSyxJQUFJQSxLQUFLRSxJQUFJLE1BQU0sUUFBUTtnQkFDcEUsSUFBSUMsY0FBY0M7Z0JBQ2xCLElBQUlDLFdBQVcsQ0FBQyxHQUFHOUIscUVBQW1CLEVBQUd5QixNQUFNUjtnQkFDL0MsSUFBSU8sVUFBVSxRQUFRRCxNQUFNLENBQUNLLGVBQWUsQ0FBQyxHQUFHMUIsbUVBQWlCLEVBQUc0QixTQUFRLE1BQU8sUUFBUUYsaUJBQWlCLEtBQUssSUFBSSxLQUFLLElBQUlBLGFBQWFMLEdBQUc7cUJBQ3pJQSxNQUFNLENBQUNNLGdCQUFnQixDQUFDLEdBQUd6QixvRUFBa0IsRUFBRzBCLFNBQVEsTUFBTyxRQUFRRCxrQkFBa0IsS0FBSyxJQUFJLEtBQUssSUFBSUEsY0FBY04sR0FB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Q0FBQzFELE1BQU1ELEdBQUcsR0FBRzRELE9BQU8zRDtZQUNoRjtRQUNKO1FBQ0EsSUFBSTJELFNBQVMsQ0FBQ2pEO1lBQ1YsSUFBSSxDQUFDdUIsTUFBTSxDQUFDMkIsTUFBTSxDQUFDbEQsS0FBS1gsR0FBRztZQUMzQixLQUFLLElBQUlDLFNBQVNVLEtBQUtjLFVBQVUsQ0FBQyxJQUFJLElBQUksQ0FBQ1MsTUFBTSxDQUFDRyxHQUFHLENBQUNwQyxNQUFNRCxHQUFHLE1BQU1DLE9BQU8yRCxPQUFPM0Q7UUFDdkY7UUFDQSxJQUFJd0Q7UUFDSlIsS0FBS2EsS0FBSyxDQUFDQyxPQUFPLENBQUMsQ0FBQ3BELE1BQU1xRDtZQUN0QixJQUFJQyxVQUFVO2dCQUNWQyxPQUFPO2dCQUNQbEUsS0FBSyxTQUFTZ0U7Z0JBQ2Q1RCxNQUFNO2dCQUNOK0QsT0FBT0M7Z0JBQ1AxQyxlQUFlO2dCQUNmRCxZQUFZO3VCQUNMZCxLQUFLYyxVQUFVO2lCQUNyQjtnQkFDRDRDLFVBQVVEO2dCQUNWRSxXQUFXRjtnQkFDWCxHQUFHekQsSUFBSTtZQUNYO1lBQ0EsSUFBSThDLE1BQU07Z0JBQ05BLEtBQUtqQixPQUFPLEdBQUd5QixRQUFRakUsR0FBRztnQkFDMUJpRSxRQUFRM0IsT0FBTyxHQUFHbUIsS0FBS3pELEdBQUc7WUFDOUIsT0FBT2lFLFFBQVEzQixPQUFPLEdBQUc7WUFDekIsSUFBSSxDQUFDdEIsSUFBSSxDQUFDdUQsSUFBSSxDQUFDTjtZQUNmYixNQUFNYTtZQUNOUixPQUFPUTtRQUNYO1FBQ0EsSUFBSVIsTUFBTUEsS0FBS2pCLE9BQU8sR0FBRztJQUM3QjtBQUNKO0FBSytILENBQy9ILGtDQUFrQyIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtZmxhc2svLi9ub2RlX21vZHVsZXMvQHJlYWN0LXN0YXRlbHkvZ3JpZC9kaXN0L2ltcG9ydC5tanM/YjZhMyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge2dldENoaWxkTm9kZXMgYXMgJGNBbjVmJGdldENoaWxkTm9kZXMsIGdldExhc3RJdGVtIGFzICRjQW41ZiRnZXRMYXN0SXRlbSwgZ2V0Rmlyc3RJdGVtIGFzICRjQW41ZiRnZXRGaXJzdEl0ZW19IGZyb20gXCJAcmVhY3Qtc3RhdGVseS9jb2xsZWN0aW9uc1wiO1xuaW1wb3J0IHt1c2VNdWx0aXBsZVNlbGVjdGlvblN0YXRlIGFzICRjQW41ZiR1c2VNdWx0aXBsZVNlbGVjdGlvblN0YXRlLCBTZWxlY3Rpb25NYW5hZ2VyIGFzICRjQW41ZiRTZWxlY3Rpb25NYW5hZ2VyfSBmcm9tIFwiQHJlYWN0LXN0YXRlbHkvc2VsZWN0aW9uXCI7XG5pbXBvcnQge3VzZU1lbW8gYXMgJGNBbjVmJHVzZU1lbW8sIHVzZVJlZiBhcyAkY0FuNWYkdXNlUmVmLCB1c2VFZmZlY3QgYXMgJGNBbjVmJHVzZUVmZmVjdH0gZnJvbSBcInJlYWN0XCI7XG5cbi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyBcblxuXG5mdW5jdGlvbiAkNjI5NjdkMTI2ZjNhYTgyMyRleHBvcnQkNDAwN2FjMDlmZjljNjhlZChwcm9wcykge1xuICAgIGxldCB7IGNvbGxlY3Rpb246IGNvbGxlY3Rpb24sIGZvY3VzTW9kZTogZm9jdXNNb2RlIH0gPSBwcm9wcztcbiAgICBsZXQgc2VsZWN0aW9uU3RhdGUgPSAoMCwgJGNBbjVmJHVzZU11bHRpcGxlU2VsZWN0aW9uU3RhdGUpKHByb3BzKTtcbiAgICBsZXQgZGlzYWJsZWRLZXlzID0gKDAsICRjQW41ZiR1c2VNZW1vKSgoKT0+cHJvcHMuZGlzYWJsZWRLZXlzID8gbmV3IFNldChwcm9wcy5kaXNhYmxlZEtleXMpIDogbmV3IFNldCgpLCBbXG4gICAgICAgIHByb3BzLmRpc2FibGVkS2V5c1xuICAgIF0pO1xuICAgIGxldCBzZXRGb2N1c2VkS2V5ID0gc2VsZWN0aW9uU3RhdGUuc2V0Rm9jdXNlZEtleTtcbiAgICBzZWxlY3Rpb25TdGF0ZS5zZXRGb2N1c2VkS2V5ID0gKGtleSwgY2hpbGQpPT57XG4gICAgICAgIC8vIElmIGZvY3VzTW9kZSBpcyBjZWxsIGFuZCBhbiBpdGVtIGlzIGZvY3VzZWQsIGZvY3VzIGEgY2hpbGQgY2VsbCBpbnN0ZWFkLlxuICAgICAgICBpZiAoZm9jdXNNb2RlID09PSBcImNlbGxcIiAmJiBrZXkgIT0gbnVsbCkge1xuICAgICAgICAgICAgbGV0IGl0ZW0gPSBjb2xsZWN0aW9uLmdldEl0ZW0oa2V5KTtcbiAgICAgICAgICAgIGlmICgoaXRlbSA9PT0gbnVsbCB8fCBpdGVtID09PSB2b2lkIDAgPyB2b2lkIDAgOiBpdGVtLnR5cGUpID09PSBcIml0ZW1cIikge1xuICAgICAgICAgICAgICAgIHZhciBfZ2V0TGFzdEl0ZW0sIF9nZXRGaXJzdEl0ZW07XG4gICAgICAgICAgICAgICAgbGV0IGNoaWxkcmVuID0gKDAsICRjQW41ZiRnZXRDaGlsZE5vZGVzKShpdGVtLCBjb2xsZWN0aW9uKTtcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGQgPT09IFwibGFzdFwiKSBrZXkgPSAoX2dldExhc3RJdGVtID0gKDAsICRjQW41ZiRnZXRMYXN0SXRlbSkoY2hpbGRyZW4pKSA9PT0gbnVsbCB8fCBfZ2V0TGFzdEl0ZW0gPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9nZXRMYXN0SXRlbS5rZXk7XG4gICAgICAgICAgICAgICAgZWxzZSBrZXkgPSAoX2dldEZpcnN0SXRlbSA9ICgwLCAkY0FuNWYkZ2V0Rmlyc3RJdGVtKShjaGlsZHJlbikpID09PSBudWxsIHx8IF9nZXRGaXJzdEl0ZW0gPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9nZXRGaXJzdEl0ZW0ua2V5O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHNldEZvY3VzZWRLZXkoa2V5LCBjaGlsZCk7XG4gICAgfTtcbiAgICBsZXQgc2VsZWN0aW9uTWFuYWdlciA9ICgwLCAkY0FuNWYkdXNlTWVtbykoKCk9Pm5ldyAoMCwgJGNBbjVmJFNlbGVjdGlvbk1hbmFnZXIpKGNvbGxlY3Rpb24sIHNlbGVjdGlvblN0YXRlKSwgW1xuICAgICAgICBjb2xsZWN0aW9uLFxuICAgICAgICBzZWxlY3Rpb25TdGF0ZVxuICAgIF0pO1xuICAgIC8vIFJlc2V0IGZvY3VzZWQga2V5IGlmIHRoYXQgaXRlbSBpcyBkZWxldGVkIGZyb20gdGhlIGNvbGxlY3Rpb24uXG4gICAgY29uc3QgY2FjaGVkQ29sbGVjdGlvbiA9ICgwLCAkY0FuNWYkdXNlUmVmKShudWxsKTtcbiAgICAoMCwgJGNBbjVmJHVzZUVmZmVjdCkoKCk9PntcbiAgICAgICAgaWYgKHNlbGVjdGlvblN0YXRlLmZvY3VzZWRLZXkgIT0gbnVsbCAmJiAhY29sbGVjdGlvbi5nZXRJdGVtKHNlbGVjdGlvblN0YXRlLmZvY3VzZWRLZXkpKSB7XG4gICAgICAgICAgICBjb25zdCBub2RlID0gY2FjaGVkQ29sbGVjdGlvbi5jdXJyZW50LmdldEl0ZW0oc2VsZWN0aW9uU3RhdGUuZm9jdXNlZEtleSk7XG4gICAgICAgICAgICBjb25zdCBwYXJlbnROb2RlID0gbm9kZS5wYXJlbnRLZXkgIT0gbnVsbCAmJiAobm9kZS50eXBlID09PSBcImNlbGxcIiB8fCBub2RlLnR5cGUgPT09IFwicm93aGVhZGVyXCIgfHwgbm9kZS50eXBlID09PSBcImNvbHVtblwiKSA/IGNhY2hlZENvbGxlY3Rpb24uY3VycmVudC5nZXRJdGVtKG5vZGUucGFyZW50S2V5KSA6IG5vZGU7XG4gICAgICAgICAgICBjb25zdCBjYWNoZWRSb3dzID0gY2FjaGVkQ29sbGVjdGlvbi5jdXJyZW50LnJvd3M7XG4gICAgICAgICAgICBjb25zdCByb3dzID0gY29sbGVjdGlvbi5yb3dzO1xuICAgICAgICAgICAgY29uc3QgZGlmZiA9IGNhY2hlZFJvd3MubGVuZ3RoIC0gcm93cy5sZW5ndGg7XG4gICAgICAgICAgICBsZXQgaW5kZXggPSBNYXRoLm1pbihkaWZmID4gMSA/IE1hdGgubWF4KHBhcmVudE5vZGUuaW5kZXggLSBkaWZmICsgMSwgMCkgOiBwYXJlbnROb2RlLmluZGV4LCByb3dzLmxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgbGV0IG5ld1JvdztcbiAgICAgICAgICAgIHdoaWxlKGluZGV4ID49IDApe1xuICAgICAgICAgICAgICAgIGlmICghc2VsZWN0aW9uTWFuYWdlci5pc0Rpc2FibGVkKHJvd3NbaW5kZXhdLmtleSkgJiYgcm93c1tpbmRleF0udHlwZSAhPT0gXCJoZWFkZXJyb3dcIikge1xuICAgICAgICAgICAgICAgICAgICBuZXdSb3cgPSByb3dzW2luZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEZpbmQgbmV4dCwgbm90IGRpc2FibGVkIHJvdy5cbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPCByb3dzLmxlbmd0aCAtIDEpIGluZGV4Kys7XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCA+IHBhcmVudE5vZGUuaW5kZXgpIGluZGV4ID0gcGFyZW50Tm9kZS5pbmRleDtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXgtLTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobmV3Um93KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2hpbGROb2RlcyA9IG5ld1Jvdy5oYXNDaGlsZE5vZGVzID8gW1xuICAgICAgICAgICAgICAgICAgICAuLi4oMCwgJGNBbjVmJGdldENoaWxkTm9kZXMpKG5ld1JvdywgY29sbGVjdGlvbilcbiAgICAgICAgICAgICAgICBdIDogW107XG4gICAgICAgICAgICAgICAgY29uc3Qga2V5VG9Gb2N1cyA9IG5ld1Jvdy5oYXNDaGlsZE5vZGVzICYmIHBhcmVudE5vZGUgIT09IG5vZGUgJiYgbm9kZS5pbmRleCA8IGNoaWxkTm9kZXMubGVuZ3RoID8gY2hpbGROb2Rlc1tub2RlLmluZGV4XS5rZXkgOiBuZXdSb3cua2V5O1xuICAgICAgICAgICAgICAgIHNlbGVjdGlvblN0YXRlLnNldEZvY3VzZWRLZXkoa2V5VG9Gb2N1cyk7XG4gICAgICAgICAgICB9IGVsc2Ugc2VsZWN0aW9uU3RhdGUuc2V0Rm9jdXNlZEtleShudWxsKTtcbiAgICAgICAgfVxuICAgICAgICBjYWNoZWRDb2xsZWN0aW9uLmN1cnJlbnQgPSBjb2xsZWN0aW9uO1xuICAgIH0sIFtcbiAgICAgICAgY29sbGVjdGlvbixcbiAgICAgICAgc2VsZWN0aW9uTWFuYWdlcixcbiAgICAgICAgc2VsZWN0aW9uU3RhdGUsXG4gICAgICAgIHNlbGVjdGlvblN0YXRlLmZvY3VzZWRLZXlcbiAgICBdKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBjb2xsZWN0aW9uOiBjb2xsZWN0aW9uLFxuICAgICAgICBkaXNhYmxlZEtleXM6IGRpc2FibGVkS2V5cyxcbiAgICAgICAgaXNLZXlib2FyZE5hdmlnYXRpb25EaXNhYmxlZDogZmFsc2UsXG4gICAgICAgIHNlbGVjdGlvbk1hbmFnZXI6IHNlbGVjdGlvbk1hbmFnZXJcbiAgICB9O1xufVxuXG5cbi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyBjbGFzcyAkMTY4MDViMWIxODA5M2M1ZiRleHBvcnQkZGUzZmRmNjQ5M2MzNTNkIHtcbiAgICAqW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG4gICAgICAgIHlpZWxkKiBbXG4gICAgICAgICAgICAuLi50aGlzLnJvd3NcbiAgICAgICAgXTtcbiAgICB9XG4gICAgZ2V0IHNpemUoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAuLi50aGlzLnJvd3NcbiAgICAgICAgXS5sZW5ndGg7XG4gICAgfVxuICAgIGdldEtleXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmtleU1hcC5rZXlzKCk7XG4gICAgfVxuICAgIGdldEtleUJlZm9yZShrZXkpIHtcbiAgICAgICAgbGV0IG5vZGUgPSB0aGlzLmtleU1hcC5nZXQoa2V5KTtcbiAgICAgICAgcmV0dXJuIG5vZGUgPyBub2RlLnByZXZLZXkgOiBudWxsO1xuICAgIH1cbiAgICBnZXRLZXlBZnRlcihrZXkpIHtcbiAgICAgICAgbGV0IG5vZGUgPSB0aGlzLmtleU1hcC5nZXQoa2V5KTtcbiAgICAgICAgcmV0dXJuIG5vZGUgPyBub2RlLm5leHRLZXkgOiBudWxsO1xuICAgIH1cbiAgICBnZXRGaXJzdEtleSgpIHtcbiAgICAgICAgdmFyIF87XG4gICAgICAgIHJldHVybiAoXyA9IFtcbiAgICAgICAgICAgIC4uLnRoaXMucm93c1xuICAgICAgICBdWzBdKSA9PT0gbnVsbCB8fCBfID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfLmtleTtcbiAgICB9XG4gICAgZ2V0TGFzdEtleSgpIHtcbiAgICAgICAgdmFyIF9yb3dzXztcbiAgICAgICAgbGV0IHJvd3MgPSBbXG4gICAgICAgICAgICAuLi50aGlzLnJvd3NcbiAgICAgICAgXTtcbiAgICAgICAgcmV0dXJuIChfcm93c18gPSByb3dzW3Jvd3MubGVuZ3RoIC0gMV0pID09PSBudWxsIHx8IF9yb3dzXyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3Jvd3NfLmtleTtcbiAgICB9XG4gICAgZ2V0SXRlbShrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMua2V5TWFwLmdldChrZXkpO1xuICAgIH1cbiAgICBhdChpZHgpIHtcbiAgICAgICAgY29uc3Qga2V5cyA9IFtcbiAgICAgICAgICAgIC4uLnRoaXMuZ2V0S2V5cygpXG4gICAgICAgIF07XG4gICAgICAgIHJldHVybiB0aGlzLmdldEl0ZW0oa2V5c1tpZHhdKTtcbiAgICB9XG4gICAgZ2V0Q2hpbGRyZW4oa2V5KSB7XG4gICAgICAgIGxldCBub2RlID0gdGhpcy5rZXlNYXAuZ2V0KGtleSk7XG4gICAgICAgIHJldHVybiAobm9kZSA9PT0gbnVsbCB8fCBub2RlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBub2RlLmNoaWxkTm9kZXMpIHx8IFtdO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihvcHRzKXtcbiAgICAgICAgdGhpcy5rZXlNYXAgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMua2V5TWFwID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLmNvbHVtbkNvdW50ID0gb3B0cyA9PT0gbnVsbCB8fCBvcHRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRzLmNvbHVtbkNvdW50O1xuICAgICAgICB0aGlzLnJvd3MgPSBbXTtcbiAgICAgICAgbGV0IHZpc2l0ID0gKG5vZGUpPT57XG4gICAgICAgICAgICAvLyBJZiB0aGUgbm9kZSBpcyB0aGUgc2FtZSBvYmplY3QgYXMgdGhlIHByZXZpb3VzIG5vZGUgZm9yIHRoZSBzYW1lIGtleSxcbiAgICAgICAgICAgIC8vIHdlIGNhbiBza2lwIHRoaXMgbm9kZSBhbmQgaXRzIGNoaWxkcmVuLiBXZSBhbHdheXMgdmlzaXQgY29sdW1ucyB0aG91Z2gsXG4gICAgICAgICAgICAvLyBiZWNhdXNlIHdlIGRlcGVuZCBvbiBvcmRlciB0byBidWlsZCB0aGUgY29sdW1ucyBhcnJheS5cbiAgICAgICAgICAgIGxldCBwcmV2Tm9kZSA9IHRoaXMua2V5TWFwLmdldChub2RlLmtleSk7XG4gICAgICAgICAgICBpZiAob3B0cy52aXNpdE5vZGUpIG5vZGUgPSBvcHRzLnZpc2l0Tm9kZShub2RlKTtcbiAgICAgICAgICAgIHRoaXMua2V5TWFwLnNldChub2RlLmtleSwgbm9kZSk7XG4gICAgICAgICAgICBsZXQgY2hpbGRLZXlzID0gbmV3IFNldCgpO1xuICAgICAgICAgICAgbGV0IGxhc3Q7XG4gICAgICAgICAgICBmb3IgKGxldCBjaGlsZCBvZiBub2RlLmNoaWxkTm9kZXMpe1xuICAgICAgICAgICAgICAgIGlmIChjaGlsZC50eXBlID09PSBcImNlbGxcIiAmJiBjaGlsZC5wYXJlbnRLZXkgPT0gbnVsbCkgLy8gaWYgY2hpbGQgaXMgYSBjZWxsIHBhcmVudCBrZXkgaXNuJ3QgYWxyZWFkeSBlc3RhYmxpc2hlZCBieSB0aGUgY29sbGVjdGlvbiwgbWF0Y2ggY2hpbGQgbm9kZSB0byBwYXJlbnQgcm93XG4gICAgICAgICAgICAgICAgY2hpbGQucGFyZW50S2V5ID0gbm9kZS5rZXk7XG4gICAgICAgICAgICAgICAgY2hpbGRLZXlzLmFkZChjaGlsZC5rZXkpO1xuICAgICAgICAgICAgICAgIGlmIChsYXN0KSB7XG4gICAgICAgICAgICAgICAgICAgIGxhc3QubmV4dEtleSA9IGNoaWxkLmtleTtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGQucHJldktleSA9IGxhc3Qua2V5O1xuICAgICAgICAgICAgICAgIH0gZWxzZSBjaGlsZC5wcmV2S2V5ID0gbnVsbDtcbiAgICAgICAgICAgICAgICB2aXNpdChjaGlsZCk7XG4gICAgICAgICAgICAgICAgbGFzdCA9IGNoaWxkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxhc3QpIGxhc3QubmV4dEtleSA9IG51bGw7XG4gICAgICAgICAgICAvLyBSZW1vdmUgZGVsZXRlZCBub2RlcyBhbmQgdGhlaXIgY2hpbGRyZW4gZnJvbSB0aGUga2V5IG1hcFxuICAgICAgICAgICAgaWYgKHByZXZOb2RlKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgY2hpbGQgb2YgcHJldk5vZGUuY2hpbGROb2RlcylpZiAoIWNoaWxkS2V5cy5oYXMoY2hpbGQua2V5KSkgcmVtb3ZlKGNoaWxkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgbGV0IHJlbW92ZSA9IChub2RlKT0+e1xuICAgICAgICAgICAgdGhpcy5rZXlNYXAuZGVsZXRlKG5vZGUua2V5KTtcbiAgICAgICAgICAgIGZvciAobGV0IGNoaWxkIG9mIG5vZGUuY2hpbGROb2RlcylpZiAodGhpcy5rZXlNYXAuZ2V0KGNoaWxkLmtleSkgPT09IGNoaWxkKSByZW1vdmUoY2hpbGQpO1xuICAgICAgICB9O1xuICAgICAgICBsZXQgbGFzdDtcbiAgICAgICAgb3B0cy5pdGVtcy5mb3JFYWNoKChub2RlLCBpKT0+e1xuICAgICAgICAgICAgbGV0IHJvd05vZGUgPSB7XG4gICAgICAgICAgICAgICAgbGV2ZWw6IDAsXG4gICAgICAgICAgICAgICAga2V5OiBcInJvdy1cIiArIGksXG4gICAgICAgICAgICAgICAgdHlwZTogXCJyb3dcIixcbiAgICAgICAgICAgICAgICB2YWx1ZTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIGhhc0NoaWxkTm9kZXM6IHRydWUsXG4gICAgICAgICAgICAgICAgY2hpbGROb2RlczogW1xuICAgICAgICAgICAgICAgICAgICAuLi5ub2RlLmNoaWxkTm9kZXNcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIHJlbmRlcmVkOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgdGV4dFZhbHVlOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgLi4ubm9kZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChsYXN0KSB7XG4gICAgICAgICAgICAgICAgbGFzdC5uZXh0S2V5ID0gcm93Tm9kZS5rZXk7XG4gICAgICAgICAgICAgICAgcm93Tm9kZS5wcmV2S2V5ID0gbGFzdC5rZXk7XG4gICAgICAgICAgICB9IGVsc2Ugcm93Tm9kZS5wcmV2S2V5ID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMucm93cy5wdXNoKHJvd05vZGUpO1xuICAgICAgICAgICAgdmlzaXQocm93Tm9kZSk7XG4gICAgICAgICAgICBsYXN0ID0gcm93Tm9kZTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChsYXN0KSBsYXN0Lm5leHRLZXkgPSBudWxsO1xuICAgIH1cbn1cblxuXG5cblxuZXhwb3J0IHskNjI5NjdkMTI2ZjNhYTgyMyRleHBvcnQkNDAwN2FjMDlmZjljNjhlZCBhcyB1c2VHcmlkU3RhdGUsICQxNjgwNWIxYjE4MDkzYzVmJGV4cG9ydCRkZTNmZGY2NDkzYzM1M2QgYXMgR3JpZENvbGxlY3Rpb259O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bW9kdWxlLmpzLm1hcFxuIl0sIm5hbWVzIjpbImdldENoaWxkTm9kZXMiLCIkY0FuNWYkZ2V0Q2hpbGROb2RlcyIsImdldExhc3RJdGVtIiwiJGNBbjVmJGdldExhc3RJdGVtIiwiZ2V0Rmlyc3RJdGVtIiwiJGNBbjVmJGdldEZpcnN0SXRlbSIsInVzZU11bHRpcGxlU2VsZWN0aW9uU3RhdGUiLCIkY0FuNWYkdXNlTXVsdGlwbGVTZWxlY3Rpb25TdGF0ZSIsIlNlbGVjdGlvbk1hbmFnZXIiLCIkY0FuNWYkU2VsZWN0aW9uTWFuYWdlciIsInVzZU1lbW8iLCIkY0FuNWYkdXNlTWVtbyIsInVzZVJlZiIsIiRjQW41ZiR1c2VSZWYiLCJ1c2VFZmZlY3QiLCIkY0FuNWYkdXNlRWZmZWN0IiwiJDYyOTY3ZDEyNmYzYWE4MjMkZXhwb3J0JDQwMDdhYzA5ZmY5YzY4ZWQiLCJwcm9wcyIsImNvbGxlY3Rpb24iLCJmb2N1c01vZGUiLCJzZWxlY3Rpb25TdGF0ZSIsImRpc2FibGVkS2V5cyIsIlNldCIsInNldEZvY3VzZWRLZXkiLCJrZXkiLCJjaGlsZCIsIml0ZW0iLCJnZXRJdGVtIiwidHlwZSIsIl9nZXRMYXN0SXRlbSIsIl9nZXRGaXJzdEl0ZW0iLCJjaGlsZHJlbiIsInNlbGVjdGlvbk1hbmFnZXIiLCJjYWNoZWRDb2xsZWN0aW9uIiwiZm9jdXNlZEtleSIsIm5vZGUiLCJjdXJyZW50IiwicGFyZW50Tm9kZSIsInBhcmVudEtleSIsImNhY2hlZFJvd3MiLCJyb3dzIiwiZGlmZiIsImxlbmd0aCIsImluZGV4IiwiTWF0aCIsIm1pbiIsIm1heCIsIm5ld1JvdyIsImlzRGlzYWJsZWQiLCJjaGlsZE5vZGVzIiwiaGFzQ2hpbGROb2RlcyIsImtleVRvRm9jdXMiLCJpc0tleWJvYXJkTmF2aWdhdGlvbkRpc2FibGVkIiwiJDE2ODA1YjFiMTgwOTNjNWYkZXhwb3J0JGRlM2ZkZjY0OTNjMzUzZCIsIlN5bWJvbCIsIml0ZXJhdG9yIiwic2l6ZSIsImdldEtleXMiLCJrZXlNYXAiLCJrZXlzIiwiZ2V0S2V5QmVmb3JlIiwiZ2V0IiwicHJldktleSIsImdldEtleUFmdGVyIiwibmV4dEtleSIsImdldEZpcnN0S2V5IiwiXyIsImdldExhc3RLZXkiLCJfcm93c18iLCJhdCIsImlkeCIsImdldENoaWxkcmVuIiwiY29uc3RydWN0b3IiLCJvcHRzIiwiTWFwIiwiY29sdW1uQ291bnQiLCJ2aXNpdCIsInByZXZOb2RlIiwidmlzaXROb2RlIiwic2V0IiwiY2hpbGRLZXlzIiwibGFzdCIsImFkZCIsImhhcyIsInJlbW92ZSIsImRlbGV0ZSIsIml0ZW1zIiwiZm9yRWFjaCIsImkiLCJyb3dOb2RlIiwibGV2ZWwiLCJ2YWx1ZSIsInVuZGVmaW5lZCIsInJlbmRlcmVkIiwidGV4dFZhbHVlIiwicHVzaCIsInVzZUdyaWRTdGF0ZSIsIkdyaWRDb2xsZWN0aW9uIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-stately/grid/dist/import.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-stately/list/dist/import.mjs":
/*!**********************************************************!*\
  !*** ./node_modules/@react-stately/list/dist/import.mjs ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ListCollection: () => (/* binding */ $a02d57049d202695$export$d085fb9e920b5ca7),\n/* harmony export */   useListState: () => (/* binding */ $e72dd72e1c76a225$export$2f645645f7bca764),\n/* harmony export */   useSingleSelectListState: () => (/* binding */ $a0d645289fe9b86b$export$e7f05e985daf4b5f)\n/* harmony export */ });\n/* harmony import */ var _react_stately_selection__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @react-stately/selection */ \"(ssr)/./node_modules/@react-stately/selection/dist/import.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _react_stately_collections__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @react-stately/collections */ \"(ssr)/./node_modules/@react-stately/collections/dist/import.mjs\");\n/* harmony import */ var _react_stately_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @react-stately/utils */ \"(ssr)/./node_modules/@react-stately/utils/dist/import.mjs\");\n\n\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ class $a02d57049d202695$export$d085fb9e920b5ca7 {\n    *[Symbol.iterator]() {\n        yield* this.iterable;\n    }\n    get size() {\n        return this.keyMap.size;\n    }\n    getKeys() {\n        return this.keyMap.keys();\n    }\n    getKeyBefore(key) {\n        let node = this.keyMap.get(key);\n        return node ? node.prevKey : null;\n    }\n    getKeyAfter(key) {\n        let node = this.keyMap.get(key);\n        return node ? node.nextKey : null;\n    }\n    getFirstKey() {\n        return this.firstKey;\n    }\n    getLastKey() {\n        return this.lastKey;\n    }\n    getItem(key) {\n        return this.keyMap.get(key);\n    }\n    at(idx) {\n        const keys = [\n            ...this.getKeys()\n        ];\n        return this.getItem(keys[idx]);\n    }\n    getChildren(key) {\n        let node = this.keyMap.get(key);\n        return (node === null || node === void 0 ? void 0 : node.childNodes) || [];\n    }\n    constructor(nodes){\n        this.keyMap = new Map();\n        this.iterable = nodes;\n        let visit = (node)=>{\n            this.keyMap.set(node.key, node);\n            if (node.childNodes && node.type === \"section\") for (let child of node.childNodes)visit(child);\n        };\n        for (let node of nodes)visit(node);\n        let last;\n        let index = 0;\n        for (let [key, node] of this.keyMap){\n            if (last) {\n                last.nextKey = key;\n                node.prevKey = last.key;\n            } else {\n                this.firstKey = key;\n                node.prevKey = undefined;\n            }\n            if (node.type === \"item\") node.index = index++;\n            last = node;\n            // Set nextKey as undefined since this might be the last node\n            // If it isn't the last node, last.nextKey will properly set at start of new loop\n            last.nextKey = undefined;\n        }\n        this.lastKey = last === null || last === void 0 ? void 0 : last.key;\n    }\n}\nfunction $e72dd72e1c76a225$export$2f645645f7bca764(props) {\n    let { filter: filter } = props;\n    let selectionState = (0, _react_stately_selection__WEBPACK_IMPORTED_MODULE_1__.useMultipleSelectionState)(props);\n    let disabledKeys = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>props.disabledKeys ? new Set(props.disabledKeys) : new Set(), [\n        props.disabledKeys\n    ]);\n    let factory = (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((nodes)=>filter ? new (0, $a02d57049d202695$export$d085fb9e920b5ca7)(filter(nodes)) : new (0, $a02d57049d202695$export$d085fb9e920b5ca7)(nodes), [\n        filter\n    ]);\n    let context = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>({\n            suppressTextValueWarning: props.suppressTextValueWarning\n        }), [\n        props.suppressTextValueWarning\n    ]);\n    let collection = (0, _react_stately_collections__WEBPACK_IMPORTED_MODULE_2__.useCollection)(props, factory, context);\n    let selectionManager = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>new (0, _react_stately_selection__WEBPACK_IMPORTED_MODULE_1__.SelectionManager)(collection, selectionState), [\n        collection,\n        selectionState\n    ]);\n    // Reset focused key if that item is deleted from the collection.\n    const cachedCollection = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    (0, react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (selectionState.focusedKey != null && !collection.getItem(selectionState.focusedKey)) {\n            const startItem = cachedCollection.current.getItem(selectionState.focusedKey);\n            const cachedItemNodes = [\n                ...cachedCollection.current.getKeys()\n            ].map((key)=>{\n                const itemNode = cachedCollection.current.getItem(key);\n                return itemNode.type === \"item\" ? itemNode : null;\n            }).filter((node)=>node !== null);\n            const itemNodes = [\n                ...collection.getKeys()\n            ].map((key)=>{\n                const itemNode = collection.getItem(key);\n                return itemNode.type === \"item\" ? itemNode : null;\n            }).filter((node)=>node !== null);\n            const diff = cachedItemNodes.length - itemNodes.length;\n            let index = Math.min(diff > 1 ? Math.max(startItem.index - diff + 1, 0) : startItem.index, itemNodes.length - 1);\n            let newNode;\n            while(index >= 0){\n                if (!selectionManager.isDisabled(itemNodes[index].key)) {\n                    newNode = itemNodes[index];\n                    break;\n                }\n                // Find next, not disabled item.\n                if (index < itemNodes.length - 1) index++;\n                else {\n                    if (index > startItem.index) index = startItem.index;\n                    index--;\n                }\n            }\n            selectionState.setFocusedKey(newNode ? newNode.key : null);\n        }\n        cachedCollection.current = collection;\n    }, [\n        collection,\n        selectionManager,\n        selectionState,\n        selectionState.focusedKey\n    ]);\n    return {\n        collection: collection,\n        disabledKeys: disabledKeys,\n        selectionManager: selectionManager\n    };\n}\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ function $a0d645289fe9b86b$export$e7f05e985daf4b5f(props) {\n    var _props_defaultSelectedKey;\n    let [selectedKey, setSelectedKey] = (0, _react_stately_utils__WEBPACK_IMPORTED_MODULE_3__.useControlledState)(props.selectedKey, (_props_defaultSelectedKey = props.defaultSelectedKey) !== null && _props_defaultSelectedKey !== void 0 ? _props_defaultSelectedKey : null, props.onSelectionChange);\n    let selectedKeys = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>selectedKey != null ? [\n            selectedKey\n        ] : [], [\n        selectedKey\n    ]);\n    let { collection: collection, disabledKeys: disabledKeys, selectionManager: selectionManager } = (0, $e72dd72e1c76a225$export$2f645645f7bca764)({\n        ...props,\n        selectionMode: \"single\",\n        disallowEmptySelection: true,\n        allowDuplicateSelectionEvents: true,\n        selectedKeys: selectedKeys,\n        onSelectionChange: (keys)=>{\n            var _keys_values_next_value;\n            let key = (_keys_values_next_value = keys.values().next().value) !== null && _keys_values_next_value !== void 0 ? _keys_values_next_value : null;\n            // Always fire onSelectionChange, even if the key is the same\n            // as the current key (useControlledState does not).\n            if (key === selectedKey && props.onSelectionChange) props.onSelectionChange(key);\n            setSelectedKey(key);\n        }\n    });\n    let selectedItem = selectedKey != null ? collection.getItem(selectedKey) : null;\n    return {\n        collection: collection,\n        disabledKeys: disabledKeys,\n        selectionManager: selectionManager,\n        selectedKey: selectedKey,\n        setSelectedKey: setSelectedKey,\n        selectedItem: selectedItem\n    };\n}\n //# sourceMappingURL=module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXN0YXRlbHkvbGlzdC9kaXN0L2ltcG9ydC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFvSjtBQUNUO0FBQzFEO0FBQ0k7QUFFckY7Ozs7Ozs7Ozs7Q0FVQyxHQUFHOzs7Ozs7Ozs7O0NBVUgsR0FBRzs7Ozs7Ozs7OztDQVVILEdBQUcsTUFBTWdCO0lBQ04sQ0FBQyxDQUFDQyxPQUFPQyxRQUFRLENBQUMsR0FBRztRQUNqQixPQUFPLElBQUksQ0FBQ0MsUUFBUTtJQUN4QjtJQUNBLElBQUlDLE9BQU87UUFDUCxPQUFPLElBQUksQ0FBQ0MsTUFBTSxDQUFDRCxJQUFJO0lBQzNCO0lBQ0FFLFVBQVU7UUFDTixPQUFPLElBQUksQ0FBQ0QsTUFBTSxDQUFDRSxJQUFJO0lBQzNCO0lBQ0FDLGFBQWFDLEdBQUcsRUFBRTtRQUNkLElBQUlDLE9BQU8sSUFBSSxDQUFDTCxNQUFNLENBQUNNLEdBQUcsQ0FBQ0Y7UUFDM0IsT0FBT0MsT0FBT0EsS0FBS0UsT0FBTyxHQUFHO0lBQ2pDO0lBQ0FDLFlBQVlKLEdBQUcsRUFBRTtRQUNiLElBQUlDLE9BQU8sSUFBSSxDQUFDTCxNQUFNLENBQUNNLEdBQUcsQ0FBQ0Y7UUFDM0IsT0FBT0MsT0FBT0EsS0FBS0ksT0FBTyxHQUFHO0lBQ2pDO0lBQ0FDLGNBQWM7UUFDVixPQUFPLElBQUksQ0FBQ0MsUUFBUTtJQUN4QjtJQUNBQyxhQUFhO1FBQ1QsT0FBTyxJQUFJLENBQUNDLE9BQU87SUFDdkI7SUFDQUMsUUFBUVYsR0FBRyxFQUFFO1FBQ1QsT0FBTyxJQUFJLENBQUNKLE1BQU0sQ0FBQ00sR0FBRyxDQUFDRjtJQUMzQjtJQUNBVyxHQUFHQyxHQUFHLEVBQUU7UUFDSixNQUFNZCxPQUFPO2VBQ04sSUFBSSxDQUFDRCxPQUFPO1NBQ2xCO1FBQ0QsT0FBTyxJQUFJLENBQUNhLE9BQU8sQ0FBQ1osSUFBSSxDQUFDYyxJQUFJO0lBQ2pDO0lBQ0FDLFlBQVliLEdBQUcsRUFBRTtRQUNi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QUFZQTtRQUNaTCxjQUFjQTtRQUNkTSxrQkFBa0JBO1FBQ2xCbUIsYUFBYUE7UUFDYkMsZ0JBQWdCQTtRQUNoQlcsY0FBY0E7SUFDbEI7QUFDSjtBQU11TSxDQUN2TSxrQ0FBa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LWZsYXNrLy4vbm9kZV9tb2R1bGVzL0ByZWFjdC1zdGF0ZWx5L2xpc3QvZGlzdC9pbXBvcnQubWpzPzUwMTMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHt1c2VNdWx0aXBsZVNlbGVjdGlvblN0YXRlIGFzICQ1OFBocyR1c2VNdWx0aXBsZVNlbGVjdGlvblN0YXRlLCBTZWxlY3Rpb25NYW5hZ2VyIGFzICQ1OFBocyRTZWxlY3Rpb25NYW5hZ2VyfSBmcm9tIFwiQHJlYWN0LXN0YXRlbHkvc2VsZWN0aW9uXCI7XG5pbXBvcnQge3VzZU1lbW8gYXMgJDU4UGhzJHVzZU1lbW8sIHVzZUNhbGxiYWNrIGFzICQ1OFBocyR1c2VDYWxsYmFjaywgdXNlUmVmIGFzICQ1OFBocyR1c2VSZWYsIHVzZUVmZmVjdCBhcyAkNThQaHMkdXNlRWZmZWN0fSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7dXNlQ29sbGVjdGlvbiBhcyAkNThQaHMkdXNlQ29sbGVjdGlvbn0gZnJvbSBcIkByZWFjdC1zdGF0ZWx5L2NvbGxlY3Rpb25zXCI7XG5pbXBvcnQge3VzZUNvbnRyb2xsZWRTdGF0ZSBhcyAkNThQaHMkdXNlQ29udHJvbGxlZFN0YXRlfSBmcm9tIFwiQHJlYWN0LXN0YXRlbHkvdXRpbHNcIjtcblxuLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIC8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyAvKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gY2xhc3MgJGEwMmQ1NzA0OWQyMDI2OTUkZXhwb3J0JGQwODVmYjllOTIwYjVjYTcge1xuICAgICpbU3ltYm9sLml0ZXJhdG9yXSgpIHtcbiAgICAgICAgeWllbGQqIHRoaXMuaXRlcmFibGU7XG4gICAgfVxuICAgIGdldCBzaXplKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5rZXlNYXAuc2l6ZTtcbiAgICB9XG4gICAgZ2V0S2V5cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMua2V5TWFwLmtleXMoKTtcbiAgICB9XG4gICAgZ2V0S2V5QmVmb3JlKGtleSkge1xuICAgICAgICBsZXQgbm9kZSA9IHRoaXMua2V5TWFwLmdldChrZXkpO1xuICAgICAgICByZXR1cm4gbm9kZSA/IG5vZGUucHJldktleSA6IG51bGw7XG4gICAgfVxuICAgIGdldEtleUFmdGVyKGtleSkge1xuICAgICAgICBsZXQgbm9kZSA9IHRoaXMua2V5TWFwLmdldChrZXkpO1xuICAgICAgICByZXR1cm4gbm9kZSA/IG5vZGUubmV4dEtleSA6IG51bGw7XG4gICAgfVxuICAgIGdldEZpcnN0S2V5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5maXJzdEtleTtcbiAgICB9XG4gICAgZ2V0TGFzdEtleSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGFzdEtleTtcbiAgICB9XG4gICAgZ2V0SXRlbShrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMua2V5TWFwLmdldChrZXkpO1xuICAgIH1cbiAgICBhdChpZHgpIHtcbiAgICAgICAgY29uc3Qga2V5cyA9IFtcbiAgICAgICAgICAgIC4uLnRoaXMuZ2V0S2V5cygpXG4gICAgICAgIF07XG4gICAgICAgIHJldHVybiB0aGlzLmdldEl0ZW0oa2V5c1tpZHhdKTtcbiAgICB9XG4gICAgZ2V0Q2hpbGRyZW4oa2V5KSB7XG4gICAgICAgIGxldCBub2RlID0gdGhpcy5rZXlNYXAuZ2V0KGtleSk7XG4gICAgICAgIHJldHVybiAobm9kZSA9PT0gbnVsbCB8fCBub2RlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBub2RlLmNoaWxkTm9kZXMpIHx8IFtdO1xuICAgIH1cbiAgICBjb25zdHJ1Y3Rvcihub2Rlcyl7XG4gICAgICAgIHRoaXMua2V5TWFwID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLml0ZXJhYmxlID0gbm9kZXM7XG4gICAgICAgIGxldCB2aXNpdCA9IChub2RlKT0+e1xuICAgICAgICAgICAgdGhpcy5rZXlNYXAuc2V0KG5vZGUua2V5LCBub2RlKTtcbiAgICAgICAgICAgIGlmIChub2RlLmNoaWxkTm9kZXMgJiYgbm9kZS50eXBlID09PSBcInNlY3Rpb25cIikgZm9yIChsZXQgY2hpbGQgb2Ygbm9kZS5jaGlsZE5vZGVzKXZpc2l0KGNoaWxkKTtcbiAgICAgICAgfTtcbiAgICAgICAgZm9yIChsZXQgbm9kZSBvZiBub2Rlcyl2aXNpdChub2RlKTtcbiAgICAgICAgbGV0IGxhc3Q7XG4gICAgICAgIGxldCBpbmRleCA9IDA7XG4gICAgICAgIGZvciAobGV0IFtrZXksIG5vZGVdIG9mIHRoaXMua2V5TWFwKXtcbiAgICAgICAgICAgIGlmIChsYXN0KSB7XG4gICAgICAgICAgICAgICAgbGFzdC5uZXh0S2V5ID0ga2V5O1xuICAgICAgICAgICAgICAgIG5vZGUucHJldktleSA9IGxhc3Qua2V5O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZpcnN0S2V5ID0ga2V5O1xuICAgICAgICAgICAgICAgIG5vZGUucHJldktleSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChub2RlLnR5cGUgPT09IFwiaXRlbVwiKSBub2RlLmluZGV4ID0gaW5kZXgrKztcbiAgICAgICAgICAgIGxhc3QgPSBub2RlO1xuICAgICAgICAgICAgLy8gU2V0IG5leHRLZXkgYXMgdW5kZWZpbmVkIHNpbmNlIHRoaXMgbWlnaHQgYmUgdGhlIGxhc3Qgbm9kZVxuICAgICAgICAgICAgLy8gSWYgaXQgaXNuJ3QgdGhlIGxhc3Qgbm9kZSwgbGFzdC5uZXh0S2V5IHdpbGwgcHJvcGVybHkgc2V0IGF0IHN0YXJ0IG9mIG5ldyBsb29wXG4gICAgICAgICAgICBsYXN0Lm5leHRLZXkgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sYXN0S2V5ID0gbGFzdCA9PT0gbnVsbCB8fCBsYXN0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBsYXN0LmtleTtcbiAgICB9XG59XG5cblxuXG5cblxuZnVuY3Rpb24gJGU3MmRkNzJlMWM3NmEyMjUkZXhwb3J0JDJmNjQ1NjQ1ZjdiY2E3NjQocHJvcHMpIHtcbiAgICBsZXQgeyBmaWx0ZXI6IGZpbHRlciB9ID0gcHJvcHM7XG4gICAgbGV0IHNlbGVjdGlvblN0YXRlID0gKDAsICQ1OFBocyR1c2VNdWx0aXBsZVNlbGVjdGlvblN0YXRlKShwcm9wcyk7XG4gICAgbGV0IGRpc2FibGVkS2V5cyA9ICgwLCAkNThQaHMkdXNlTWVtbykoKCk9PnByb3BzLmRpc2FibGVkS2V5cyA/IG5ldyBTZXQocHJvcHMuZGlzYWJsZWRLZXlzKSA6IG5ldyBTZXQoKSwgW1xuICAgICAgICBwcm9wcy5kaXNhYmxlZEtleXNcbiAgICBdKTtcbiAgICBsZXQgZmFjdG9yeSA9ICgwLCAkNThQaHMkdXNlQ2FsbGJhY2spKChub2Rlcyk9PmZpbHRlciA/IG5ldyAoMCwgJGEwMmQ1NzA0OWQyMDI2OTUkZXhwb3J0JGQwODVmYjllOTIwYjVjYTcpKGZpbHRlcihub2RlcykpIDogbmV3ICgwLCAkYTAyZDU3MDQ5ZDIwMjY5NSRleHBvcnQkZDA4NWZiOWU5MjBiNWNhNykobm9kZXMpLCBbXG4gICAgICAgIGZpbHRlclxuICAgIF0pO1xuICAgIGxldCBjb250ZXh0ID0gKDAsICQ1OFBocyR1c2VNZW1vKSgoKT0+KHtcbiAgICAgICAgICAgIHN1cHByZXNzVGV4dFZhbHVlV2FybmluZzogcHJvcHMuc3VwcHJlc3NUZXh0VmFsdWVXYXJuaW5nXG4gICAgICAgIH0pLCBbXG4gICAgICAgIHByb3BzLnN1cHByZXNzVGV4dFZhbHVlV2FybmluZ1xuICAgIF0pO1xuICAgIGxldCBjb2xsZWN0aW9uID0gKDAsICQ1OFBocyR1c2VDb2xsZWN0aW9uKShwcm9wcywgZmFjdG9yeSwgY29udGV4dCk7XG4gICAgbGV0IHNlbGVjdGlvbk1hbmFnZXIgPSAoMCwgJDU4UGhzJHVzZU1lbW8pKCgpPT5uZXcgKDAsICQ1OFBocyRTZWxlY3Rpb25NYW5hZ2VyKShjb2xsZWN0aW9uLCBzZWxlY3Rpb25TdGF0ZSksIFtcbiAgICAgICAgY29sbGVjdGlvbixcbiAgICAgICAgc2VsZWN0aW9uU3RhdGVcbiAgICBdKTtcbiAgICAvLyBSZXNldCBmb2N1c2VkIGtleSBpZiB0aGF0IGl0ZW0gaXMgZGVsZXRlZCBmcm9tIHRoZSBjb2xsZWN0aW9uLlxuICAgIGNvbnN0IGNhY2hlZENvbGxlY3Rpb24gPSAoMCwgJDU4UGhzJHVzZVJlZikobnVsbCk7XG4gICAgKDAsICQ1OFBocyR1c2VFZmZlY3QpKCgpPT57XG4gICAgICAgIGlmIChzZWxlY3Rpb25TdGF0ZS5mb2N1c2VkS2V5ICE9IG51bGwgJiYgIWNvbGxlY3Rpb24uZ2V0SXRlbShzZWxlY3Rpb25TdGF0ZS5mb2N1c2VkS2V5KSkge1xuICAgICAgICAgICAgY29uc3Qgc3RhcnRJdGVtID0gY2FjaGVkQ29sbGVjdGlvbi5jdXJyZW50LmdldEl0ZW0oc2VsZWN0aW9uU3RhdGUuZm9jdXNlZEtleSk7XG4gICAgICAgICAgICBjb25zdCBjYWNoZWRJdGVtTm9kZXMgPSBbXG4gICAgICAgICAgICAgICAgLi4uY2FjaGVkQ29sbGVjdGlvbi5jdXJyZW50LmdldEtleXMoKVxuICAgICAgICAgICAgXS5tYXAoKGtleSk9PntcbiAgICAgICAgICAgICAgICBjb25zdCBpdGVtTm9kZSA9IGNhY2hlZENvbGxlY3Rpb24uY3VycmVudC5nZXRJdGVtKGtleSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW1Ob2RlLnR5cGUgPT09IFwiaXRlbVwiID8gaXRlbU5vZGUgOiBudWxsO1xuICAgICAgICAgICAgfSkuZmlsdGVyKChub2RlKT0+bm9kZSAhPT0gbnVsbCk7XG4gICAgICAgICAgICBjb25zdCBpdGVtTm9kZXMgPSBbXG4gICAgICAgICAgICAgICAgLi4uY29sbGVjdGlvbi5nZXRLZXlzKClcbiAgICAgICAgICAgIF0ubWFwKChrZXkpPT57XG4gICAgICAgICAgICAgICAgY29uc3QgaXRlbU5vZGUgPSBjb2xsZWN0aW9uLmdldEl0ZW0oa2V5KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbU5vZGUudHlwZSA9PT0gXCJpdGVtXCIgPyBpdGVtTm9kZSA6IG51bGw7XG4gICAgICAgICAgICB9KS5maWx0ZXIoKG5vZGUpPT5ub2RlICE9PSBudWxsKTtcbiAgICAgICAgICAgIGNvbnN0IGRpZmYgPSBjYWNoZWRJdGVtTm9kZXMubGVuZ3RoIC0gaXRlbU5vZGVzLmxlbmd0aDtcbiAgICAgICAgICAgIGxldCBpbmRleCA9IE1hdGgubWluKGRpZmYgPiAxID8gTWF0aC5tYXgoc3RhcnRJdGVtLmluZGV4IC0gZGlmZiArIDEsIDApIDogc3RhcnRJdGVtLmluZGV4LCBpdGVtTm9kZXMubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICBsZXQgbmV3Tm9kZTtcbiAgICAgICAgICAgIHdoaWxlKGluZGV4ID49IDApe1xuICAgICAgICAgICAgICAgIGlmICghc2VsZWN0aW9uTWFuYWdlci5pc0Rpc2FibGVkKGl0ZW1Ob2Rlc1tpbmRleF0ua2V5KSkge1xuICAgICAgICAgICAgICAgICAgICBuZXdOb2RlID0gaXRlbU5vZGVzW2luZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEZpbmQgbmV4dCwgbm90IGRpc2FibGVkIGl0ZW0uXG4gICAgICAgICAgICAgICAgaWYgKGluZGV4IDwgaXRlbU5vZGVzLmxlbmd0aCAtIDEpIGluZGV4Kys7XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCA+IHN0YXJ0SXRlbS5pbmRleCkgaW5kZXggPSBzdGFydEl0ZW0uaW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4LS07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2VsZWN0aW9uU3RhdGUuc2V0Rm9jdXNlZEtleShuZXdOb2RlID8gbmV3Tm9kZS5rZXkgOiBudWxsKTtcbiAgICAgICAgfVxuICAgICAgICBjYWNoZWRDb2xsZWN0aW9uLmN1cnJlbnQgPSBjb2xsZWN0aW9uO1xuICAgIH0sIFtcbiAgICAgICAgY29sbGVjdGlvbixcbiAgICAgICAgc2VsZWN0aW9uTWFuYWdlcixcbiAgICAgICAgc2VsZWN0aW9uU3RhdGUsXG4gICAgICAgIHNlbGVjdGlvblN0YXRlLmZvY3VzZWRLZXlcbiAgICBdKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBjb2xsZWN0aW9uOiBjb2xsZWN0aW9uLFxuICAgICAgICBkaXNhYmxlZEtleXM6IGRpc2FibGVkS2V5cyxcbiAgICAgICAgc2VsZWN0aW9uTWFuYWdlcjogc2VsZWN0aW9uTWFuYWdlclxuICAgIH07XG59XG5cblxuLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIFxuXG5cbmZ1bmN0aW9uICRhMGQ2NDUyODlmZTliODZiJGV4cG9ydCRlN2YwNWU5ODVkYWY0YjVmKHByb3BzKSB7XG4gICAgdmFyIF9wcm9wc19kZWZhdWx0U2VsZWN0ZWRLZXk7XG4gICAgbGV0IFtzZWxlY3RlZEtleSwgc2V0U2VsZWN0ZWRLZXldID0gKDAsICQ1OFBocyR1c2VDb250cm9sbGVkU3RhdGUpKHByb3BzLnNlbGVjdGVkS2V5LCAoX3Byb3BzX2RlZmF1bHRTZWxlY3RlZEtleSA9IHByb3BzLmRlZmF1bHRTZWxlY3RlZEtleSkgIT09IG51bGwgJiYgX3Byb3BzX2RlZmF1bHRTZWxlY3RlZEtleSAhPT0gdm9pZCAwID8gX3Byb3BzX2RlZmF1bHRTZWxlY3RlZEtleSA6IG51bGwsIHByb3BzLm9uU2VsZWN0aW9uQ2hhbmdlKTtcbiAgICBsZXQgc2VsZWN0ZWRLZXlzID0gKDAsICQ1OFBocyR1c2VNZW1vKSgoKT0+c2VsZWN0ZWRLZXkgIT0gbnVsbCA/IFtcbiAgICAgICAgICAgIHNlbGVjdGVkS2V5XG4gICAgICAgIF0gOiBbXSwgW1xuICAgICAgICBzZWxlY3RlZEtleVxuICAgIF0pO1xuICAgIGxldCB7IGNvbGxlY3Rpb246IGNvbGxlY3Rpb24sIGRpc2FibGVkS2V5czogZGlzYWJsZWRLZXlzLCBzZWxlY3Rpb25NYW5hZ2VyOiBzZWxlY3Rpb25NYW5hZ2VyIH0gPSAoMCwgJGU3MmRkNzJlMWM3NmEyMjUkZXhwb3J0JDJmNjQ1NjQ1ZjdiY2E3NjQpKHtcbiAgICAgICAgLi4ucHJvcHMsXG4gICAgICAgIHNlbGVjdGlvbk1vZGU6IFwic2luZ2xlXCIsXG4gICAgICAgIGRpc2FsbG93RW1wdHlTZWxlY3Rpb246IHRydWUsXG4gICAgICAgIGFsbG93RHVwbGljYXRlU2VsZWN0aW9uRXZlbnRzOiB0cnVlLFxuICAgICAgICBzZWxlY3RlZEtleXM6IHNlbGVjdGVkS2V5cyxcbiAgICAgICAgb25TZWxlY3Rpb25DaGFuZ2U6IChrZXlzKT0+e1xuICAgICAgICAgICAgdmFyIF9rZXlzX3ZhbHVlc19uZXh0X3ZhbHVlO1xuICAgICAgICAgICAgbGV0IGtleSA9IChfa2V5c192YWx1ZXNfbmV4dF92YWx1ZSA9IGtleXMudmFsdWVzKCkubmV4dCgpLnZhbHVlKSAhPT0gbnVsbCAmJiBfa2V5c192YWx1ZXNfbmV4dF92YWx1ZSAhPT0gdm9pZCAwID8gX2tleXNfdmFsdWVzX25leHRfdmFsdWUgOiBudWxsO1xuICAgICAgICAgICAgLy8gQWx3YXlzIGZpcmUgb25TZWxlY3Rpb25DaGFuZ2UsIGV2ZW4gaWYgdGhlIGtleSBpcyB0aGUgc2FtZVxuICAgICAgICAgICAgLy8gYXMgdGhlIGN1cnJlbnQga2V5ICh1c2VDb250cm9sbGVkU3RhdGUgZG9lcyBub3QpLlxuICAgICAgICAgICAgaWYgKGtleSA9PT0gc2VsZWN0ZWRLZXkgJiYgcHJvcHMub25TZWxlY3Rpb25DaGFuZ2UpIHByb3BzLm9uU2VsZWN0aW9uQ2hhbmdlKGtleSk7XG4gICAgICAgICAgICBzZXRTZWxlY3RlZEtleShrZXkpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgbGV0IHNlbGVjdGVkSXRlbSA9IHNlbGVjdGVkS2V5ICE9IG51bGwgPyBjb2xsZWN0aW9uLmdldEl0ZW0oc2VsZWN0ZWRLZXkpIDogbnVsbDtcbiAgICByZXR1cm4ge1xuICAgICAgICBjb2xsZWN0aW9uOiBjb2xsZWN0aW9uLFxuICAgICAgICBkaXNhYmxlZEtleXM6IGRpc2FibGVkS2V5cyxcbiAgICAgICAgc2VsZWN0aW9uTWFuYWdlcjogc2VsZWN0aW9uTWFuYWdlcixcbiAgICAgICAgc2VsZWN0ZWRLZXk6IHNlbGVjdGVkS2V5LFxuICAgICAgICBzZXRTZWxlY3RlZEtleTogc2V0U2VsZWN0ZWRLZXksXG4gICAgICAgIHNlbGVjdGVkSXRlbTogc2VsZWN0ZWRJdGVtXG4gICAgfTtcbn1cblxuXG5cblxuXG5leHBvcnQgeyRlNzJkZDcyZTFjNzZhMjI1JGV4cG9ydCQyZjY0NTY0NWY3YmNhNzY0IGFzIHVzZUxpc3RTdGF0ZSwgJGEwZDY0NTI4OWZlOWI4NmIkZXhwb3J0JGU3ZjA1ZTk4NWRhZjRiNWYgYXMgdXNlU2luZ2xlU2VsZWN0TGlzdFN0YXRlLCAkYTAyZDU3MDQ5ZDIwMjY5NSRleHBvcnQkZDA4NWZiOWU5MjBiNWNhNyBhcyBMaXN0Q29sbGVjdGlvbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tb2R1bGUuanMubWFwXG4iXSwibmFtZXMiOlsidXNlTXVsdGlwbGVTZWxlY3Rpb25TdGF0ZSIsIiQ1OFBocyR1c2VNdWx0aXBsZVNlbGVjdGlvblN0YXRlIiwiU2VsZWN0aW9uTWFuYWdlciIsIiQ1OFBocyRTZWxlY3Rpb25NYW5hZ2VyIiwidXNlTWVtbyIsIiQ1OFBocyR1c2VNZW1vIiwidXNlQ2FsbGJhY2siLCIkNThQaHMkdXNlQ2FsbGJhY2siLCJ1c2VSZWYiLCIkNThQaHMkdXNlUmVmIiwidXNlRWZmZWN0IiwiJDU4UGhzJHVzZUVmZmVjdCIsInVzZUNvbGxlY3Rpb24iLCIkNThQaHMkdXNlQ29sbGVjdGlvbiIsInVzZUNvbnRyb2xsZWRTdGF0ZSIsIiQ1OFBocyR1c2VDb250cm9sbGVkU3RhdGUiLCIkYTAyZDU3MDQ5ZDIwMjY5NSRleHBvcnQkZDA4NWZiOWU5MjBiNWNhNyIsIlN5bWJvbCIsIml0ZXJhdG9yIiwiaXRlcmFibGUiLCJzaXplIiwia2V5TWFwIiwiZ2V0S2V5cyIsImtleXMiLCJnZXRLZXlCZWZvcmUiLCJrZXkiLCJub2RlIiwiZ2V0IiwicHJldktleSIsImdldEtleUFmdGVyIiwibmV4dEtleSIsImdldEZpcnN0S2V5IiwiZmlyc3RLZXkiLCJnZXRMYXN0S2V5IiwibGFzdEtleSIsImdldEl0ZW0iLCJhdCIsImlkeCIsImdldENoaWxkcmVuIiwiY2hpbGROb2RlcyIsImNvbnN0cnVjdG9yIiwibm9kZXMiLCJNYXAiLCJ2aXNpdCIsInNldCIsInR5cGUiLCJjaGlsZCIsImxhc3QiLCJpbmRleCIsInVuZGVmaW5lZCIsIiRlNzJkZDcyZTFjNzZhMjI1JGV4cG9ydCQyZjY0NTY0NWY3YmNhNzY0IiwicHJvcHMiLCJmaWx0ZXIiLCJzZWxlY3Rpb25TdGF0ZSIsImRpc2FibGVkS2V5cyIsIlNldCIsImZhY3RvcnkiLCJjb250ZXh0Iiwic3VwcHJlc3NUZXh0VmFsdWVXYXJuaW5nIiwiY29sbGVjdGlvbiIsInNlbGVjdGlvbk1hbmFnZXIiLCJjYWNoZWRDb2xsZWN0aW9uIiwiZm9jdXNlZEtleSIsInN0YXJ0SXRlbSIsImN1cnJlbnQiLCJjYWNoZWRJdGVtTm9kZXMiLCJtYXAiLCJpdGVtTm9kZSIsIml0ZW1Ob2RlcyIsImRpZmYiLCJsZW5ndGgiLCJNYXRoIiwibWluIiwibWF4IiwibmV3Tm9kZSIsImlzRGlzYWJsZWQiLCJzZXRGb2N1c2VkS2V5IiwiJGEwZDY0NTI4OWZlOWI4NmIkZXhwb3J0JGU3ZjA1ZTk4NWRhZjRiNWYiLCJfcHJvcHNfZGVmYXVsdFNlbGVjdGVkS2V5Iiwic2VsZWN0ZWRLZXkiLCJzZXRTZWxlY3RlZEtleSIsImRlZmF1bHRTZWxlY3RlZEtleSIsIm9uU2VsZWN0aW9uQ2hhbmdlIiwic2VsZWN0ZWRLZXlzIiwic2VsZWN0aW9uTW9kZSIsImRpc2FsbG93RW1wdHlTZWxlY3Rpb24iLCJhbGxvd0R1cGxpY2F0ZVNlbGVjdGlvbkV2ZW50cyIsIl9rZXlzX3ZhbHVlc19uZXh0X3ZhbHVlIiwidmFsdWVzIiwibmV4dCIsInZhbHVlIiwic2VsZWN0ZWRJdGVtIiwidXNlTGlzdFN0YXRlIiwidXNlU2luZ2xlU2VsZWN0TGlzdFN0YXRlIiwiTGlzdENvbGxlY3Rpb24iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-stately/list/dist/import.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-stately/menu/dist/import.mjs":
/*!**********************************************************!*\
  !*** ./node_modules/@react-stately/menu/dist/import.mjs ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   UNSTABLE_useSubmenuTriggerState: () => (/* binding */ $e5614764aa47eb35$export$d39fdbfa42246ac4),\n/* harmony export */   useMenuTriggerState: () => (/* binding */ $a28c903ee9ad8dc5$export$79fefeb1c2091ac3)\n/* harmony export */ });\n/* harmony import */ var _react_stately_overlays__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @react-stately/overlays */ \"(ssr)/./node_modules/@react-stately/overlays/dist/import.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ function $a28c903ee9ad8dc5$export$79fefeb1c2091ac3(props) {\n    let overlayTriggerState = (0, _react_stately_overlays__WEBPACK_IMPORTED_MODULE_1__.useOverlayTriggerState)(props);\n    let [focusStrategy, setFocusStrategy] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    let [expandedKeysStack, setExpandedKeysStack] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    let closeAll = ()=>{\n        setExpandedKeysStack([]);\n        overlayTriggerState.close();\n    };\n    let openSubmenu = (triggerKey, level)=>{\n        setExpandedKeysStack((oldStack)=>{\n            if (level > oldStack.length) return oldStack;\n            return [\n                ...oldStack.slice(0, level),\n                triggerKey\n            ];\n        });\n    };\n    let closeSubmenu = (triggerKey, level)=>{\n        setExpandedKeysStack((oldStack)=>{\n            let key = oldStack[level];\n            if (key === triggerKey) return oldStack.slice(0, level);\n            else return oldStack;\n        });\n    };\n    return {\n        focusStrategy: focusStrategy,\n        ...overlayTriggerState,\n        open (focusStrategy = null) {\n            setFocusStrategy(focusStrategy);\n            overlayTriggerState.open();\n        },\n        toggle (focusStrategy = null) {\n            setFocusStrategy(focusStrategy);\n            overlayTriggerState.toggle();\n        },\n        close () {\n            closeAll();\n        },\n        UNSTABLE_expandedKeysStack: expandedKeysStack,\n        UNSTABLE_openSubmenu: openSubmenu,\n        UNSTABLE_closeSubmenu: closeSubmenu\n    };\n}\n/*\n * Copyright 2023 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ function $e5614764aa47eb35$export$d39fdbfa42246ac4(props, state) {\n    let { triggerKey: triggerKey } = props;\n    let { UNSTABLE_expandedKeysStack: UNSTABLE_expandedKeysStack, UNSTABLE_openSubmenu: UNSTABLE_openSubmenu, UNSTABLE_closeSubmenu: UNSTABLE_closeSubmenu, close: closeAll } = state;\n    let [submenuLevel] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(UNSTABLE_expandedKeysStack === null || UNSTABLE_expandedKeysStack === void 0 ? void 0 : UNSTABLE_expandedKeysStack.length);\n    let isOpen = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>UNSTABLE_expandedKeysStack[submenuLevel] === triggerKey, [\n        UNSTABLE_expandedKeysStack,\n        triggerKey,\n        submenuLevel\n    ]);\n    let [focusStrategy, setFocusStrategy] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    let open = (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((focusStrategy = null)=>{\n        setFocusStrategy(focusStrategy);\n        UNSTABLE_openSubmenu(triggerKey, submenuLevel);\n    }, [\n        UNSTABLE_openSubmenu,\n        submenuLevel,\n        triggerKey\n    ]);\n    let close = (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        setFocusStrategy(null);\n        UNSTABLE_closeSubmenu(triggerKey, submenuLevel);\n    }, [\n        UNSTABLE_closeSubmenu,\n        submenuLevel,\n        triggerKey\n    ]);\n    let toggle = (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((focusStrategy = null)=>{\n        setFocusStrategy(focusStrategy);\n        if (isOpen) close();\n        else open(focusStrategy);\n    }, [\n        close,\n        open,\n        isOpen\n    ]);\n    return (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>({\n            focusStrategy: focusStrategy,\n            isOpen: isOpen,\n            open: open,\n            close: close,\n            closeAll: closeAll,\n            submenuLevel: submenuLevel,\n            // TODO: Placeholders that aren't used but give us parity with OverlayTriggerState so we can use this in Popover. Refactor if we update Popover via\n            // https://github.com/adobe/react-spectrum/pull/4976#discussion_r1336472863\n            setOpen: ()=>{},\n            toggle: toggle\n        }), [\n        isOpen,\n        open,\n        close,\n        closeAll,\n        focusStrategy,\n        toggle,\n        submenuLevel\n    ]);\n}\n //# sourceMappingURL=module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXN0YXRlbHkvbWVudS9kaXN0L2ltcG9ydC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFnRztBQUNnQjtBQUVoSDs7Ozs7Ozs7OztDQVVDLEdBQUc7Ozs7Ozs7Ozs7Q0FVSCxHQUVELFNBQVNRLDBDQUEwQ0MsS0FBSztJQUNwRCxJQUFJQyxzQkFBc0IsQ0FBQyxHQUFHVCwyRUFBNEIsRUFBR1E7SUFDN0QsSUFBSSxDQUFDRSxlQUFlQyxpQkFBaUIsR0FBRyxDQUFDLEdBQUdULDJDQUFjLEVBQUc7SUFDN0QsSUFBSSxDQUFDVSxtQkFBbUJDLHFCQUFxQixHQUFHLENBQUMsR0FBR1gsMkNBQWMsRUFBRyxFQUFFO0lBQ3ZFLElBQUlZLFdBQVc7UUFDWEQscUJBQXFCLEVBQUU7UUFDdkJKLG9CQUFvQk0sS0FBSztJQUM3QjtJQUNBLElBQUlDLGNBQWMsQ0FBQ0MsWUFBWUM7UUFDM0JMLHFCQUFxQixDQUFDTTtZQUNsQixJQUFJRCxRQUFRQyxTQUFTQyxNQUFNLEVBQUUsT0FBT0Q7WUFDcEMsT0FBTzttQkFDQUEsU0FBU0UsS0FBSyxDQUFDLEdBQUdIO2dCQUNyQkQ7YUFDSDtRQUNMO0lBQ0o7SUFDQSxJQUFJSyxlQUFlLENBQUNMLFlBQVlDO1FBQzVCTCxxQkFBcUIsQ0FBQ007WUFDbEIsSUFBSUksTUFBTUosUUFBUSxDQUFDRCxNQUFNO1lBQ3pCLElBQUlLLFFBQVFOLFlBQVksT0FBT0UsU0FBU0UsS0FBSyxDQUFDLEdBQUdIO2lCQUM1QyxPQUFPQztRQUNoQjtJQUNKO0lBQ0EsT0FBTztRQUNIVCxlQUFlQTtRQUNmLEdBQUdELG1CQUFtQjtRQUN0QmUsTUFBTWQsZ0JBQWdCLElBQUk7WUFDdEJDLGlCQUFpQkQ7WUFDakJELG9CQUFvQmUsSUFBSTtRQUM1QjtRQUNBQyxRQUFRZixnQkFBZ0IsSUFBSTtZQUN4QkMsaUJBQWlCRDtZQUNqQkQsb0JBQW9CZ0IsTUFBTTtRQUM5QjtRQUNBVjtZQUNJRDtRQUNKO1FBQ0FZLDRCQUE0QmQ7UUFDNUJlLHNCQUFzQlg7UUFDdEJZLHVCQUF1Qk47SUFDM0I7QUFDSjtBQUdBOzs7Ozs7Ozs7O0NBVUMsR0FDRCxTQUFTTywwQ0FBMENyQixLQUFLLEVBQUVzQixLQUFLO0lBQzNELElBQUksRUFBRWIsWUFBWUEsVUFBVSxFQUFFLEdBQUdUO0lBQ2pDLElBQUksRUFBRWtCLDRCQUE0QkEsMEJBQTBCLEVBQUVDLHNCQUFzQkEsb0JBQW9CLEVBQUVDLHVCQUF1QkEscUJBQXFCLEVBQUViLE9BQU9ELFFBQVEsRUFBRSxHQUFHZ0I7SUFDNUssSUFBSSxDQUFDQyxhQUFhLEdBQUcsQ0FBQyxHQUFHN0IsMkNBQWMsRUFBR3dCLCtCQUErQixRQUFRQSwrQkFBK0IsS0FBSyxJQUFJLEtBQUssSUFBSUEsMkJBQTJCTixNQUFNO0lBQ25LLElBQUlZLFNBQVMsQ0FBQyxHQUFHNUIsMENBQWEsRUFBRyxJQUFJc0IsMEJBQTBCLENBQUNLLGFBQWEsS0FBS2QsWUFBWTtRQUMxRlM7UUFDQVQ7UUFDQWM7S0FDSDtJQUNELElBQUksQ0FBQ3JCLGVBQWVDLGlCQUFpQixHQUFHLENBQUMsR0FBR1QsMkNBQWMsRUFBRztJQUM3RCxJQUFJc0IsT0FBTyxDQUFDLEdBQUdsQiw4Q0FBaUIsRUFBRyxDQUFDSSxnQkFBZ0IsSUFBSTtRQUNwREMsaUJBQWlCRDtRQUNqQmlCLHFCQUFxQlYsWUFBWWM7SUFDckMsR0FBRztRQUNDSjtRQUNBSTtRQUNBZDtLQUNIO0lBQ0QsSUFBSUYsUUFBUSxDQUFDLEdBQUdULDhDQUFpQixFQUFHO1FBQ2hDSyxpQkFBaUI7UUFDakJpQixzQkFBc0JYLFlBQVljO0lBQ3RDLEdBQUc7UUFDQ0g7UUFDQUc7UUFDQWQ7S0FDSDtJQUNELElBQUlRLFNBQVMsQ0FBQyxHQUFHbkIsOENBQWlCLEVBQUcsQ0FBQ0ksZ0JBQWdCLElBQUk7UUFDdERDLGlCQUFpQkQ7UUFDakIsSUFBSXNCLFFBQVFqQjthQUNQUyxLQUFLZDtJQUNkLEdBQUc7UUFDQ0s7UUFDQVM7UUFDQVE7S0FDSDtJQUNELE9BQU8sQ0FBQyxHQUFHNUIsMENBQWEsRUFBRyxJQUFLO1lBQ3hCTSxlQUFlQTtZQUNmc0IsUUFBUUE7WUFDUlIsTUFBTUE7WUFDTlQsT0FBT0E7WUFDUEQsVUFBVUE7WUFDVmlCLGNBQWNBO1lBQ2QsbUpBQW1KO1lBQ25KLDJFQUEyRTtZQUMzRUUsU0FBUyxLQUFLO1lBQ2RSLFFBQVFBO1FBQ1osSUFBSTtRQUNKTztRQUNBUjtRQUNBVDtRQUNBRDtRQUNBSjtRQUNBZTtRQUNBTTtLQUNIO0FBQ0w7QUFLd0osQ0FDeEosa0NBQWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1mbGFzay8uL25vZGVfbW9kdWxlcy9AcmVhY3Qtc3RhdGVseS9tZW51L2Rpc3QvaW1wb3J0Lm1qcz8xYjVlIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7dXNlT3ZlcmxheVRyaWdnZXJTdGF0ZSBhcyAkOVh2b2gkdXNlT3ZlcmxheVRyaWdnZXJTdGF0ZX0gZnJvbSBcIkByZWFjdC1zdGF0ZWx5L292ZXJsYXlzXCI7XG5pbXBvcnQge3VzZVN0YXRlIGFzICQ5WHZvaCR1c2VTdGF0ZSwgdXNlTWVtbyBhcyAkOVh2b2gkdXNlTWVtbywgdXNlQ2FsbGJhY2sgYXMgJDlYdm9oJHVzZUNhbGxiYWNrfSBmcm9tIFwicmVhY3RcIjtcblxuLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIC8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyBcblxuZnVuY3Rpb24gJGEyOGM5MDNlZTlhZDhkYzUkZXhwb3J0JDc5ZmVmZWIxYzIwOTFhYzMocHJvcHMpIHtcbiAgICBsZXQgb3ZlcmxheVRyaWdnZXJTdGF0ZSA9ICgwLCAkOVh2b2gkdXNlT3ZlcmxheVRyaWdnZXJTdGF0ZSkocHJvcHMpO1xuICAgIGxldCBbZm9jdXNTdHJhdGVneSwgc2V0Rm9jdXNTdHJhdGVneV0gPSAoMCwgJDlYdm9oJHVzZVN0YXRlKShudWxsKTtcbiAgICBsZXQgW2V4cGFuZGVkS2V5c1N0YWNrLCBzZXRFeHBhbmRlZEtleXNTdGFja10gPSAoMCwgJDlYdm9oJHVzZVN0YXRlKShbXSk7XG4gICAgbGV0IGNsb3NlQWxsID0gKCk9PntcbiAgICAgICAgc2V0RXhwYW5kZWRLZXlzU3RhY2soW10pO1xuICAgICAgICBvdmVybGF5VHJpZ2dlclN0YXRlLmNsb3NlKCk7XG4gICAgfTtcbiAgICBsZXQgb3BlblN1Ym1lbnUgPSAodHJpZ2dlcktleSwgbGV2ZWwpPT57XG4gICAgICAgIHNldEV4cGFuZGVkS2V5c1N0YWNrKChvbGRTdGFjayk9PntcbiAgICAgICAgICAgIGlmIChsZXZlbCA+IG9sZFN0YWNrLmxlbmd0aCkgcmV0dXJuIG9sZFN0YWNrO1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAuLi5vbGRTdGFjay5zbGljZSgwLCBsZXZlbCksXG4gICAgICAgICAgICAgICAgdHJpZ2dlcktleVxuICAgICAgICAgICAgXTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBsZXQgY2xvc2VTdWJtZW51ID0gKHRyaWdnZXJLZXksIGxldmVsKT0+e1xuICAgICAgICBzZXRFeHBhbmRlZEtleXNTdGFjaygob2xkU3RhY2spPT57XG4gICAgICAgICAgICBsZXQga2V5ID0gb2xkU3RhY2tbbGV2ZWxdO1xuICAgICAgICAgICAgaWYgKGtleSA9PT0gdHJpZ2dlcktleSkgcmV0dXJuIG9sZFN0YWNrLnNsaWNlKDAsIGxldmVsKTtcbiAgICAgICAgICAgIGVsc2UgcmV0dXJuIG9sZFN0YWNrO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiB7XG4gICAgICAgIGZvY3VzU3RyYXRlZ3k6IGZvY3VzU3RyYXRlZ3ksXG4gICAgICAgIC4uLm92ZXJsYXlUcmlnZ2VyU3RhdGUsXG4gICAgICAgIG9wZW4gKGZvY3VzU3RyYXRlZ3kgPSBudWxsKSB7XG4gICAgICAgICAgICBzZXRGb2N1c1N0cmF0ZWd5KGZvY3VzU3RyYXRlZ3kpO1xuICAgICAgICAgICAgb3ZlcmxheVRyaWdnZXJTdGF0ZS5vcGVuKCk7XG4gICAgICAgIH0sXG4gICAgICAgIHRvZ2dsZSAoZm9jdXNTdHJhdGVneSA9IG51bGwpIHtcbiAgICAgICAgICAgIHNldEZvY3VzU3RyYXRlZ3koZm9jdXNTdHJhdGVneSk7XG4gICAgICAgICAgICBvdmVybGF5VHJpZ2dlclN0YXRlLnRvZ2dsZSgpO1xuICAgICAgICB9LFxuICAgICAgICBjbG9zZSAoKSB7XG4gICAgICAgICAgICBjbG9zZUFsbCgpO1xuICAgICAgICB9LFxuICAgICAgICBVTlNUQUJMRV9leHBhbmRlZEtleXNTdGFjazogZXhwYW5kZWRLZXlzU3RhY2ssXG4gICAgICAgIFVOU1RBQkxFX29wZW5TdWJtZW51OiBvcGVuU3VibWVudSxcbiAgICAgICAgVU5TVEFCTEVfY2xvc2VTdWJtZW51OiBjbG9zZVN1Ym1lbnVcbiAgICB9O1xufVxuXG5cbi8qXG4gKiBDb3B5cmlnaHQgMjAyMyBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyBcbmZ1bmN0aW9uICRlNTYxNDc2NGFhNDdlYjM1JGV4cG9ydCRkMzlmZGJmYTQyMjQ2YWM0KHByb3BzLCBzdGF0ZSkge1xuICAgIGxldCB7IHRyaWdnZXJLZXk6IHRyaWdnZXJLZXkgfSA9IHByb3BzO1xuICAgIGxldCB7IFVOU1RBQkxFX2V4cGFuZGVkS2V5c1N0YWNrOiBVTlNUQUJMRV9leHBhbmRlZEtleXNTdGFjaywgVU5TVEFCTEVfb3BlblN1Ym1lbnU6IFVOU1RBQkxFX29wZW5TdWJtZW51LCBVTlNUQUJMRV9jbG9zZVN1Ym1lbnU6IFVOU1RBQkxFX2Nsb3NlU3VibWVudSwgY2xvc2U6IGNsb3NlQWxsIH0gPSBzdGF0ZTtcbiAgICBsZXQgW3N1Ym1lbnVMZXZlbF0gPSAoMCwgJDlYdm9oJHVzZVN0YXRlKShVTlNUQUJMRV9leHBhbmRlZEtleXNTdGFjayA9PT0gbnVsbCB8fCBVTlNUQUJMRV9leHBhbmRlZEtleXNTdGFjayA9PT0gdm9pZCAwID8gdm9pZCAwIDogVU5TVEFCTEVfZXhwYW5kZWRLZXlzU3RhY2subGVuZ3RoKTtcbiAgICBsZXQgaXNPcGVuID0gKDAsICQ5WHZvaCR1c2VNZW1vKSgoKT0+VU5TVEFCTEVfZXhwYW5kZWRLZXlzU3RhY2tbc3VibWVudUxldmVsXSA9PT0gdHJpZ2dlcktleSwgW1xuICAgICAgICBVTlNUQUJMRV9leHBhbmRlZEtleXNTdGFjayxcbiAgICAgICAgdHJpZ2dlcktleSxcbiAgICAgICAgc3VibWVudUxldmVsXG4gICAgXSk7XG4gICAgbGV0IFtmb2N1c1N0cmF0ZWd5LCBzZXRGb2N1c1N0cmF0ZWd5XSA9ICgwLCAkOVh2b2gkdXNlU3RhdGUpKG51bGwpO1xuICAgIGxldCBvcGVuID0gKDAsICQ5WHZvaCR1c2VDYWxsYmFjaykoKGZvY3VzU3RyYXRlZ3kgPSBudWxsKT0+e1xuICAgICAgICBzZXRGb2N1c1N0cmF0ZWd5KGZvY3VzU3RyYXRlZ3kpO1xuICAgICAgICBVTlNUQUJMRV9vcGVuU3VibWVudSh0cmlnZ2VyS2V5LCBzdWJtZW51TGV2ZWwpO1xuICAgIH0sIFtcbiAgICAgICAgVU5TVEFCTEVfb3BlblN1Ym1lbnUsXG4gICAgICAgIHN1Ym1lbnVMZXZlbCxcbiAgICAgICAgdHJpZ2dlcktleVxuICAgIF0pO1xuICAgIGxldCBjbG9zZSA9ICgwLCAkOVh2b2gkdXNlQ2FsbGJhY2spKCgpPT57XG4gICAgICAgIHNldEZvY3VzU3RyYXRlZ3kobnVsbCk7XG4gICAgICAgIFVOU1RBQkxFX2Nsb3NlU3VibWVudSh0cmlnZ2VyS2V5LCBzdWJtZW51TGV2ZWwpO1xuICAgIH0sIFtcbiAgICAgICAgVU5TVEFCTEVfY2xvc2VTdWJtZW51LFxuICAgICAgICBzdWJtZW51TGV2ZWwsXG4gICAgICAgIHRyaWdnZXJLZXlcbiAgICBdKTtcbiAgICBsZXQgdG9nZ2xlID0gKDAsICQ5WHZvaCR1c2VDYWxsYmFjaykoKGZvY3VzU3RyYXRlZ3kgPSBudWxsKT0+e1xuICAgICAgICBzZXRGb2N1c1N0cmF0ZWd5KGZvY3VzU3RyYXRlZ3kpO1xuICAgICAgICBpZiAoaXNPcGVuKSBjbG9zZSgpO1xuICAgICAgICBlbHNlIG9wZW4oZm9jdXNTdHJhdGVneSk7XG4gICAgfSwgW1xuICAgICAgICBjbG9zZSxcbiAgICAgICAgb3BlbixcbiAgICAgICAgaXNPcGVuXG4gICAgXSk7XG4gICAgcmV0dXJuICgwLCAkOVh2b2gkdXNlTWVtbykoKCk9Pih7XG4gICAgICAgICAgICBmb2N1c1N0cmF0ZWd5OiBmb2N1c1N0cmF0ZWd5LFxuICAgICAgICAgICAgaXNPcGVuOiBpc09wZW4sXG4gICAgICAgICAgICBvcGVuOiBvcGVuLFxuICAgICAgICAgICAgY2xvc2U6IGNsb3NlLFxuICAgICAgICAgICAgY2xvc2VBbGw6IGNsb3NlQWxsLFxuICAgICAgICAgICAgc3VibWVudUxldmVsOiBzdWJtZW51TGV2ZWwsXG4gICAgICAgICAgICAvLyBUT0RPOiBQbGFjZWhvbGRlcnMgdGhhdCBhcmVuJ3QgdXNlZCBidXQgZ2l2ZSB1cyBwYXJpdHkgd2l0aCBPdmVybGF5VHJpZ2dlclN0YXRlIHNvIHdlIGNhbiB1c2UgdGhpcyBpbiBQb3BvdmVyLiBSZWZhY3RvciBpZiB3ZSB1cGRhdGUgUG9wb3ZlciB2aWFcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9hZG9iZS9yZWFjdC1zcGVjdHJ1bS9wdWxsLzQ5NzYjZGlzY3Vzc2lvbl9yMTMzNjQ3Mjg2M1xuICAgICAgICAgICAgc2V0T3BlbjogKCk9Pnt9LFxuICAgICAgICAgICAgdG9nZ2xlOiB0b2dnbGVcbiAgICAgICAgfSksIFtcbiAgICAgICAgaXNPcGVuLFxuICAgICAgICBvcGVuLFxuICAgICAgICBjbG9zZSxcbiAgICAgICAgY2xvc2VBbGwsXG4gICAgICAgIGZvY3VzU3RyYXRlZ3ksXG4gICAgICAgIHRvZ2dsZSxcbiAgICAgICAgc3VibWVudUxldmVsXG4gICAgXSk7XG59XG5cblxuXG5cbmV4cG9ydCB7JGEyOGM5MDNlZTlhZDhkYzUkZXhwb3J0JDc5ZmVmZWIxYzIwOTFhYzMgYXMgdXNlTWVudVRyaWdnZXJTdGF0ZSwgJGU1NjE0NzY0YWE0N2ViMzUkZXhwb3J0JGQzOWZkYmZhNDIyNDZhYzQgYXMgVU5TVEFCTEVfdXNlU3VibWVudVRyaWdnZXJTdGF0ZX07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tb2R1bGUuanMubWFwXG4iXSwibmFtZXMiOlsidXNlT3ZlcmxheVRyaWdnZXJTdGF0ZSIsIiQ5WHZvaCR1c2VPdmVybGF5VHJpZ2dlclN0YXRlIiwidXNlU3RhdGUiLCIkOVh2b2gkdXNlU3RhdGUiLCJ1c2VNZW1vIiwiJDlYdm9oJHVzZU1lbW8iLCJ1c2VDYWxsYmFjayIsIiQ5WHZvaCR1c2VDYWxsYmFjayIsIiRhMjhjOTAzZWU5YWQ4ZGM1JGV4cG9ydCQ3OWZlZmViMWMyMDkxYWMzIiwicHJvcHMiLCJvdmVybGF5VHJpZ2dlclN0YXRlIiwiZm9jdXNTdHJhdGVneSIsInNldEZvY3VzU3RyYXRlZ3kiLCJleHBhbmRlZEtleXNTdGFjayIsInNldEV4cGFuZGVkS2V5c1N0YWNrIiwiY2xvc2VBbGwiLCJjbG9zZSIsIm9wZW5TdWJtZW51IiwidHJpZ2dlcktleSIsImxldmVsIiwib2xkU3RhY2siLCJsZW5ndGgiLCJzbGljZSIsImNsb3NlU3VibWVudSIsImtleSIsIm9wZW4iLCJ0b2dnbGUiLCJVTlNUQUJMRV9leHBhbmRlZEtleXNTdGFjayIsIlVOU1RBQkxFX29wZW5TdWJtZW51IiwiVU5TVEFCTEVfY2xvc2VTdWJtZW51IiwiJGU1NjE0NzY0YWE0N2ViMzUkZXhwb3J0JGQzOWZkYmZhNDIyNDZhYzQiLCJzdGF0ZSIsInN1Ym1lbnVMZXZlbCIsImlzT3BlbiIsInNldE9wZW4iLCJ1c2VNZW51VHJpZ2dlclN0YXRlIiwiVU5TVEFCTEVfdXNlU3VibWVudVRyaWdnZXJTdGF0ZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-stately/menu/dist/import.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-stately/overlays/dist/import.mjs":
/*!**************************************************************!*\
  !*** ./node_modules/@react-stately/overlays/dist/import.mjs ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useOverlayTriggerState: () => (/* binding */ $fc909762b330b746$export$61c6a8c84e605fb6)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _react_stately_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @react-stately/utils */ \"(ssr)/./node_modules/@react-stately/utils/dist/import.mjs\");\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ function $fc909762b330b746$export$61c6a8c84e605fb6(props) {\n    let [isOpen, setOpen] = (0, _react_stately_utils__WEBPACK_IMPORTED_MODULE_1__.useControlledState)(props.isOpen, props.defaultOpen || false, props.onOpenChange);\n    const open = (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        setOpen(true);\n    }, [\n        setOpen\n    ]);\n    const close = (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        setOpen(false);\n    }, [\n        setOpen\n    ]);\n    const toggle = (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        setOpen(!isOpen);\n    }, [\n        setOpen,\n        isOpen\n    ]);\n    return {\n        isOpen: isOpen,\n        setOpen: setOpen,\n        open: open,\n        close: close,\n        toggle: toggle\n    };\n}\n //# sourceMappingURL=module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXN0YXRlbHkvb3ZlcmxheXMvZGlzdC9pbXBvcnQubWpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUF3RDtBQUM2QjtBQUVyRjs7Ozs7Ozs7OztDQVVDLEdBQUc7Ozs7Ozs7Ozs7Q0FVSCxHQUVELFNBQVNJLDBDQUEwQ0MsS0FBSztJQUNwRCxJQUFJLENBQUNDLFFBQVFDLFFBQVEsR0FBRyxDQUFDLEdBQUdKLG9FQUF3QixFQUFHRSxNQUFNQyxNQUFNLEVBQUVELE1BQU1HLFdBQVcsSUFBSSxPQUFPSCxNQUFNSSxZQUFZO0lBQ25ILE1BQU1DLE9BQU8sQ0FBQyxHQUFHVCw4Q0FBaUIsRUFBRztRQUNqQ00sUUFBUTtJQUNaLEdBQUc7UUFDQ0E7S0FDSDtJQUNELE1BQU1JLFFBQVEsQ0FBQyxHQUFHViw4Q0FBaUIsRUFBRztRQUNsQ00sUUFBUTtJQUNaLEdBQUc7UUFDQ0E7S0FDSDtJQUNELE1BQU1LLFNBQVMsQ0FBQyxHQUFHWCw4Q0FBaUIsRUFBRztRQUNuQ00sUUFBUSxDQUFDRDtJQUNiLEdBQUc7UUFDQ0M7UUFDQUQ7S0FDSDtJQUNELE9BQU87UUFDSEEsUUFBUUE7UUFDUkMsU0FBU0E7UUFDVEcsTUFBTUE7UUFDTkMsT0FBT0E7UUFDUEMsUUFBUUE7SUFDWjtBQUNKO0FBSzZFLENBQzdFLGtDQUFrQyIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtZmxhc2svLi9ub2RlX21vZHVsZXMvQHJlYWN0LXN0YXRlbHkvb3ZlcmxheXMvZGlzdC9pbXBvcnQubWpzPzA3YTQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHt1c2VDYWxsYmFjayBhcyAkNG9BM1AkdXNlQ2FsbGJhY2t9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHt1c2VDb250cm9sbGVkU3RhdGUgYXMgJDRvQTNQJHVzZUNvbnRyb2xsZWRTdGF0ZX0gZnJvbSBcIkByZWFjdC1zdGF0ZWx5L3V0aWxzXCI7XG5cbi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyAvKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gXG5cbmZ1bmN0aW9uICRmYzkwOTc2MmIzMzBiNzQ2JGV4cG9ydCQ2MWM2YThjODRlNjA1ZmI2KHByb3BzKSB7XG4gICAgbGV0IFtpc09wZW4sIHNldE9wZW5dID0gKDAsICQ0b0EzUCR1c2VDb250cm9sbGVkU3RhdGUpKHByb3BzLmlzT3BlbiwgcHJvcHMuZGVmYXVsdE9wZW4gfHwgZmFsc2UsIHByb3BzLm9uT3BlbkNoYW5nZSk7XG4gICAgY29uc3Qgb3BlbiA9ICgwLCAkNG9BM1AkdXNlQ2FsbGJhY2spKCgpPT57XG4gICAgICAgIHNldE9wZW4odHJ1ZSk7XG4gICAgfSwgW1xuICAgICAgICBzZXRPcGVuXG4gICAgXSk7XG4gICAgY29uc3QgY2xvc2UgPSAoMCwgJDRvQTNQJHVzZUNhbGxiYWNrKSgoKT0+e1xuICAgICAgICBzZXRPcGVuKGZhbHNlKTtcbiAgICB9LCBbXG4gICAgICAgIHNldE9wZW5cbiAgICBdKTtcbiAgICBjb25zdCB0b2dnbGUgPSAoMCwgJDRvQTNQJHVzZUNhbGxiYWNrKSgoKT0+e1xuICAgICAgICBzZXRPcGVuKCFpc09wZW4pO1xuICAgIH0sIFtcbiAgICAgICAgc2V0T3BlbixcbiAgICAgICAgaXNPcGVuXG4gICAgXSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgaXNPcGVuOiBpc09wZW4sXG4gICAgICAgIHNldE9wZW46IHNldE9wZW4sXG4gICAgICAgIG9wZW46IG9wZW4sXG4gICAgICAgIGNsb3NlOiBjbG9zZSxcbiAgICAgICAgdG9nZ2xlOiB0b2dnbGVcbiAgICB9O1xufVxuXG5cblxuXG5leHBvcnQgeyRmYzkwOTc2MmIzMzBiNzQ2JGV4cG9ydCQ2MWM2YThjODRlNjA1ZmI2IGFzIHVzZU92ZXJsYXlUcmlnZ2VyU3RhdGV9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bW9kdWxlLmpzLm1hcFxuIl0sIm5hbWVzIjpbInVzZUNhbGxiYWNrIiwiJDRvQTNQJHVzZUNhbGxiYWNrIiwidXNlQ29udHJvbGxlZFN0YXRlIiwiJDRvQTNQJHVzZUNvbnRyb2xsZWRTdGF0ZSIsIiRmYzkwOTc2MmIzMzBiNzQ2JGV4cG9ydCQ2MWM2YThjODRlNjA1ZmI2IiwicHJvcHMiLCJpc09wZW4iLCJzZXRPcGVuIiwiZGVmYXVsdE9wZW4iLCJvbk9wZW5DaGFuZ2UiLCJvcGVuIiwiY2xvc2UiLCJ0b2dnbGUiLCJ1c2VPdmVybGF5VHJpZ2dlclN0YXRlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-stately/overlays/dist/import.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-stately/radio/dist/import.mjs":
/*!***********************************************************!*\
  !*** ./node_modules/@react-stately/radio/dist/import.mjs ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useRadioGroupState: () => (/* binding */ $a54cdc5c1942b639$export$bca9d026f8e704eb)\n/* harmony export */ });\n/* harmony import */ var _react_stately_form__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @react-stately/form */ \"(ssr)/./node_modules/@react-stately/form/dist/import.mjs\");\n/* harmony import */ var _react_stately_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @react-stately/utils */ \"(ssr)/./node_modules/@react-stately/utils/dist/import.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ let $a54cdc5c1942b639$var$instance = Math.round(Math.random() * 10000000000);\nlet $a54cdc5c1942b639$var$i = 0;\nfunction $a54cdc5c1942b639$export$bca9d026f8e704eb(props) {\n    // Preserved here for backward compatibility. React Aria now generates the name instead of stately.\n    let name = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>props.name || `radio-group-${$a54cdc5c1942b639$var$instance}-${++$a54cdc5c1942b639$var$i}`, [\n        props.name\n    ]);\n    var _props_defaultValue;\n    let [selectedValue, setSelected] = (0, _react_stately_utils__WEBPACK_IMPORTED_MODULE_1__.useControlledState)(props.value, (_props_defaultValue = props.defaultValue) !== null && _props_defaultValue !== void 0 ? _props_defaultValue : null, props.onChange);\n    let [lastFocusedValue, setLastFocusedValue] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    let validation = (0, _react_stately_form__WEBPACK_IMPORTED_MODULE_2__.useFormValidationState)({\n        ...props,\n        value: selectedValue\n    });\n    let setSelectedValue = (value)=>{\n        if (!props.isReadOnly && !props.isDisabled) {\n            setSelected(value);\n            validation.commitValidation();\n        }\n    };\n    let isInvalid = validation.displayValidation.isInvalid;\n    return {\n        ...validation,\n        name: name,\n        selectedValue: selectedValue,\n        setSelectedValue: setSelectedValue,\n        lastFocusedValue: lastFocusedValue,\n        setLastFocusedValue: setLastFocusedValue,\n        isDisabled: props.isDisabled || false,\n        isReadOnly: props.isReadOnly || false,\n        isRequired: props.isRequired || false,\n        validationState: props.validationState || (isInvalid ? \"invalid\" : null),\n        isInvalid: isInvalid\n    };\n}\n //# sourceMappingURL=module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXN0YXRlbHkvcmFkaW8vZGlzdC9pbXBvcnQubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBNEY7QUFDUDtBQUNSO0FBRTdFOzs7Ozs7Ozs7O0NBVUMsR0FBRzs7Ozs7Ozs7OztDQVVILEdBR0QsSUFBSVEsaUNBQWlDQyxLQUFLQyxLQUFLLENBQUNELEtBQUtFLE1BQU0sS0FBSztBQUNoRSxJQUFJQywwQkFBMEI7QUFDOUIsU0FBU0MsMENBQTBDQyxLQUFLO0lBQ3BELG1HQUFtRztJQUNuRyxJQUFJQyxPQUFPLENBQUMsR0FBR1YsMENBQWEsRUFBRyxJQUFJUyxNQUFNQyxJQUFJLElBQUksQ0FBQyxZQUFZLEVBQUVQLCtCQUErQixDQUFDLEVBQUUsRUFBRUksd0JBQXdCLENBQUMsRUFBRTtRQUMzSEUsTUFBTUMsSUFBSTtLQUNiO0lBQ0QsSUFBSUM7SUFDSixJQUFJLENBQUNDLGVBQWVDLFlBQVksR0FBRyxDQUFDLEdBQUdmLG9FQUF3QixFQUFHVyxNQUFNSyxLQUFLLEVBQUUsQ0FBQ0gsc0JBQXNCRixNQUFNTSxZQUFZLE1BQU0sUUFBUUosd0JBQXdCLEtBQUssSUFBSUEsc0JBQXNCLE1BQU1GLE1BQU1PLFFBQVE7SUFDak4sSUFBSSxDQUFDQyxrQkFBa0JDLG9CQUFvQixHQUFHLENBQUMsR0FBR2hCLDJDQUFjLEVBQUc7SUFDbkUsSUFBSWlCLGFBQWEsQ0FBQyxHQUFHdkIsdUVBQTRCLEVBQUc7UUFDaEQsR0FBR2EsS0FBSztRQUNSSyxPQUFPRjtJQUNYO0lBQ0EsSUFBSVEsbUJBQW1CLENBQUNOO1FBQ3BCLElBQUksQ0FBQ0wsTUFBTVksVUFBVSxJQUFJLENBQUNaLE1BQU1hLFVBQVUsRUFBRTtZQUN4Q1QsWUFBWUM7WUFDWkssV0FBV0ksZ0JBQWdCO1FBQy9CO0lBQ0o7SUFDQSxJQUFJQyxZQUFZTCxXQUFXTSxpQkFBaUIsQ0FBQ0QsU0FBUztJQUN0RCxPQUFPO1FBQ0gsR0FBR0wsVUFBVTtRQUNiVCxNQUFNQTtRQUNORSxlQUFlQTtRQUNmUSxrQkFBa0JBO1FBQ2xCSCxrQkFBa0JBO1FBQ2xCQyxxQkFBcUJBO1FBQ3JCSSxZQUFZYixNQUFNYSxVQUFVLElBQUk7UUFDaENELFlBQVlaLE1BQU1ZLFVBQVUsSUFBSTtRQUNoQ0ssWUFBWWpCLE1BQU1pQixVQUFVLElBQUk7UUFDaENDLGlCQUFpQmxCLE1BQU1rQixlQUFlLElBQUtILENBQUFBLFlBQVksWUFBWSxJQUFHO1FBQ3RFQSxXQUFXQTtJQUNmO0FBQ0o7QUFLeUUsQ0FDekUsa0NBQWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1mbGFzay8uL25vZGVfbW9kdWxlcy9AcmVhY3Qtc3RhdGVseS9yYWRpby9kaXN0L2ltcG9ydC5tanM/MzNlMyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge3VzZUZvcm1WYWxpZGF0aW9uU3RhdGUgYXMgJGZRMlNGJHVzZUZvcm1WYWxpZGF0aW9uU3RhdGV9IGZyb20gXCJAcmVhY3Qtc3RhdGVseS9mb3JtXCI7XG5pbXBvcnQge3VzZUNvbnRyb2xsZWRTdGF0ZSBhcyAkZlEyU0YkdXNlQ29udHJvbGxlZFN0YXRlfSBmcm9tIFwiQHJlYWN0LXN0YXRlbHkvdXRpbHNcIjtcbmltcG9ydCB7dXNlTWVtbyBhcyAkZlEyU0YkdXNlTWVtbywgdXNlU3RhdGUgYXMgJGZRMlNGJHVzZVN0YXRlfSBmcm9tIFwicmVhY3RcIjtcblxuLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIC8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyBcblxuXG5sZXQgJGE1NGNkYzVjMTk0MmI2MzkkdmFyJGluc3RhbmNlID0gTWF0aC5yb3VuZChNYXRoLnJhbmRvbSgpICogMTAwMDAwMDAwMDApO1xubGV0ICRhNTRjZGM1YzE5NDJiNjM5JHZhciRpID0gMDtcbmZ1bmN0aW9uICRhNTRjZGM1YzE5NDJiNjM5JGV4cG9ydCRiY2E5ZDAyNmY4ZTcwNGViKHByb3BzKSB7XG4gICAgLy8gUHJlc2VydmVkIGhlcmUgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkuIFJlYWN0IEFyaWEgbm93IGdlbmVyYXRlcyB0aGUgbmFtZSBpbnN0ZWFkIG9mIHN0YXRlbHkuXG4gICAgbGV0IG5hbWUgPSAoMCwgJGZRMlNGJHVzZU1lbW8pKCgpPT5wcm9wcy5uYW1lIHx8IGByYWRpby1ncm91cC0keyRhNTRjZGM1YzE5NDJiNjM5JHZhciRpbnN0YW5jZX0tJHsrKyRhNTRjZGM1YzE5NDJiNjM5JHZhciRpfWAsIFtcbiAgICAgICAgcHJvcHMubmFtZVxuICAgIF0pO1xuICAgIHZhciBfcHJvcHNfZGVmYXVsdFZhbHVlO1xuICAgIGxldCBbc2VsZWN0ZWRWYWx1ZSwgc2V0U2VsZWN0ZWRdID0gKDAsICRmUTJTRiR1c2VDb250cm9sbGVkU3RhdGUpKHByb3BzLnZhbHVlLCAoX3Byb3BzX2RlZmF1bHRWYWx1ZSA9IHByb3BzLmRlZmF1bHRWYWx1ZSkgIT09IG51bGwgJiYgX3Byb3BzX2RlZmF1bHRWYWx1ZSAhPT0gdm9pZCAwID8gX3Byb3BzX2RlZmF1bHRWYWx1ZSA6IG51bGwsIHByb3BzLm9uQ2hhbmdlKTtcbiAgICBsZXQgW2xhc3RGb2N1c2VkVmFsdWUsIHNldExhc3RGb2N1c2VkVmFsdWVdID0gKDAsICRmUTJTRiR1c2VTdGF0ZSkobnVsbCk7XG4gICAgbGV0IHZhbGlkYXRpb24gPSAoMCwgJGZRMlNGJHVzZUZvcm1WYWxpZGF0aW9uU3RhdGUpKHtcbiAgICAgICAgLi4ucHJvcHMsXG4gICAgICAgIHZhbHVlOiBzZWxlY3RlZFZhbHVlXG4gICAgfSk7XG4gICAgbGV0IHNldFNlbGVjdGVkVmFsdWUgPSAodmFsdWUpPT57XG4gICAgICAgIGlmICghcHJvcHMuaXNSZWFkT25seSAmJiAhcHJvcHMuaXNEaXNhYmxlZCkge1xuICAgICAgICAgICAgc2V0U2VsZWN0ZWQodmFsdWUpO1xuICAgICAgICAgICAgdmFsaWRhdGlvbi5jb21taXRWYWxpZGF0aW9uKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGxldCBpc0ludmFsaWQgPSB2YWxpZGF0aW9uLmRpc3BsYXlWYWxpZGF0aW9uLmlzSW52YWxpZDtcbiAgICByZXR1cm4ge1xuICAgICAgICAuLi52YWxpZGF0aW9uLFxuICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICBzZWxlY3RlZFZhbHVlOiBzZWxlY3RlZFZhbHVlLFxuICAgICAgICBzZXRTZWxlY3RlZFZhbHVlOiBzZXRTZWxlY3RlZFZhbHVlLFxuICAgICAgICBsYXN0Rm9jdXNlZFZhbHVlOiBsYXN0Rm9jdXNlZFZhbHVlLFxuICAgICAgICBzZXRMYXN0Rm9jdXNlZFZhbHVlOiBzZXRMYXN0Rm9jdXNlZFZhbHVlLFxuICAgICAgICBpc0Rpc2FibGVkOiBwcm9wcy5pc0Rpc2FibGVkIHx8IGZhbHNlLFxuICAgICAgICBpc1JlYWRPbmx5OiBwcm9wcy5pc1JlYWRPbmx5IHx8IGZhbHNlLFxuICAgICAgICBpc1JlcXVpcmVkOiBwcm9wcy5pc1JlcXVpcmVkIHx8IGZhbHNlLFxuICAgICAgICB2YWxpZGF0aW9uU3RhdGU6IHByb3BzLnZhbGlkYXRpb25TdGF0ZSB8fCAoaXNJbnZhbGlkID8gXCJpbnZhbGlkXCIgOiBudWxsKSxcbiAgICAgICAgaXNJbnZhbGlkOiBpc0ludmFsaWRcbiAgICB9O1xufVxuXG5cblxuXG5leHBvcnQgeyRhNTRjZGM1YzE5NDJiNjM5JGV4cG9ydCRiY2E5ZDAyNmY4ZTcwNGViIGFzIHVzZVJhZGlvR3JvdXBTdGF0ZX07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tb2R1bGUuanMubWFwXG4iXSwibmFtZXMiOlsidXNlRm9ybVZhbGlkYXRpb25TdGF0ZSIsIiRmUTJTRiR1c2VGb3JtVmFsaWRhdGlvblN0YXRlIiwidXNlQ29udHJvbGxlZFN0YXRlIiwiJGZRMlNGJHVzZUNvbnRyb2xsZWRTdGF0ZSIsInVzZU1lbW8iLCIkZlEyU0YkdXNlTWVtbyIsInVzZVN0YXRlIiwiJGZRMlNGJHVzZVN0YXRlIiwiJGE1NGNkYzVjMTk0MmI2MzkkdmFyJGluc3RhbmNlIiwiTWF0aCIsInJvdW5kIiwicmFuZG9tIiwiJGE1NGNkYzVjMTk0MmI2MzkkdmFyJGkiLCIkYTU0Y2RjNWMxOTQyYjYzOSRleHBvcnQkYmNhOWQwMjZmOGU3MDRlYiIsInByb3BzIiwibmFtZSIsIl9wcm9wc19kZWZhdWx0VmFsdWUiLCJzZWxlY3RlZFZhbHVlIiwic2V0U2VsZWN0ZWQiLCJ2YWx1ZSIsImRlZmF1bHRWYWx1ZSIsIm9uQ2hhbmdlIiwibGFzdEZvY3VzZWRWYWx1ZSIsInNldExhc3RGb2N1c2VkVmFsdWUiLCJ2YWxpZGF0aW9uIiwic2V0U2VsZWN0ZWRWYWx1ZSIsImlzUmVhZE9ubHkiLCJpc0Rpc2FibGVkIiwiY29tbWl0VmFsaWRhdGlvbiIsImlzSW52YWxpZCIsImRpc3BsYXlWYWxpZGF0aW9uIiwiaXNSZXF1aXJlZCIsInZhbGlkYXRpb25TdGF0ZSIsInVzZVJhZGlvR3JvdXBTdGF0ZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-stately/radio/dist/import.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-stately/selection/dist/import.mjs":
/*!***************************************************************!*\
  !*** ./node_modules/@react-stately/selection/dist/import.mjs ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SelectionManager: () => (/* binding */ $d496c0a20b6e58ec$export$6c8a5aaad13c9852),\n/* harmony export */   useMultipleSelectionState: () => (/* binding */ $7af3f5b51489e0b5$export$253fe78d46329472)\n/* harmony export */ });\n/* harmony import */ var _react_stately_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @react-stately/utils */ \"(ssr)/./node_modules/@react-stately/utils/dist/import.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _react_stately_collections__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @react-stately/collections */ \"(ssr)/./node_modules/@react-stately/collections/dist/import.mjs\");\n\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ class $e40ea825a81a3709$export$52baac22726c72bf extends Set {\n    constructor(keys, anchorKey, currentKey){\n        super(keys);\n        if (keys instanceof $e40ea825a81a3709$export$52baac22726c72bf) {\n            this.anchorKey = anchorKey || keys.anchorKey;\n            this.currentKey = currentKey || keys.currentKey;\n        } else {\n            this.anchorKey = anchorKey;\n            this.currentKey = currentKey;\n        }\n    }\n}\nfunction $7af3f5b51489e0b5$var$equalSets(setA, setB) {\n    if (setA.size !== setB.size) return false;\n    for (let item of setA){\n        if (!setB.has(item)) return false;\n    }\n    return true;\n}\nfunction $7af3f5b51489e0b5$export$253fe78d46329472(props) {\n    let { selectionMode: selectionMode = \"none\", disallowEmptySelection: disallowEmptySelection, allowDuplicateSelectionEvents: allowDuplicateSelectionEvents, selectionBehavior: selectionBehaviorProp = \"toggle\", disabledBehavior: disabledBehavior = \"all\" } = props;\n    // We want synchronous updates to `isFocused` and `focusedKey` after their setters are called.\n    // But we also need to trigger a react re-render. So, we have both a ref (sync) and state (async).\n    let isFocusedRef = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    let [, setFocused] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    let focusedKeyRef = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    let childFocusStrategyRef = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    let [, setFocusedKey] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    let selectedKeysProp = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>$7af3f5b51489e0b5$var$convertSelection(props.selectedKeys), [\n        props.selectedKeys\n    ]);\n    let defaultSelectedKeys = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>$7af3f5b51489e0b5$var$convertSelection(props.defaultSelectedKeys, new (0, $e40ea825a81a3709$export$52baac22726c72bf)()), [\n        props.defaultSelectedKeys\n    ]);\n    let [selectedKeys, setSelectedKeys] = (0, _react_stately_utils__WEBPACK_IMPORTED_MODULE_1__.useControlledState)(selectedKeysProp, defaultSelectedKeys, props.onSelectionChange);\n    let disabledKeysProp = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>props.disabledKeys ? new Set(props.disabledKeys) : new Set(), [\n        props.disabledKeys\n    ]);\n    let [selectionBehavior, setSelectionBehavior] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(selectionBehaviorProp);\n    // If the selectionBehavior prop is set to replace, but the current state is toggle (e.g. due to long press\n    // to enter selection mode on touch), and the selection becomes empty, reset the selection behavior.\n    if (selectionBehaviorProp === \"replace\" && selectionBehavior === \"toggle\" && typeof selectedKeys === \"object\" && selectedKeys.size === 0) setSelectionBehavior(\"replace\");\n    // If the selectionBehavior prop changes, update the state as well.\n    let lastSelectionBehavior = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)(selectionBehaviorProp);\n    (0, react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (selectionBehaviorProp !== lastSelectionBehavior.current) {\n            setSelectionBehavior(selectionBehaviorProp);\n            lastSelectionBehavior.current = selectionBehaviorProp;\n        }\n    }, [\n        selectionBehaviorProp\n    ]);\n    return {\n        selectionMode: selectionMode,\n        disallowEmptySelection: disallowEmptySelection,\n        selectionBehavior: selectionBehavior,\n        setSelectionBehavior: setSelectionBehavior,\n        get isFocused () {\n            return isFocusedRef.current;\n        },\n        setFocused (f) {\n            isFocusedRef.current = f;\n            setFocused(f);\n        },\n        get focusedKey () {\n            return focusedKeyRef.current;\n        },\n        get childFocusStrategy () {\n            return childFocusStrategyRef.current;\n        },\n        setFocusedKey (k, childFocusStrategy = \"first\") {\n            focusedKeyRef.current = k;\n            childFocusStrategyRef.current = childFocusStrategy;\n            setFocusedKey(k);\n        },\n        selectedKeys: selectedKeys,\n        setSelectedKeys (keys) {\n            if (allowDuplicateSelectionEvents || !$7af3f5b51489e0b5$var$equalSets(keys, selectedKeys)) setSelectedKeys(keys);\n        },\n        disabledKeys: disabledKeysProp,\n        disabledBehavior: disabledBehavior\n    };\n}\nfunction $7af3f5b51489e0b5$var$convertSelection(selection, defaultValue) {\n    if (!selection) return defaultValue;\n    return selection === \"all\" ? \"all\" : new (0, $e40ea825a81a3709$export$52baac22726c72bf)(selection);\n}\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ class $d496c0a20b6e58ec$export$6c8a5aaad13c9852 {\n    /**\n   * The type of selection that is allowed in the collection.\n   */ get selectionMode() {\n        return this.state.selectionMode;\n    }\n    /**\n   * Whether the collection allows empty selection.\n   */ get disallowEmptySelection() {\n        return this.state.disallowEmptySelection;\n    }\n    /**\n   * The selection behavior for the collection.\n   */ get selectionBehavior() {\n        return this.state.selectionBehavior;\n    }\n    /**\n   * Sets the selection behavior for the collection.\n   */ setSelectionBehavior(selectionBehavior) {\n        this.state.setSelectionBehavior(selectionBehavior);\n    }\n    /**\n   * Whether the collection is currently focused.\n   */ get isFocused() {\n        return this.state.isFocused;\n    }\n    /**\n   * Sets whether the collection is focused.\n   */ setFocused(isFocused) {\n        this.state.setFocused(isFocused);\n    }\n    /**\n   * The current focused key in the collection.\n   */ get focusedKey() {\n        return this.state.focusedKey;\n    }\n    /** Whether the first or last child of the focused key should receive focus. */ get childFocusStrategy() {\n        return this.state.childFocusStrategy;\n    }\n    /**\n   * Sets the focused key.\n   */ setFocusedKey(key, childFocusStrategy) {\n        if (key == null || this.collection.getItem(key)) this.state.setFocusedKey(key, childFocusStrategy);\n    }\n    /**\n   * The currently selected keys in the collection.\n   */ get selectedKeys() {\n        return this.state.selectedKeys === \"all\" ? new Set(this.getSelectAllKeys()) : this.state.selectedKeys;\n    }\n    /**\n   * The raw selection value for the collection.\n   * Either 'all' for select all, or a set of keys.\n   */ get rawSelection() {\n        return this.state.selectedKeys;\n    }\n    /**\n   * Returns whether a key is selected.\n   */ isSelected(key) {\n        if (this.state.selectionMode === \"none\") return false;\n        key = this.getKey(key);\n        return this.state.selectedKeys === \"all\" ? this.canSelectItem(key) : this.state.selectedKeys.has(key);\n    }\n    /**\n   * Whether the selection is empty.\n   */ get isEmpty() {\n        return this.state.selectedKeys !== \"all\" && this.state.selectedKeys.size === 0;\n    }\n    /**\n   * Whether all items in the collection are selected.\n   */ get isSelectAll() {\n        if (this.isEmpty) return false;\n        if (this.state.selectedKeys === \"all\") return true;\n        if (this._isSelectAll != null) return this._isSelectAll;\n        let allKeys = this.getSelectAllKeys();\n        let selectedKeys = this.state.selectedKeys;\n        this._isSelectAll = allKeys.every((k)=>selectedKeys.has(k));\n        return this._isSelectAll;\n    }\n    get firstSelectedKey() {\n        let first = null;\n        for (let key of this.state.selectedKeys){\n            let item = this.collection.getItem(key);\n            if (!first || item && (0, _react_stately_collections__WEBPACK_IMPORTED_MODULE_2__.compareNodeOrder)(this.collection, item, first) < 0) first = item;\n        }\n        return first === null || first === void 0 ? void 0 : first.key;\n    }\n    get lastSelectedKey() {\n        let last = null;\n        for (let key of this.state.selectedKeys){\n            let item = this.collection.getItem(key);\n            if (!last || item && (0, _react_stately_collections__WEBPACK_IMPORTED_MODULE_2__.compareNodeOrder)(this.collection, item, last) > 0) last = item;\n        }\n        return last === null || last === void 0 ? void 0 : last.key;\n    }\n    get disabledKeys() {\n        return this.state.disabledKeys;\n    }\n    get disabledBehavior() {\n        return this.state.disabledBehavior;\n    }\n    /**\n   * Extends the selection to the given key.\n   */ extendSelection(toKey) {\n        if (this.selectionMode === \"none\") return;\n        if (this.selectionMode === \"single\") {\n            this.replaceSelection(toKey);\n            return;\n        }\n        toKey = this.getKey(toKey);\n        let selection;\n        // Only select the one key if coming from a select all.\n        if (this.state.selectedKeys === \"all\") selection = new (0, $e40ea825a81a3709$export$52baac22726c72bf)([\n            toKey\n        ], toKey, toKey);\n        else {\n            let selectedKeys = this.state.selectedKeys;\n            let anchorKey = selectedKeys.anchorKey || toKey;\n            selection = new (0, $e40ea825a81a3709$export$52baac22726c72bf)(selectedKeys, anchorKey, toKey);\n            for (let key of this.getKeyRange(anchorKey, selectedKeys.currentKey || toKey))selection.delete(key);\n            for (let key of this.getKeyRange(toKey, anchorKey))if (this.canSelectItem(key)) selection.add(key);\n        }\n        this.state.setSelectedKeys(selection);\n    }\n    getKeyRange(from, to) {\n        let fromItem = this.collection.getItem(from);\n        let toItem = this.collection.getItem(to);\n        if (fromItem && toItem) {\n            if ((0, _react_stately_collections__WEBPACK_IMPORTED_MODULE_2__.compareNodeOrder)(this.collection, fromItem, toItem) <= 0) return this.getKeyRangeInternal(from, to);\n            return this.getKeyRangeInternal(to, from);\n        }\n        return [];\n    }\n    getKeyRangeInternal(from, to) {\n        let keys = [];\n        let key = from;\n        while(key){\n            let item = this.collection.getItem(key);\n            if (item && item.type === \"item\" || item.type === \"cell\" && this.allowsCellSelection) keys.push(key);\n            if (key === to) return keys;\n            key = this.collection.getKeyAfter(key);\n        }\n        return [];\n    }\n    getKey(key) {\n        let item = this.collection.getItem(key);\n        if (!item) return key;\n        // If cell selection is allowed, just return the key.\n        if (item.type === \"cell\" && this.allowsCellSelection) return key;\n        // Find a parent item to select\n        while(item.type !== \"item\" && item.parentKey != null)item = this.collection.getItem(item.parentKey);\n        if (!item || item.type !== \"item\") return null;\n        return item.key;\n    }\n    /**\n   * Toggles whether the given key is selected.\n   */ toggleSelection(key) {\n        if (this.selectionMode === \"none\") return;\n        if (this.selectionMode === \"single\" && !this.isSelected(key)) {\n            this.replaceSelection(key);\n            return;\n        }\n        key = this.getKey(key);\n        if (key == null) return;\n        let keys = new (0, $e40ea825a81a3709$export$52baac22726c72bf)(this.state.selectedKeys === \"all\" ? this.getSelectAllKeys() : this.state.selectedKeys);\n        if (keys.has(key)) keys.delete(key);\n        else if (this.canSelectItem(key)) {\n            keys.add(key);\n            keys.anchorKey = key;\n            keys.currentKey = key;\n        }\n        if (this.disallowEmptySelection && keys.size === 0) return;\n        this.state.setSelectedKeys(keys);\n    }\n    /**\n   * Replaces the selection with only the given key.\n   */ replaceSelection(key) {\n        if (this.selectionMode === \"none\") return;\n        key = this.getKey(key);\n        if (key == null) return;\n        let selection = this.canSelectItem(key) ? new (0, $e40ea825a81a3709$export$52baac22726c72bf)([\n            key\n        ], key, key) : new (0, $e40ea825a81a3709$export$52baac22726c72bf)();\n        this.state.setSelectedKeys(selection);\n    }\n    /**\n   * Replaces the selection with the given keys.\n   */ setSelectedKeys(keys) {\n        if (this.selectionMode === \"none\") return;\n        let selection = new (0, $e40ea825a81a3709$export$52baac22726c72bf)();\n        for (let key of keys){\n            key = this.getKey(key);\n            if (key != null) {\n                selection.add(key);\n                if (this.selectionMode === \"single\") break;\n            }\n        }\n        this.state.setSelectedKeys(selection);\n    }\n    getSelectAllKeys() {\n        let keys = [];\n        let addKeys = (key)=>{\n            while(key){\n                if (this.canSelectItem(key)) {\n                    let item = this.collection.getItem(key);\n                    if (item.type === \"item\") keys.push(key);\n                    // Add child keys. If cell selection is allowed, then include item children too.\n                    if (item.hasChildNodes && (this.allowsCellSelection || item.type !== \"item\")) addKeys((0, _react_stately_collections__WEBPACK_IMPORTED_MODULE_2__.getFirstItem)((0, _react_stately_collections__WEBPACK_IMPORTED_MODULE_2__.getChildNodes)(item, this.collection)).key);\n                }\n                key = this.collection.getKeyAfter(key);\n            }\n        };\n        addKeys(this.collection.getFirstKey());\n        return keys;\n    }\n    /**\n   * Selects all items in the collection.\n   */ selectAll() {\n        if (!this.isSelectAll && this.selectionMode === \"multiple\") this.state.setSelectedKeys(\"all\");\n    }\n    /**\n   * Removes all keys from the selection.\n   */ clearSelection() {\n        if (!this.disallowEmptySelection && (this.state.selectedKeys === \"all\" || this.state.selectedKeys.size > 0)) this.state.setSelectedKeys(new (0, $e40ea825a81a3709$export$52baac22726c72bf)());\n    }\n    /**\n   * Toggles between select all and an empty selection.\n   */ toggleSelectAll() {\n        if (this.isSelectAll) this.clearSelection();\n        else this.selectAll();\n    }\n    select(key, e) {\n        if (this.selectionMode === \"none\") return;\n        if (this.selectionMode === \"single\") {\n            if (this.isSelected(key) && !this.disallowEmptySelection) this.toggleSelection(key);\n            else this.replaceSelection(key);\n        } else if (this.selectionBehavior === \"toggle\" || e && (e.pointerType === \"touch\" || e.pointerType === \"virtual\")) this.toggleSelection(key);\n        else this.replaceSelection(key);\n    }\n    /**\n   * Returns whether the current selection is equal to the given selection.\n   */ isSelectionEqual(selection) {\n        if (selection === this.state.selectedKeys) return true;\n        // Check if the set of keys match.\n        let selectedKeys = this.selectedKeys;\n        if (selection.size !== selectedKeys.size) return false;\n        for (let key of selection){\n            if (!selectedKeys.has(key)) return false;\n        }\n        for (let key of selectedKeys){\n            if (!selection.has(key)) return false;\n        }\n        return true;\n    }\n    canSelectItem(key) {\n        if (this.state.selectionMode === \"none\" || this.state.disabledKeys.has(key)) return false;\n        let item = this.collection.getItem(key);\n        if (!item || item.type === \"cell\" && !this.allowsCellSelection) return false;\n        return true;\n    }\n    isDisabled(key) {\n        return this.state.disabledKeys.has(key) && this.state.disabledBehavior === \"all\";\n    }\n    isLink(key) {\n        var _this_collection_getItem_props, _this_collection_getItem;\n        return !!((_this_collection_getItem = this.collection.getItem(key)) === null || _this_collection_getItem === void 0 ? void 0 : (_this_collection_getItem_props = _this_collection_getItem.props) === null || _this_collection_getItem_props === void 0 ? void 0 : _this_collection_getItem_props.href);\n    }\n    constructor(collection, state, options){\n        this.collection = collection;\n        this.state = state;\n        var _options_allowsCellSelection;\n        this.allowsCellSelection = (_options_allowsCellSelection = options === null || options === void 0 ? void 0 : options.allowsCellSelection) !== null && _options_allowsCellSelection !== void 0 ? _options_allowsCellSelection : false;\n        this._isSelectAll = null;\n    }\n}\n //# sourceMappingURL=module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXN0YXRlbHkvc2VsZWN0aW9uL2Rpc3QvaW1wb3J0Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFxRjtBQUNnRDtBQUM4QjtBQUVuSzs7Ozs7Ozs7OztDQVVDLEdBQUc7Ozs7Ozs7Ozs7Q0FVSCxHQUFHOzs7Ozs7Ozs7O0NBVUgsR0FBRyxNQUFNZ0Isa0RBQWtEQztJQUN4REMsWUFBWUMsSUFBSSxFQUFFQyxTQUFTLEVBQUVDLFVBQVUsQ0FBQztRQUNwQyxLQUFLLENBQUNGO1FBQ04sSUFBSUEsZ0JBQWdCSCwyQ0FBMkM7WUFDM0QsSUFBSSxDQUFDSSxTQUFTLEdBQUdBLGFBQWFELEtBQUtDLFNBQVM7WUFDNUMsSUFBSSxDQUFDQyxVQUFVLEdBQUdBLGNBQWNGLEtBQUtFLFVBQVU7UUFDbkQsT0FBTztZQUNILElBQUksQ0FBQ0QsU0FBUyxHQUFHQTtZQUNqQixJQUFJLENBQUNDLFVBQVUsR0FBR0E7UUFDdEI7SUFDSjtBQUNKO0FBS0EsU0FBU0MsZ0NBQWdDQyxJQUFJLEVBQUVDLElBQUk7SUFDL0MsSUFBSUQsS0FBS0UsSUFBSSxLQUFLRCxLQUFLQyxJQUFJLEVBQUUsT0FBTztJQUNwQyxLQUFLLElBQUlDLFFBQVFILEtBQUs7UUFDbEIsSUFBSSxDQUFDQyxLQUFLRyxHQUFHLENBQUNELE9BQU8sT0FBTztJQUNoQztJQUNBLE9BQU87QUFDWDtBQUNBLFNBQVNFLDBDQUEwQ0MsS0FBSztJQUNwRCxJQUFJLEVBQUVDLGVBQWVBLGdCQUFnQixNQUFNLEVBQUVDLHdCQUF3QkEsc0JBQXNCLEVBQUVDLCtCQUErQkEsNkJBQTZCLEVBQUVDLG1CQUFtQkMsd0JBQXdCLFFBQVEsRUFBRUMsa0JBQWtCQSxtQkFBbUIsS0FBSyxFQUFFLEdBQUdOO0lBQy9QLDhGQUE4RjtJQUM5RixrR0FBa0c7SUFDbEcsSUFBSU8sZUFBZSxDQUFDLEdBQUdqQyx5Q0FBWSxFQUFHO0lBQ3RDLElBQUksR0FBR2tDLFdBQVcsR0FBRyxDQUFD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YWNrOi8vbmV4dC1mbGFzay8uL25vZGVfbW9kdWxlcy9AcmVhY3Qtc3RhdGVseS9zZWxlY3Rpb24vZGlzdC9pbXBvcnQubWpzP2FlZDEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHt1c2VDb250cm9sbGVkU3RhdGUgYXMgJFFzdG8yJHVzZUNvbnRyb2xsZWRTdGF0ZX0gZnJvbSBcIkByZWFjdC1zdGF0ZWx5L3V0aWxzXCI7XG5pbXBvcnQge3VzZVJlZiBhcyAkUXN0bzIkdXNlUmVmLCB1c2VTdGF0ZSBhcyAkUXN0bzIkdXNlU3RhdGUsIHVzZU1lbW8gYXMgJFFzdG8yJHVzZU1lbW8sIHVzZUVmZmVjdCBhcyAkUXN0bzIkdXNlRWZmZWN0fSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7Y29tcGFyZU5vZGVPcmRlciBhcyAkUXN0bzIkY29tcGFyZU5vZGVPcmRlciwgZ2V0Rmlyc3RJdGVtIGFzICRRc3RvMiRnZXRGaXJzdEl0ZW0sIGdldENoaWxkTm9kZXMgYXMgJFFzdG8yJGdldENoaWxkTm9kZXN9IGZyb20gXCJAcmVhY3Qtc3RhdGVseS9jb2xsZWN0aW9uc1wiO1xuXG4vKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIC8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyBjbGFzcyAkZTQwZWE4MjVhODFhMzcwOSRleHBvcnQkNTJiYWFjMjI3MjZjNzJiZiBleHRlbmRzIFNldCB7XG4gICAgY29uc3RydWN0b3Ioa2V5cywgYW5jaG9yS2V5LCBjdXJyZW50S2V5KXtcbiAgICAgICAgc3VwZXIoa2V5cyk7XG4gICAgICAgIGlmIChrZXlzIGluc3RhbmNlb2YgJGU0MGVhODI1YTgxYTM3MDkkZXhwb3J0JDUyYmFhYzIyNzI2YzcyYmYpIHtcbiAgICAgICAgICAgIHRoaXMuYW5jaG9yS2V5ID0gYW5jaG9yS2V5IHx8IGtleXMuYW5jaG9yS2V5O1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50S2V5ID0gY3VycmVudEtleSB8fCBrZXlzLmN1cnJlbnRLZXk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmFuY2hvcktleSA9IGFuY2hvcktleTtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudEtleSA9IGN1cnJlbnRLZXk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cblxuXG5cbmZ1bmN0aW9uICQ3YWYzZjViNTE0ODllMGI1JHZhciRlcXVhbFNldHMoc2V0QSwgc2V0Qikge1xuICAgIGlmIChzZXRBLnNpemUgIT09IHNldEIuc2l6ZSkgcmV0dXJuIGZhbHNlO1xuICAgIGZvciAobGV0IGl0ZW0gb2Ygc2V0QSl7XG4gICAgICAgIGlmICghc2V0Qi5oYXMoaXRlbSkpIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiAkN2FmM2Y1YjUxNDg5ZTBiNSRleHBvcnQkMjUzZmU3OGQ0NjMyOTQ3Mihwcm9wcykge1xuICAgIGxldCB7IHNlbGVjdGlvbk1vZGU6IHNlbGVjdGlvbk1vZGUgPSBcIm5vbmVcIiwgZGlzYWxsb3dFbXB0eVNlbGVjdGlvbjogZGlzYWxsb3dFbXB0eVNlbGVjdGlvbiwgYWxsb3dEdXBsaWNhdGVTZWxlY3Rpb25FdmVudHM6IGFsbG93RHVwbGljYXRlU2VsZWN0aW9uRXZlbnRzLCBzZWxlY3Rpb25CZWhhdmlvcjogc2VsZWN0aW9uQmVoYXZpb3JQcm9wID0gXCJ0b2dnbGVcIiwgZGlzYWJsZWRCZWhhdmlvcjogZGlzYWJsZWRCZWhhdmlvciA9IFwiYWxsXCIgfSA9IHByb3BzO1xuICAgIC8vIFdlIHdhbnQgc3luY2hyb25vdXMgdXBkYXRlcyB0byBgaXNGb2N1c2VkYCBhbmQgYGZvY3VzZWRLZXlgIGFmdGVyIHRoZWlyIHNldHRlcnMgYXJlIGNhbGxlZC5cbiAgICAvLyBCdXQgd2UgYWxzbyBuZWVkIHRvIHRyaWdnZXIgYSByZWFjdCByZS1yZW5kZXIuIFNvLCB3ZSBoYXZlIGJvdGggYSByZWYgKHN5bmMpIGFuZCBzdGF0ZSAoYXN5bmMpLlxuICAgIGxldCBpc0ZvY3VzZWRSZWYgPSAoMCwgJFFzdG8yJHVzZVJlZikoZmFsc2UpO1xuICAgIGxldCBbLCBzZXRGb2N1c2VkXSA9ICgwLCAkUXN0bzIkdXNlU3RhdGUpKGZhbHNlKTtcbiAgICBsZXQgZm9jdXNlZEtleVJlZiA9ICgwLCAkUXN0bzIkdXNlUmVmKShudWxsKTtcbiAgICBsZXQgY2hpbGRGb2N1c1N0cmF0ZWd5UmVmID0gKDAsICRRc3RvMiR1c2VSZWYpKG51bGwpO1xuICAgIGxldCBbLCBzZXRGb2N1c2VkS2V5XSA9ICgwLCAkUXN0bzIkdXNlU3RhdGUpKG51bGwpO1xuICAgIGxldCBzZWxlY3RlZEtleXNQcm9wID0gKDAsICRRc3RvMiR1c2VNZW1vKSgoKT0+JDdhZjNmNWI1MTQ4OWUwYjUkdmFyJGNvbnZlcnRTZWxlY3Rpb24ocHJvcHMuc2VsZWN0ZWRLZXlzKSwgW1xuICAgICAgICBwcm9wcy5zZWxlY3RlZEtleXNcbiAgICBdKTtcbiAgICBsZXQgZGVmYXVsdFNlbGVjdGVkS2V5cyA9ICgwLCAkUXN0bzIkdXNlTWVtbykoKCk9PiQ3YWYzZjViNTE0ODllMGI1JHZhciRjb252ZXJ0U2VsZWN0aW9uKHByb3BzLmRlZmF1bHRTZWxlY3RlZEtleXMsIG5ldyAoMCwgJGU0MGVhODI1YTgxYTM3MDkkZXhwb3J0JDUyYmFhYzIyNzI2YzcyYmYpKCkpLCBbXG4gICAgICAgIHByb3BzLmRlZmF1bHRTZWxlY3RlZEtleXNcbiAgICBdKTtcbiAgICBsZXQgW3NlbGVjdGVkS2V5cywgc2V0U2VsZWN0ZWRLZXlzXSA9ICgwLCAkUXN0bzIkdXNlQ29udHJvbGxlZFN0YXRlKShzZWxlY3RlZEtleXNQcm9wLCBkZWZhdWx0U2VsZWN0ZWRLZXlzLCBwcm9wcy5vblNlbGVjdGlvbkNoYW5nZSk7XG4gICAgbGV0IGRpc2FibGVkS2V5c1Byb3AgPSAoMCwgJFFzdG8yJHVzZU1lbW8pKCgpPT5wcm9wcy5kaXNhYmxlZEtleXMgPyBuZXcgU2V0KHByb3BzLmRpc2FibGVkS2V5cykgOiBuZXcgU2V0KCksIFtcbiAgICAgICAgcHJvcHMuZGlzYWJsZWRLZXlzXG4gICAgXSk7XG4gICAgbGV0IFtzZWxlY3Rpb25CZWhhdmlvciwgc2V0U2VsZWN0aW9uQmVoYXZpb3JdID0gKDAsICRRc3RvMiR1c2VTdGF0ZSkoc2VsZWN0aW9uQmVoYXZpb3JQcm9wKTtcbiAgICAvLyBJZiB0aGUgc2VsZWN0aW9uQmVoYXZpb3IgcHJvcCBpcyBzZXQgdG8gcmVwbGFjZSwgYnV0IHRoZSBjdXJyZW50IHN0YXRlIGlzIHRvZ2dsZSAoZS5nLiBkdWUgdG8gbG9uZyBwcmVzc1xuICAgIC8vIHRvIGVudGVyIHNlbGVjdGlvbiBtb2RlIG9uIHRvdWNoKSwgYW5kIHRoZSBzZWxlY3Rpb24gYmVjb21lcyBlbXB0eSwgcmVzZXQgdGhlIHNlbGVjdGlvbiBiZWhhdmlvci5cbiAgICBpZiAoc2VsZWN0aW9uQmVoYXZpb3JQcm9wID09PSBcInJlcGxhY2VcIiAmJiBzZWxlY3Rpb25CZWhhdmlvciA9PT0gXCJ0b2dnbGVcIiAmJiB0eXBlb2Ygc2VsZWN0ZWRLZXlzID09PSBcIm9iamVjdFwiICYmIHNlbGVjdGVkS2V5cy5zaXplID09PSAwKSBzZXRTZWxlY3Rpb25CZWhhdmlvcihcInJlcGxhY2VcIik7XG4gICAgLy8gSWYgdGhlIHNlbGVjdGlvbkJlaGF2aW9yIHByb3AgY2hhbmdlcywgdXBkYXRlIHRoZSBzdGF0ZSBhcyB3ZWxsLlxuICAgIGxldCBsYXN0U2VsZWN0aW9uQmVoYXZpb3IgPSAoMCwgJFFzdG8yJHVzZVJlZikoc2VsZWN0aW9uQmVoYXZpb3JQcm9wKTtcbiAgICAoMCwgJFFzdG8yJHVzZUVmZmVjdCkoKCk9PntcbiAgICAgICAgaWYgKHNlbGVjdGlvbkJlaGF2aW9yUHJvcCAhPT0gbGFzdFNlbGVjdGlvbkJlaGF2aW9yLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIHNldFNlbGVjdGlvbkJlaGF2aW9yKHNlbGVjdGlvbkJlaGF2aW9yUHJvcCk7XG4gICAgICAgICAgICBsYXN0U2VsZWN0aW9uQmVoYXZpb3IuY3VycmVudCA9IHNlbGVjdGlvbkJlaGF2aW9yUHJvcDtcbiAgICAgICAgfVxuICAgIH0sIFtcbiAgICAgICAgc2VsZWN0aW9uQmVoYXZpb3JQcm9wXG4gICAgXSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc2VsZWN0aW9uTW9kZTogc2VsZWN0aW9uTW9kZSxcbiAgICAgICAgZGlzYWxsb3dFbXB0eVNlbGVjdGlvbjogZGlzYWxsb3dFbXB0eVNlbGVjdGlvbixcbiAgICAgICAgc2VsZWN0aW9uQmVoYXZpb3I6IHNlbGVjdGlvbkJlaGF2aW9yLFxuICAgICAgICBzZXRTZWxlY3Rpb25CZWhhdmlvcjogc2V0U2VsZWN0aW9uQmVoYXZpb3IsXG4gICAgICAgIGdldCBpc0ZvY3VzZWQgKCkge1xuICAgICAgICAgICAgcmV0dXJuIGlzRm9jdXNlZFJlZi5jdXJyZW50O1xuICAgICAgICB9LFxuICAgICAgICBzZXRGb2N1c2VkIChmKSB7XG4gICAgICAgICAgICBpc0ZvY3VzZWRSZWYuY3VycmVudCA9IGY7XG4gICAgICAgICAgICBzZXRGb2N1c2VkKGYpO1xuICAgICAgICB9LFxuICAgICAgICBnZXQgZm9jdXNlZEtleSAoKSB7XG4gICAgICAgICAgICByZXR1cm4gZm9jdXNlZEtleVJlZi5jdXJyZW50O1xuICAgICAgICB9LFxuICAgICAgICBnZXQgY2hpbGRGb2N1c1N0cmF0ZWd5ICgpIHtcbiAgICAgICAgICAgIHJldHVybiBjaGlsZEZvY3VzU3RyYXRlZ3lSZWYuY3VycmVudDtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0Rm9jdXNlZEtleSAoaywgY2hpbGRGb2N1c1N0cmF0ZWd5ID0gXCJmaXJzdFwiKSB7XG4gICAgICAgICAgICBmb2N1c2VkS2V5UmVmLmN1cnJlbnQgPSBrO1xuICAgICAgICAgICAgY2hpbGRGb2N1c1N0cmF0ZWd5UmVmLmN1cnJlbnQgPSBjaGlsZEZvY3VzU3RyYXRlZ3k7XG4gICAgICAgICAgICBzZXRGb2N1c2VkS2V5KGspO1xuICAgICAgICB9LFxuICAgICAgICBzZWxlY3RlZEtleXM6IHNlbGVjdGVkS2V5cyxcbiAgICAgICAgc2V0U2VsZWN0ZWRLZXlzIChrZXlzKSB7XG4gICAgICAgICAgICBpZiAoYWxsb3dEdXBsaWNhdGVTZWxlY3Rpb25FdmVudHMgfHwgISQ3YWYzZjViNTE0ODllMGI1JHZhciRlcXVhbFNldHMoa2V5cywgc2VsZWN0ZWRLZXlzKSkgc2V0U2VsZWN0ZWRLZXlzKGtleXMpO1xuICAgICAgICB9LFxuICAgICAgICBkaXNhYmxlZEtleXM6IGRpc2FibGVkS2V5c1Byb3AsXG4gICAgICAgIGRpc2FibGVkQmVoYXZpb3I6IGRpc2FibGVkQmVoYXZpb3JcbiAgICB9O1xufVxuZnVuY3Rpb24gJDdhZjNmNWI1MTQ4OWUwYjUkdmFyJGNvbnZlcnRTZWxlY3Rpb24oc2VsZWN0aW9uLCBkZWZhdWx0VmFsdWUpIHtcbiAgICBpZiAoIXNlbGVjdGlvbikgcmV0dXJuIGRlZmF1bHRWYWx1ZTtcbiAgICByZXR1cm4gc2VsZWN0aW9uID09PSBcImFsbFwiID8gXCJhbGxcIiA6IG5ldyAoMCwgJGU0MGVhODI1YTgxYTM3MDkkZXhwb3J0JDUyYmFhYzIyNzI2YzcyYmYpKHNlbGVjdGlvbik7XG59XG5cblxuLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIFxuXG5jbGFzcyAkZDQ5NmMwYTIwYjZlNThlYyRleHBvcnQkNmM4YTVhYWFkMTNjOTg1MiB7XG4gICAgLyoqXG4gICAqIFRoZSB0eXBlIG9mIHNlbGVjdGlvbiB0aGF0IGlzIGFsbG93ZWQgaW4gdGhlIGNvbGxlY3Rpb24uXG4gICAqLyBnZXQgc2VsZWN0aW9uTW9kZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGUuc2VsZWN0aW9uTW9kZTtcbiAgICB9XG4gICAgLyoqXG4gICAqIFdoZXRoZXIgdGhlIGNvbGxlY3Rpb24gYWxsb3dzIGVtcHR5IHNlbGVjdGlvbi5cbiAgICovIGdldCBkaXNhbGxvd0VtcHR5U2VsZWN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZS5kaXNhbGxvd0VtcHR5U2VsZWN0aW9uO1xuICAgIH1cbiAgICAvKipcbiAgICogVGhlIHNlbGVjdGlvbiBiZWhhdmlvciBmb3IgdGhlIGNvbGxlY3Rpb24uXG4gICAqLyBnZXQgc2VsZWN0aW9uQmVoYXZpb3IoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlLnNlbGVjdGlvbkJlaGF2aW9yO1xuICAgIH1cbiAgICAvKipcbiAgICogU2V0cyB0aGUgc2VsZWN0aW9uIGJlaGF2aW9yIGZvciB0aGUgY29sbGVjdGlvbi5cbiAgICovIHNldFNlbGVjdGlvbkJlaGF2aW9yKHNlbGVjdGlvbkJlaGF2aW9yKSB7XG4gICAgICAgIHRoaXMuc3RhdGUuc2V0U2VsZWN0aW9uQmVoYXZpb3Ioc2VsZWN0aW9uQmVoYXZpb3IpO1xuICAgIH1cbiAgICAvKipcbiAgICogV2hldGhlciB0aGUgY29sbGVjdGlvbiBpcyBjdXJyZW50bHkgZm9jdXNlZC5cbiAgICovIGdldCBpc0ZvY3VzZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlLmlzRm9jdXNlZDtcbiAgICB9XG4gICAgLyoqXG4gICAqIFNldHMgd2hldGhlciB0aGUgY29sbGVjdGlvbiBpcyBmb2N1c2VkLlxuICAgKi8gc2V0Rm9jdXNlZChpc0ZvY3VzZWQpIHtcbiAgICAgICAgdGhpcy5zdGF0ZS5zZXRGb2N1c2VkKGlzRm9jdXNlZCk7XG4gICAgfVxuICAgIC8qKlxuICAgKiBUaGUgY3VycmVudCBmb2N1c2VkIGtleSBpbiB0aGUgY29sbGVjdGlvbi5cbiAgICovIGdldCBmb2N1c2VkS2V5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZS5mb2N1c2VkS2V5O1xuICAgIH1cbiAgICAvKiogV2hldGhlciB0aGUgZmlyc3Qgb3IgbGFzdCBjaGlsZCBvZiB0aGUgZm9jdXNlZCBrZXkgc2hvdWxkIHJlY2VpdmUgZm9jdXMuICovIGdldCBjaGlsZEZvY3VzU3RyYXRlZ3koKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlLmNoaWxkRm9jdXNTdHJhdGVneTtcbiAgICB9XG4gICAgLyoqXG4gICAqIFNldHMgdGhlIGZvY3VzZWQga2V5LlxuICAgKi8gc2V0Rm9jdXNlZEtleShrZXksIGNoaWxkRm9jdXNTdHJhdGVneSkge1xuICAgICAgICBpZiAoa2V5ID09IG51bGwgfHwgdGhpcy5jb2xsZWN0aW9uLmdldEl0ZW0oa2V5KSkgdGhpcy5zdGF0ZS5zZXRGb2N1c2VkS2V5KGtleSwgY2hpbGRGb2N1c1N0cmF0ZWd5KTtcbiAgICB9XG4gICAgLyoqXG4gICAqIFRoZSBjdXJyZW50bHkgc2VsZWN0ZWQga2V5cyBpbiB0aGUgY29sbGVjdGlvbi5cbiAgICovIGdldCBzZWxlY3RlZEtleXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlLnNlbGVjdGVkS2V5cyA9PT0gXCJhbGxcIiA/IG5ldyBTZXQodGhpcy5nZXRTZWxlY3RBbGxLZXlzKCkpIDogdGhpcy5zdGF0ZS5zZWxlY3RlZEtleXM7XG4gICAgfVxuICAgIC8qKlxuICAgKiBUaGUgcmF3IHNlbGVjdGlvbiB2YWx1ZSBmb3IgdGhlIGNvbGxlY3Rpb24uXG4gICAqIEVpdGhlciAnYWxsJyBmb3Igc2VsZWN0IGFsbCwgb3IgYSBzZXQgb2Yga2V5cy5cbiAgICovIGdldCByYXdTZWxlY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlLnNlbGVjdGVkS2V5cztcbiAgICB9XG4gICAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlciBhIGtleSBpcyBzZWxlY3RlZC5cbiAgICovIGlzU2VsZWN0ZWQoa2V5KSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlLnNlbGVjdGlvbk1vZGUgPT09IFwibm9uZVwiKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIGtleSA9IHRoaXMuZ2V0S2V5KGtleSk7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlLnNlbGVjdGVkS2V5cyA9PT0gXCJhbGxcIiA/IHRoaXMuY2FuU2VsZWN0SXRlbShrZXkpIDogdGhpcy5zdGF0ZS5zZWxlY3RlZEtleXMuaGFzKGtleSk7XG4gICAgfVxuICAgIC8qKlxuICAgKiBXaGV0aGVyIHRoZSBzZWxlY3Rpb24gaXMgZW1wdHkuXG4gICAqLyBnZXQgaXNFbXB0eSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGUuc2VsZWN0ZWRLZXlzICE9PSBcImFsbFwiICYmIHRoaXMuc3RhdGUuc2VsZWN0ZWRLZXlzLnNpemUgPT09IDA7XG4gICAgfVxuICAgIC8qKlxuICAgKiBXaGV0aGVyIGFsbCBpdGVtcyBpbiB0aGUgY29sbGVjdGlvbiBhcmUgc2VsZWN0ZWQuXG4gICAqLyBnZXQgaXNTZWxlY3RBbGwoKSB7XG4gICAgICAgIGlmICh0aGlzLmlzRW1wdHkpIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUuc2VsZWN0ZWRLZXlzID09PSBcImFsbFwiKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgaWYgKHRoaXMuX2lzU2VsZWN0QWxsICE9IG51bGwpIHJldHVybiB0aGlzLl9pc1NlbGVjdEFsbDtcbiAgICAgICAgbGV0IGFsbEtleXMgPSB0aGlzLmdldFNlbGVjdEFsbEtleXMoKTtcbiAgICAgICAgbGV0IHNlbGVjdGVkS2V5cyA9IHRoaXMuc3RhdGUuc2VsZWN0ZWRLZXlzO1xuICAgICAgICB0aGlzLl9pc1NlbGVjdEFsbCA9IGFsbEtleXMuZXZlcnkoKGspPT5zZWxlY3RlZEtleXMuaGFzKGspKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzU2VsZWN0QWxsO1xuICAgIH1cbiAgICBnZXQgZmlyc3RTZWxlY3RlZEtleSgpIHtcbiAgICAgICAgbGV0IGZpcnN0ID0gbnVsbDtcbiAgICAgICAgZm9yIChsZXQga2V5IG9mIHRoaXMuc3RhdGUuc2VsZWN0ZWRLZXlzKXtcbiAgICAgICAgICAgIGxldCBpdGVtID0gdGhpcy5jb2xsZWN0aW9uLmdldEl0ZW0oa2V5KTtcbiAgICAgICAgICAgIGlmICghZmlyc3QgfHwgaXRlbSAmJiAoMCwgJFFzdG8yJGNvbXBhcmVOb2RlT3JkZXIpKHRoaXMuY29sbGVjdGlvbiwgaXRlbSwgZmlyc3QpIDwgMCkgZmlyc3QgPSBpdGVtO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmaXJzdCA9PT0gbnVsbCB8fCBmaXJzdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogZmlyc3Qua2V5O1xuICAgIH1cbiAgICBnZXQgbGFzdFNlbGVjdGVkS2V5KCkge1xuICAgICAgICBsZXQgbGFzdCA9IG51bGw7XG4gICAgICAgIGZvciAobGV0IGtleSBvZiB0aGlzLnN0YXRlLnNlbGVjdGVkS2V5cyl7XG4gICAgICAgICAgICBsZXQgaXRlbSA9IHRoaXMuY29sbGVjdGlvbi5nZXRJdGVtKGtleSk7XG4gICAgICAgICAgICBpZiAoIWxhc3QgfHwgaXRlbSAmJiAoMCwgJFFzdG8yJGNvbXBhcmVOb2RlT3JkZXIpKHRoaXMuY29sbGVjdGlvbiwgaXRlbSwgbGFzdCkgPiAwKSBsYXN0ID0gaXRlbTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbGFzdCA9PT0gbnVsbCB8fCBsYXN0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBsYXN0LmtleTtcbiAgICB9XG4gICAgZ2V0IGRpc2FibGVkS2V5cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGUuZGlzYWJsZWRLZXlzO1xuICAgIH1cbiAgICBnZXQgZGlzYWJsZWRCZWhhdmlvcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGUuZGlzYWJsZWRCZWhhdmlvcjtcbiAgICB9XG4gICAgLyoqXG4gICAqIEV4dGVuZHMgdGhlIHNlbGVjdGlvbiB0byB0aGUgZ2l2ZW4ga2V5LlxuICAgKi8gZXh0ZW5kU2VsZWN0aW9uKHRvS2V5KSB7XG4gICAgICAgIGlmICh0aGlzLnNlbGVjdGlvbk1vZGUgPT09IFwibm9uZVwiKSByZXR1cm47XG4gICAgICAgIGlmICh0aGlzLnNlbGVjdGlvbk1vZGUgPT09IFwic2luZ2xlXCIpIHtcbiAgICAgICAgICAgIHRoaXMucmVwbGFjZVNlbGVjdGlvbih0b0tleSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdG9LZXkgPSB0aGlzLmdldEtleSh0b0tleSk7XG4gICAgICAgIGxldCBzZWxlY3Rpb247XG4gICAgICAgIC8vIE9ubHkgc2VsZWN0IHRoZSBvbmUga2V5IGlmIGNvbWluZyBmcm9tIGEgc2VsZWN0IGFsbC5cbiAgICAgICAgaWYgKHRoaXMuc3RhdGUuc2VsZWN0ZWRLZXlzID09PSBcImFsbFwiKSBzZWxlY3Rpb24gPSBuZXcgKDAsICRlNDBlYTgyNWE4MWEzNzA5JGV4cG9ydCQ1MmJhYWMyMjcyNmM3MmJmKShbXG4gICAgICAgICAgICB0b0tleVxuICAgICAgICBdLCB0b0tleSwgdG9LZXkpO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBzZWxlY3RlZEtleXMgPSB0aGlzLnN0YXRlLnNlbGVjdGVkS2V5cztcbiAgICAgICAgICAgIGxldCBhbmNob3JLZXkgPSBzZWxlY3RlZEtleXMuYW5jaG9yS2V5IHx8IHRvS2V5O1xuICAgICAgICAgICAgc2VsZWN0aW9uID0gbmV3ICgwLCAkZTQwZWE4MjVhODFhMzcwOSRleHBvcnQkNTJiYWFjMjI3MjZjNzJiZikoc2VsZWN0ZWRLZXlzLCBhbmNob3JLZXksIHRvS2V5KTtcbiAgICAgICAgICAgIGZvciAobGV0IGtleSBvZiB0aGlzLmdldEtleVJhbmdlKGFuY2hvcktleSwgc2VsZWN0ZWRLZXlzLmN1cnJlbnRLZXkgfHwgdG9LZXkpKXNlbGVjdGlvbi5kZWxldGUoa2V5KTtcbiAgICAgICAgICAgIGZvciAobGV0IGtleSBvZiB0aGlzLmdldEtleVJhbmdlKHRvS2V5LCBhbmNob3JLZXkpKWlmICh0aGlzLmNhblNlbGVjdEl0ZW0oa2V5KSkgc2VsZWN0aW9uLmFkZChrZXkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RhdGUuc2V0U2VsZWN0ZWRLZXlzKHNlbGVjdGlvbik7XG4gICAgfVxuICAgIGdldEtleVJhbmdlKGZyb20sIHRvKSB7XG4gICAgICAgIGxldCBmcm9tSXRlbSA9IHRoaXMuY29sbGVjdGlvbi5nZXRJdGVtKGZyb20pO1xuICAgICAgICBsZXQgdG9JdGVtID0gdGhpcy5jb2xsZWN0aW9uLmdldEl0ZW0odG8pO1xuICAgICAgICBpZiAoZnJvbUl0ZW0gJiYgdG9JdGVtKSB7XG4gICAgICAgICAgICBpZiAoKDAsICRRc3RvMiRjb21wYXJlTm9kZU9yZGVyKSh0aGlzLmNvbGxlY3Rpb24sIGZyb21JdGVtLCB0b0l0ZW0pIDw9IDApIHJldHVybiB0aGlzLmdldEtleVJhbmdlSW50ZXJuYWwoZnJvbSwgdG8pO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0S2V5UmFuZ2VJbnRlcm5hbCh0bywgZnJvbSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBnZXRLZXlSYW5nZUludGVybmFsKGZyb20sIHRvKSB7XG4gICAgICAgIGxldCBrZXlzID0gW107XG4gICAgICAgIGxldCBrZXkgPSBmcm9tO1xuICAgICAgICB3aGlsZShrZXkpe1xuICAgICAgICAgICAgbGV0IGl0ZW0gPSB0aGlzLmNvbGxlY3Rpb24uZ2V0SXRlbShrZXkpO1xuICAgICAgICAgICAgaWYgKGl0ZW0gJiYgaXRlbS50eXBlID09PSBcIml0ZW1cIiB8fCBpdGVtLnR5cGUgPT09IFwiY2VsbFwiICYmIHRoaXMuYWxsb3dzQ2VsbFNlbGVjdGlvbikga2V5cy5wdXNoKGtleSk7XG4gICAgICAgICAgICBpZiAoa2V5ID09PSB0bykgcmV0dXJuIGtleXM7XG4gICAgICAgICAgICBrZXkgPSB0aGlzLmNvbGxlY3Rpb24uZ2V0S2V5QWZ0ZXIoa2V5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGdldEtleShrZXkpIHtcbiAgICAgICAgbGV0IGl0ZW0gPSB0aGlzLmNvbGxlY3Rpb24uZ2V0SXRlbShrZXkpO1xuICAgICAgICBpZiAoIWl0ZW0pIC8vIMKvXFxfKOODhClfL8KvXG4gICAgICAgIHJldHVybiBrZXk7XG4gICAgICAgIC8vIElmIGNlbGwgc2VsZWN0aW9uIGlzIGFsbG93ZWQsIGp1c3QgcmV0dXJuIHRoZSBrZXkuXG4gICAgICAgIGlmIChpdGVtLnR5cGUgPT09IFwiY2VsbFwiICYmIHRoaXMuYWxsb3dzQ2VsbFNlbGVjdGlvbikgcmV0dXJuIGtleTtcbiAgICAgICAgLy8gRmluZCBhIHBhcmVudCBpdGVtIHRvIHNlbGVjdFxuICAgICAgICB3aGlsZShpdGVtLnR5cGUgIT09IFwiaXRlbVwiICYmIGl0ZW0ucGFyZW50S2V5ICE9IG51bGwpaXRlbSA9IHRoaXMuY29sbGVjdGlvbi5nZXRJdGVtKGl0ZW0ucGFyZW50S2V5KTtcbiAgICAgICAgaWYgKCFpdGVtIHx8IGl0ZW0udHlwZSAhPT0gXCJpdGVtXCIpIHJldHVybiBudWxsO1xuICAgICAgICByZXR1cm4gaXRlbS5rZXk7XG4gICAgfVxuICAgIC8qKlxuICAgKiBUb2dnbGVzIHdoZXRoZXIgdGhlIGdpdmVuIGtleSBpcyBzZWxlY3RlZC5cbiAgICovIHRvZ2dsZVNlbGVjdGlvbihrZXkpIHtcbiAgICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uTW9kZSA9PT0gXCJub25lXCIpIHJldHVybjtcbiAgICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uTW9kZSA9PT0gXCJzaW5nbGVcIiAmJiAhdGhpcy5pc1NlbGVjdGVkKGtleSkpIHtcbiAgICAgICAgICAgIHRoaXMucmVwbGFjZVNlbGVjdGlvbihrZXkpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGtleSA9IHRoaXMuZ2V0S2V5KGtleSk7XG4gICAgICAgIGlmIChrZXkgPT0gbnVsbCkgcmV0dXJuO1xuICAgICAgICBsZXQga2V5cyA9IG5ldyAoMCwgJGU0MGVhODI1YTgxYTM3MDkkZXhwb3J0JDUyYmFhYzIyNzI2YzcyYmYpKHRoaXMuc3RhdGUuc2VsZWN0ZWRLZXlzID09PSBcImFsbFwiID8gdGhpcy5nZXRTZWxlY3RBbGxLZXlzKCkgOiB0aGlzLnN0YXRlLnNlbGVjdGVkS2V5cyk7XG4gICAgICAgIGlmIChrZXlzLmhhcyhrZXkpKSBrZXlzLmRlbGV0ZShrZXkpO1xuICAgICAgICBlbHNlIGlmICh0aGlzLmNhblNlbGVjdEl0ZW0oa2V5KSkge1xuICAgICAgICAgICAga2V5cy5hZGQoa2V5KTtcbiAgICAgICAgICAgIGtleXMuYW5jaG9yS2V5ID0ga2V5O1xuICAgICAgICAgICAga2V5cy5jdXJyZW50S2V5ID0ga2V5O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmRpc2FsbG93RW1wdHlTZWxlY3Rpb24gJiYga2V5cy5zaXplID09PSAwKSByZXR1cm47XG4gICAgICAgIHRoaXMuc3RhdGUuc2V0U2VsZWN0ZWRLZXlzKGtleXMpO1xuICAgIH1cbiAgICAvKipcbiAgICogUmVwbGFjZXMgdGhlIHNlbGVjdGlvbiB3aXRoIG9ubHkgdGhlIGdpdmVuIGtleS5cbiAgICovIHJlcGxhY2VTZWxlY3Rpb24oa2V5KSB7XG4gICAgICAgIGlmICh0aGlzLnNlbGVjdGlvbk1vZGUgPT09IFwibm9uZVwiKSByZXR1cm47XG4gICAgICAgIGtleSA9IHRoaXMuZ2V0S2V5KGtleSk7XG4gICAgICAgIGlmIChrZXkgPT0gbnVsbCkgcmV0dXJuO1xuICAgICAgICBsZXQgc2VsZWN0aW9uID0gdGhpcy5jYW5TZWxlY3RJdGVtKGtleSkgPyBuZXcgKDAsICRlNDBlYTgyNWE4MWEzNzA5JGV4cG9ydCQ1MmJhYWMyMjcyNmM3MmJmKShbXG4gICAgICAgICAgICBrZXlcbiAgICAgICAgXSwga2V5LCBrZXkpIDogbmV3ICgwLCAkZTQwZWE4MjVhODFhMzcwOSRleHBvcnQkNTJiYWFjMjI3MjZjNzJiZikoKTtcbiAgICAgICAgdGhpcy5zdGF0ZS5zZXRTZWxlY3RlZEtleXMoc2VsZWN0aW9uKTtcbiAgICB9XG4gICAgLyoqXG4gICAqIFJlcGxhY2VzIHRoZSBzZWxlY3Rpb24gd2l0aCB0aGUgZ2l2ZW4ga2V5cy5cbiAgICovIHNldFNlbGVjdGVkS2V5cyhrZXlzKSB7XG4gICAgICAgIGlmICh0aGlzLnNlbGVjdGlvbk1vZGUgPT09IFwibm9uZVwiKSByZXR1cm47XG4gICAgICAgIGxldCBzZWxlY3Rpb24gPSBuZXcgKDAsICRlNDBlYTgyNWE4MWEzNzA5JGV4cG9ydCQ1MmJhYWMyMjcyNmM3MmJmKSgpO1xuICAgICAgICBmb3IgKGxldCBrZXkgb2Yga2V5cyl7XG4gICAgICAgICAgICBrZXkgPSB0aGlzLmdldEtleShrZXkpO1xuICAgICAgICAgICAgaWYgKGtleSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uLmFkZChrZXkpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnNlbGVjdGlvbk1vZGUgPT09IFwic2luZ2xlXCIpIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RhdGUuc2V0U2VsZWN0ZWRLZXlzKHNlbGVjdGlvbik7XG4gICAgfVxuICAgIGdldFNlbGVjdEFsbEtleXMoKSB7XG4gICAgICAgIGxldCBrZXlzID0gW107XG4gICAgICAgIGxldCBhZGRLZXlzID0gKGtleSk9PntcbiAgICAgICAgICAgIHdoaWxlKGtleSl7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY2FuU2VsZWN0SXRlbShrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBpdGVtID0gdGhpcy5jb2xsZWN0aW9uLmdldEl0ZW0oa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW0udHlwZSA9PT0gXCJpdGVtXCIpIGtleXMucHVzaChrZXkpO1xuICAgICAgICAgICAgICAgICAgICAvLyBBZGQgY2hpbGQga2V5cy4gSWYgY2VsbCBzZWxlY3Rpb24gaXMgYWxsb3dlZCwgdGhlbiBpbmNsdWRlIGl0ZW0gY2hpbGRyZW4gdG9vLlxuICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbS5oYXNDaGlsZE5vZGVzICYmICh0aGlzLmFsbG93c0NlbGxTZWxlY3Rpb24gfHwgaXRlbS50eXBlICE9PSBcIml0ZW1cIikpIGFkZEtleXMoKDAsICRRc3RvMiRnZXRGaXJzdEl0ZW0pKCgwLCAkUXN0bzIkZ2V0Q2hpbGROb2RlcykoaXRlbSwgdGhpcy5jb2xsZWN0aW9uKSkua2V5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAga2V5ID0gdGhpcy5jb2xsZWN0aW9uLmdldEtleUFmdGVyKGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGFkZEtleXModGhpcy5jb2xsZWN0aW9uLmdldEZpcnN0S2V5KCkpO1xuICAgICAgICByZXR1cm4ga2V5cztcbiAgICB9XG4gICAgLyoqXG4gICAqIFNlbGVjdHMgYWxsIGl0ZW1zIGluIHRoZSBjb2xsZWN0aW9uLlxuICAgKi8gc2VsZWN0QWxsKCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNTZWxlY3RBbGwgJiYgdGhpcy5zZWxlY3Rpb25Nb2RlID09PSBcIm11bHRpcGxlXCIpIHRoaXMuc3RhdGUuc2V0U2VsZWN0ZWRLZXlzKFwiYWxsXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICogUmVtb3ZlcyBhbGwga2V5cyBmcm9tIHRoZSBzZWxlY3Rpb24uXG4gICAqLyBjbGVhclNlbGVjdGlvbigpIHtcbiAgICAgICAgaWYgKCF0aGlzLmRpc2FsbG93RW1wdHlTZWxlY3Rpb24gJiYgKHRoaXMuc3RhdGUuc2VsZWN0ZWRLZXlzID09PSBcImFsbFwiIHx8IHRoaXMuc3RhdGUuc2VsZWN0ZWRLZXlzLnNpemUgPiAwKSkgdGhpcy5zdGF0ZS5zZXRTZWxlY3RlZEtleXMobmV3ICgwLCAkZTQwZWE4MjVhODFhMzcwOSRleHBvcnQkNTJiYWFjMjI3MjZjNzJiZikoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgKiBUb2dnbGVzIGJldHdlZW4gc2VsZWN0IGFsbCBhbmQgYW4gZW1wdHkgc2VsZWN0aW9uLlxuICAgKi8gdG9nZ2xlU2VsZWN0QWxsKCkge1xuICAgICAgICBpZiAodGhpcy5pc1NlbGVjdEFsbCkgdGhpcy5jbGVhclNlbGVjdGlvbigpO1xuICAgICAgICBlbHNlIHRoaXMuc2VsZWN0QWxsKCk7XG4gICAgfVxuICAgIHNlbGVjdChrZXksIGUpIHtcbiAgICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uTW9kZSA9PT0gXCJub25lXCIpIHJldHVybjtcbiAgICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uTW9kZSA9PT0gXCJzaW5nbGVcIikge1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNTZWxlY3RlZChrZXkpICYmICF0aGlzLmRpc2FsbG93RW1wdHlTZWxlY3Rpb24pIHRoaXMudG9nZ2xlU2VsZWN0aW9uKGtleSk7XG4gICAgICAgICAgICBlbHNlIHRoaXMucmVwbGFjZVNlbGVjdGlvbihrZXkpO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuc2VsZWN0aW9uQmVoYXZpb3IgPT09IFwidG9nZ2xlXCIgfHwgZSAmJiAoZS5wb2ludGVyVHlwZSA9PT0gXCJ0b3VjaFwiIHx8IGUucG9pbnRlclR5cGUgPT09IFwidmlydHVhbFwiKSkgLy8gaWYgdG91Y2ggb3IgdmlydHVhbCAoVk8pIHRoZW4gd2UganVzdCB3YW50IHRvIHRvZ2dsZSwgb3RoZXJ3aXNlIGl0J3MgaW1wb3NzaWJsZSB0byBtdWx0aSBzZWxlY3QgYmVjYXVzZSB0aGV5IGRvbid0IGhhdmUgbW9kaWZpZXIga2V5c1xuICAgICAgICB0aGlzLnRvZ2dsZVNlbGVjdGlvbihrZXkpO1xuICAgICAgICBlbHNlIHRoaXMucmVwbGFjZVNlbGVjdGlvbihrZXkpO1xuICAgIH1cbiAgICAvKipcbiAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBjdXJyZW50IHNlbGVjdGlvbiBpcyBlcXVhbCB0byB0aGUgZ2l2ZW4gc2VsZWN0aW9uLlxuICAgKi8gaXNTZWxlY3Rpb25FcXVhbChzZWxlY3Rpb24pIHtcbiAgICAgICAgaWYgKHNlbGVjdGlvbiA9PT0gdGhpcy5zdGF0ZS5zZWxlY3RlZEtleXMpIHJldHVybiB0cnVlO1xuICAgICAgICAvLyBDaGVjayBpZiB0aGUgc2V0IG9mIGtleXMgbWF0Y2guXG4gICAgICAgIGxldCBzZWxlY3RlZEtleXMgPSB0aGlzLnNlbGVjdGVkS2V5cztcbiAgICAgICAgaWYgKHNlbGVjdGlvbi5zaXplICE9PSBzZWxlY3RlZEtleXMuc2l6ZSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBmb3IgKGxldCBrZXkgb2Ygc2VsZWN0aW9uKXtcbiAgICAgICAgICAgIGlmICghc2VsZWN0ZWRLZXlzLmhhcyhrZXkpKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQga2V5IG9mIHNlbGVjdGVkS2V5cyl7XG4gICAgICAgICAgICBpZiAoIXNlbGVjdGlvbi5oYXMoa2V5KSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjYW5TZWxlY3RJdGVtKGtleSkge1xuICAgICAgICBpZiAodGhpcy5zdGF0ZS5zZWxlY3Rpb25Nb2RlID09PSBcIm5vbmVcIiB8fCB0aGlzLnN0YXRlLmRpc2FibGVkS2V5cy5oYXMoa2V5KSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBsZXQgaXRlbSA9IHRoaXMuY29sbGVjdGlvbi5nZXRJdGVtKGtleSk7XG4gICAgICAgIGlmICghaXRlbSB8fCBpdGVtLnR5cGUgPT09IFwiY2VsbFwiICYmICF0aGlzLmFsbG93c0NlbGxTZWxlY3Rpb24pIHJldHVybiBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlzRGlzYWJsZWQoa2V5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlLmRpc2FibGVkS2V5cy5oYXMoa2V5KSAmJiB0aGlzLnN0YXRlLmRpc2FibGVkQmVoYXZpb3IgPT09IFwiYWxsXCI7XG4gICAgfVxuICAgIGlzTGluayhrZXkpIHtcbiAgICAgICAgdmFyIF90aGlzX2NvbGxlY3Rpb25fZ2V0SXRlbV9wcm9wcywgX3RoaXNfY29sbGVjdGlvbl9nZXRJdGVtO1xuICAgICAgICByZXR1cm4gISEoKF90aGlzX2NvbGxlY3Rpb25fZ2V0SXRlbSA9IHRoaXMuY29sbGVjdGlvbi5nZXRJdGVtKGtleSkpID09PSBudWxsIHx8IF90aGlzX2NvbGxlY3Rpb25fZ2V0SXRlbSA9PT0gdm9pZCAwID8gdm9pZCAwIDogKF90aGlzX2NvbGxlY3Rpb25fZ2V0SXRlbV9wcm9wcyA9IF90aGlzX2NvbGxlY3Rpb25fZ2V0SXRlbS5wcm9wcykgPT09IG51bGwgfHwgX3RoaXNfY29sbGVjdGlvbl9nZXRJdGVtX3Byb3BzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfdGhpc19jb2xsZWN0aW9uX2dldEl0ZW1fcHJvcHMuaHJlZik7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKGNvbGxlY3Rpb24sIHN0YXRlLCBvcHRpb25zKXtcbiAgICAgICAgdGhpcy5jb2xsZWN0aW9uID0gY29sbGVjdGlvbjtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xuICAgICAgICB2YXIgX29wdGlvbnNfYWxsb3dzQ2VsbFNlbGVjdGlvbjtcbiAgICAgICAgdGhpcy5hbGxvd3NDZWxsU2VsZWN0aW9uID0gKF9vcHRpb25zX2FsbG93c0NlbGxTZWxlY3Rpb24gPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuYWxsb3dzQ2VsbFNlbGVjdGlvbikgIT09IG51bGwgJiYgX29wdGlvbnNfYWxsb3dzQ2VsbFNlbGVjdGlvbiAhPT0gdm9pZCAwID8gX29wdGlvbnNfYWxsb3dzQ2VsbFNlbGVjdGlvbiA6IGZhbHNlO1xuICAgICAgICB0aGlzLl9pc1NlbGVjdEFsbCA9IG51bGw7XG4gICAgfVxufVxuXG5cblxuXG5leHBvcnQgeyQ3YWYzZjViNTE0ODllMGI1JGV4cG9ydCQyNTNmZTc4ZDQ2MzI5NDcyIGFzIHVzZU11bHRpcGxlU2VsZWN0aW9uU3RhdGUsICRkNDk2YzBhMjBiNmU1OGVjJGV4cG9ydCQ2YzhhNWFhYWQxM2M5ODUyIGFzIFNlbGVjdGlvbk1hbmFnZXJ9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bW9kdWxlLmpzLm1hcFxuIl0sIm5hbWVzIjpbInVzZUNvbnRyb2xsZWRTdGF0ZSIsIiRRc3RvMiR1c2VDb250cm9sbGVkU3RhdGUiLCJ1c2VSZWYiLCIkUXN0bzIkdXNlUmVmIiwidXNlU3RhdGUiLCIkUXN0bzIkdXNlU3RhdGUiLCJ1c2VNZW1vIiwiJFFzdG8yJHVzZU1lbW8iLCJ1c2VFZmZlY3QiLCIkUXN0bzIkdXNlRWZmZWN0IiwiY29tcGFyZU5vZGVPcmRlciIsIiRRc3RvMiRjb21wYXJlTm9kZU9yZGVyIiwiZ2V0Rmlyc3RJdGVtIiwiJFFzdG8yJGdldEZpcnN0SXRlbSIsImdldENoaWxkTm9kZXMiLCIkUXN0bzIkZ2V0Q2hpbGROb2RlcyIsIiRlNDBlYTgyNWE4MWEzNzA5JGV4cG9ydCQ1MmJhYWMyMjcyNmM3MmJmIiwiU2V0IiwiY29uc3RydWN0b3IiLCJrZXlzIiwiYW5jaG9yS2V5IiwiY3VycmVudEtleSIsIiQ3YWYzZjViNTE0ODllMGI1JHZhciRlcXVhbFNldHMiLCJzZXRBIiwic2V0QiIsInNpemUiLCJpdGVtIiwiaGFzIiwiJDdhZjNmNWI1MTQ4OWUwYjUkZXhwb3J0JDI1M2ZlNzhkNDYzMjk0NzIiLCJwcm9wcyIsInNlbGVjdGlvbk1vZGUiLCJkaXNhbGxvd0VtcHR5U2VsZWN0aW9uIiwiYWxsb3dEdXBsaWNhdGVTZWxlY3Rpb25FdmVudHMiLCJzZWxlY3Rpb25CZWhhdmlvciIsInNlbGVjdGlvbkJlaGF2aW9yUHJvcCIsImRpc2FibGVkQmVoYXZpb3IiLCJpc0ZvY3VzZWRSZWYiLCJzZXRGb2N1c2VkIiwiZm9jdXNlZEtleVJlZiIsImNoaWxkRm9jdXNTdHJhdGVneVJlZiIsInNldEZvY3VzZWRLZXkiLCJzZWxlY3RlZEtleXNQcm9wIiwiJDdhZjNmNWI1MTQ4OWUwYjUkdmFyJGNvbnZlcnRTZWxlY3Rpb24iLCJzZWxlY3RlZEtleXMiLCJkZWZhdWx0U2VsZWN0ZWRLZXlzIiwic2V0U2VsZWN0ZWRLZXlzIiwib25TZWxlY3Rpb25DaGFuZ2UiLCJkaXNhYmxlZEtleXNQcm9wIiwiZGlzYWJsZWRLZXlzIiwic2V0U2VsZWN0aW9uQmVoYXZpb3IiLCJsYXN0U2VsZWN0aW9uQmVoYXZpb3IiLCJjdXJyZW50IiwiaXNGb2N1c2VkIiwiZiIsImZvY3VzZWRLZXkiLCJjaGlsZEZvY3VzU3RyYXRlZ3kiLCJrIiwic2VsZWN0aW9uIiwiZGVmYXVsdFZhbHVlIiwiJGQ0OTZjMGEyMGI2ZTU4ZWMkZXhwb3J0JDZjOGE1YWFhZDEzYzk4NTIiLCJzdGF0ZSIsImtleSIsImNvbGxlY3Rpb24iLCJnZXRJdGVtIiwiZ2V0U2VsZWN0QWxsS2V5cyIsInJhd1NlbGVjdGlvbiIsImlzU2VsZWN0ZWQiLCJnZXRLZXkiLCJjYW5TZWxlY3RJdGVtIiwiaXNFbXB0eSIsImlzU2VsZWN0QWxsIiwiX2lzU2VsZWN0QWxsIiwiYWxsS2V5cyIsImV2ZXJ5IiwiZmlyc3RTZWxlY3RlZEtleSIsImZpcnN0IiwibGFzdFNlbGVjdGVkS2V5IiwibGFzdCIsImV4dGVuZFNlbGVjdGlvbiIsInRvS2V5IiwicmVwbGFjZVNlbGVjdGlvbiIsImdldEtleVJhbmdlIiwiZGVsZXRlIiwiYWRkIiwiZnJvbSIsInRvIiwiZnJvbUl0ZW0iLCJ0b0l0ZW0iLCJnZXRLZXlSYW5nZUludGVybmFsIiwidHlwZSIsImFsbG93c0NlbGxTZWxlY3Rpb24iLCJwdXNoIiwiZ2V0S2V5QWZ0ZXIiLCJwYXJlbnRLZXkiLCJ0b2dnbGVTZWxlY3Rpb24iLCJhZGRLZXlzIiwiaGFzQ2hpbGROb2RlcyIsImdldEZpcnN0S2V5Iiwic2VsZWN0QWxsIiwiY2xlYXJTZWxlY3Rpb24iLCJ0b2dnbGVTZWxlY3RBbGwiLCJzZWxlY3QiLCJlIiwicG9pbnRlclR5cGUiLCJpc1NlbGVjdGlvbkVxdWFsIiwiaXNEaXNhYmxlZCIsImlzTGluayIsIl90aGlzX2NvbGxlY3Rpb25fZ2V0SXRlbV9wcm9wcyIsIl90aGlzX2NvbGxlY3Rpb25fZ2V0SXRlbSIsImhyZWYiLCJvcHRpb25zIiwiX29wdGlvbnNfYWxsb3dzQ2VsbFNlbGVjdGlvbiIsInVzZU11bHRpcGxlU2VsZWN0aW9uU3RhdGUiLCJTZWxlY3Rpb25NYW5hZ2VyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-stately/selection/dist/import.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-stately/slider/dist/import.mjs":
/*!************************************************************!*\
  !*** ./node_modules/@react-stately/slider/dist/import.mjs ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useSliderState: () => (/* binding */ $28f99e3e86e6ec45$export$e5fda3247f5d67f9)\n/* harmony export */ });\n/* harmony import */ var _react_stately_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @react-stately/utils */ \"(ssr)/./node_modules/@react-stately/utils/dist/import.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ const $28f99e3e86e6ec45$var$DEFAULT_MIN_VALUE = 0;\nconst $28f99e3e86e6ec45$var$DEFAULT_MAX_VALUE = 100;\nconst $28f99e3e86e6ec45$var$DEFAULT_STEP_VALUE = 1;\nfunction $28f99e3e86e6ec45$export$e5fda3247f5d67f9(props) {\n    const { isDisabled: isDisabled = false, minValue: minValue = $28f99e3e86e6ec45$var$DEFAULT_MIN_VALUE, maxValue: maxValue = $28f99e3e86e6ec45$var$DEFAULT_MAX_VALUE, numberFormatter: formatter, step: step = $28f99e3e86e6ec45$var$DEFAULT_STEP_VALUE, orientation: orientation = \"horizontal\" } = props;\n    // Page step should be at least equal to step and always a multiple of the step.\n    let pageSize = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        let calcPageSize = (maxValue - minValue) / 10;\n        calcPageSize = (0, _react_stately_utils__WEBPACK_IMPORTED_MODULE_1__.snapValueToStep)(calcPageSize, 0, calcPageSize + step, step);\n        return Math.max(calcPageSize, step);\n    }, [\n        step,\n        maxValue,\n        minValue\n    ]);\n    let restrictValues = (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((values)=>values === null || values === void 0 ? void 0 : values.map((val, idx)=>{\n            let min = idx === 0 ? minValue : val[idx - 1];\n            let max = idx === values.length - 1 ? maxValue : val[idx + 1];\n            return (0, _react_stately_utils__WEBPACK_IMPORTED_MODULE_1__.snapValueToStep)(val, min, max, step);\n        }), [\n        minValue,\n        maxValue,\n        step\n    ]);\n    let value = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>restrictValues($28f99e3e86e6ec45$var$convertValue(props.value)), [\n        props.value\n    ]);\n    let defaultValue = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        var _convertValue;\n        return restrictValues((_convertValue = $28f99e3e86e6ec45$var$convertValue(props.defaultValue)) !== null && _convertValue !== void 0 ? _convertValue : [\n            minValue\n        ]);\n    }, [\n        props.defaultValue,\n        minValue\n    ]);\n    let onChange = $28f99e3e86e6ec45$var$createOnChange(props.value, props.defaultValue, props.onChange);\n    let onChangeEnd = $28f99e3e86e6ec45$var$createOnChange(props.value, props.defaultValue, props.onChangeEnd);\n    const [values, setValuesState] = (0, _react_stately_utils__WEBPACK_IMPORTED_MODULE_1__.useControlledState)(value, defaultValue, onChange);\n    const [isDraggings, setDraggingsState] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(new Array(values.length).fill(false));\n    const isEditablesRef = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)(new Array(values.length).fill(true));\n    const [focusedIndex, setFocusedIndex] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(undefined);\n    const valuesRef = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)(values);\n    const isDraggingsRef = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)(isDraggings);\n    let setValues = (values)=>{\n        valuesRef.current = values;\n        setValuesState(values);\n    };\n    let setDraggings = (draggings)=>{\n        isDraggingsRef.current = draggings;\n        setDraggingsState(draggings);\n    };\n    function getValuePercent(value) {\n        return (value - minValue) / (maxValue - minValue);\n    }\n    function getThumbMinValue(index) {\n        return index === 0 ? minValue : values[index - 1];\n    }\n    function getThumbMaxValue(index) {\n        return index === values.length - 1 ? maxValue : values[index + 1];\n    }\n    function isThumbEditable(index) {\n        return isEditablesRef.current[index];\n    }\n    function setThumbEditable(index, editable) {\n        isEditablesRef.current[index] = editable;\n    }\n    function updateValue(index, value) {\n        if (isDisabled || !isThumbEditable(index)) return;\n        const thisMin = getThumbMinValue(index);\n        const thisMax = getThumbMaxValue(index);\n        // Round value to multiple of step, clamp value between min and max\n        value = (0, _react_stately_utils__WEBPACK_IMPORTED_MODULE_1__.snapValueToStep)(value, thisMin, thisMax, step);\n        let newValues = $28f99e3e86e6ec45$var$replaceIndex(valuesRef.current, index, value);\n        setValues(newValues);\n    }\n    function updateDragging(index, dragging) {\n        if (isDisabled || !isThumbEditable(index)) return;\n        const wasDragging = isDraggingsRef.current[index];\n        isDraggingsRef.current = $28f99e3e86e6ec45$var$replaceIndex(isDraggingsRef.current, index, dragging);\n        setDraggings(isDraggingsRef.current);\n        // Call onChangeEnd if no handles are dragging.\n        if (onChangeEnd && wasDragging && !isDraggingsRef.current.some(Boolean)) onChangeEnd(valuesRef.current);\n    }\n    function getFormattedValue(value) {\n        return formatter.format(value);\n    }\n    function setThumbPercent(index, percent) {\n        updateValue(index, getPercentValue(percent));\n    }\n    function getRoundedValue(value) {\n        return Math.round((value - minValue) / step) * step + minValue;\n    }\n    function getPercentValue(percent) {\n        const val = percent * (maxValue - minValue) + minValue;\n        return (0, _react_stately_utils__WEBPACK_IMPORTED_MODULE_1__.clamp)(getRoundedValue(val), minValue, maxValue);\n    }\n    function incrementThumb(index, stepSize = 1) {\n        let s = Math.max(stepSize, step);\n        updateValue(index, (0, _react_stately_utils__WEBPACK_IMPORTED_MODULE_1__.snapValueToStep)(values[index] + s, minValue, maxValue, step));\n    }\n    function decrementThumb(index, stepSize = 1) {\n        let s = Math.max(stepSize, step);\n        updateValue(index, (0, _react_stately_utils__WEBPACK_IMPORTED_MODULE_1__.snapValueToStep)(values[index] - s, minValue, maxValue, step));\n    }\n    return {\n        values: values,\n        getThumbValue: (index)=>values[index],\n        setThumbValue: updateValue,\n        setThumbPercent: setThumbPercent,\n        isThumbDragging: (index)=>isDraggings[index],\n        setThumbDragging: updateDragging,\n        focusedThumb: focusedIndex,\n        setFocusedThumb: setFocusedIndex,\n        getThumbPercent: (index)=>getValuePercent(values[index]),\n        getValuePercent: getValuePercent,\n        getThumbValueLabel: (index)=>getFormattedValue(values[index]),\n        getFormattedValue: getFormattedValue,\n        getThumbMinValue: getThumbMinValue,\n        getThumbMaxValue: getThumbMaxValue,\n        getPercentValue: getPercentValue,\n        isThumbEditable: isThumbEditable,\n        setThumbEditable: setThumbEditable,\n        incrementThumb: incrementThumb,\n        decrementThumb: decrementThumb,\n        step: step,\n        pageSize: pageSize,\n        orientation: orientation,\n        isDisabled: isDisabled\n    };\n}\nfunction $28f99e3e86e6ec45$var$replaceIndex(array, index, value) {\n    if (array[index] === value) return array;\n    return [\n        ...array.slice(0, index),\n        value,\n        ...array.slice(index + 1)\n    ];\n}\nfunction $28f99e3e86e6ec45$var$convertValue(value) {\n    if (value == null) return undefined;\n    return Array.isArray(value) ? value : [\n        value\n    ];\n}\nfunction $28f99e3e86e6ec45$var$createOnChange(value, defaultValue, onChange) {\n    return (newValue)=>{\n        if (typeof value === \"number\" || typeof defaultValue === \"number\") onChange === null || onChange === void 0 ? void 0 : onChange(newValue[0]);\n        else onChange === null || onChange === void 0 ? void 0 : onChange(newValue);\n    };\n}\n //# sourceMappingURL=module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXN0YXRlbHkvc2xpZGVyL2Rpc3QvaW1wb3J0Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBdUo7QUFDZDtBQUV6STs7Ozs7Ozs7OztDQVVDLEdBQUc7Ozs7Ozs7Ozs7Q0FVSCxHQUVELE1BQU1jLDBDQUEwQztBQUNoRCxNQUFNQywwQ0FBMEM7QUFDaEQsTUFBTUMsMkNBQTJDO0FBQ2pELFNBQVNDLDBDQUEwQ0MsS0FBSztJQUNwRCxNQUFNLEVBQUVDLFlBQVlBLGFBQWEsS0FBSyxFQUFFQyxVQUFVQSxXQUFXTix1Q0FBdUMsRUFBRU8sVUFBVUEsV0FBV04sdUNBQXVDLEVBQUVPLGlCQUFpQkMsU0FBUyxFQUFFQyxNQUFNQSxPQUFPUix3Q0FBd0MsRUFBRVMsYUFBYUEsY0FBYyxZQUFZLEVBQUUsR0FBR1A7SUFDblMsZ0ZBQWdGO0lBQ2hGLElBQUlRLFdBQVcsQ0FBQyxHQUFHbkIsMENBQWEsRUFBRztRQUMvQixJQUFJb0IsZUFBZSxDQUFDTixXQUFXRCxRQUFPLElBQUs7UUFDM0NPLGVBQWUsQ0FBQyxHQUFHMUIsaUVBQXFCLEVBQUcwQixjQUFjLEdBQUdBLGVBQWVILE1BQU1BO1FBQ2pGLE9BQU9JLEtBQUtDLEdBQUcsQ0FBQ0YsY0FBY0g7SUFDbEMsR0FBRztRQUNDQTtRQUNBSDtRQUNBRDtLQUNIO0lBQ0QsSUFBSVUsaUJBQWlCLENBQUMsR0FBR3JCLDhDQUFpQixFQUFHLENBQUNzQixTQUFTQSxXQUFXLFFBQVFBLFdBQVcsS0FBSyxJQUFJLEtBQUssSUFBSUEsT0FBT0MsR0FBRyxDQUFDLENBQUNDLEtBQUtDO1lBQ2hILElBQUlDLE1BQU1ELFFBQVEsSUFBSWQsV0FBV2EsR0FBRyxDQUFDQyxNQUFNLEVBQUU7WUFDN0MsSUFBSUwsTUFBTUssUUFBUUgsT0FBT0ssTUFBTSxHQUFHLElBQUlmLFdBQVdZLEdBQUcsQ0FBQ0MsTUFBTSxFQUFFO1lBQzdELE9BQU8sQ0FBQyxHQUFHakMsaUVBQXFCLEVBQUdnQyxL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LE9BQU83RCxVQUFVLFlBQVksT0FBT0UsaUJBQWlCLFVBQVVFLGFBQWEsUUFBUUEsYUFBYSxLQUFLLElBQUksS0FBSyxJQUFJQSxTQUFTeUQsUUFBUSxDQUFDLEVBQUU7YUFDdEl6RCxhQUFhLFFBQVFBLGFBQWEsS0FBSyxJQUFJLEtBQUssSUFBSUEsU0FBU3lEO0lBQ3RFO0FBQ0o7QUFLcUUsQ0FDckUsa0NBQWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1mbGFzay8uL25vZGVfbW9kdWxlcy9AcmVhY3Qtc3RhdGVseS9zbGlkZXIvZGlzdC9pbXBvcnQubWpzPzgxODciXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtzbmFwVmFsdWVUb1N0ZXAgYXMgJGFUd3V4JHNuYXBWYWx1ZVRvU3RlcCwgdXNlQ29udHJvbGxlZFN0YXRlIGFzICRhVHd1eCR1c2VDb250cm9sbGVkU3RhdGUsIGNsYW1wIGFzICRhVHd1eCRjbGFtcH0gZnJvbSBcIkByZWFjdC1zdGF0ZWx5L3V0aWxzXCI7XG5pbXBvcnQge3VzZU1lbW8gYXMgJGFUd3V4JHVzZU1lbW8sIHVzZUNhbGxiYWNrIGFzICRhVHd1eCR1c2VDYWxsYmFjaywgdXNlU3RhdGUgYXMgJGFUd3V4JHVzZVN0YXRlLCB1c2VSZWYgYXMgJGFUd3V4JHVzZVJlZn0gZnJvbSBcInJlYWN0XCI7XG5cbi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyAvKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gXG5cbmNvbnN0ICQyOGY5OWUzZTg2ZTZlYzQ1JHZhciRERUZBVUxUX01JTl9WQUxVRSA9IDA7XG5jb25zdCAkMjhmOTllM2U4NmU2ZWM0NSR2YXIkREVGQVVMVF9NQVhfVkFMVUUgPSAxMDA7XG5jb25zdCAkMjhmOTllM2U4NmU2ZWM0NSR2YXIkREVGQVVMVF9TVEVQX1ZBTFVFID0gMTtcbmZ1bmN0aW9uICQyOGY5OWUzZTg2ZTZlYzQ1JGV4cG9ydCRlNWZkYTMyNDdmNWQ2N2Y5KHByb3BzKSB7XG4gICAgY29uc3QgeyBpc0Rpc2FibGVkOiBpc0Rpc2FibGVkID0gZmFsc2UsIG1pblZhbHVlOiBtaW5WYWx1ZSA9ICQyOGY5OWUzZTg2ZTZlYzQ1JHZhciRERUZBVUxUX01JTl9WQUxVRSwgbWF4VmFsdWU6IG1heFZhbHVlID0gJDI4Zjk5ZTNlODZlNmVjNDUkdmFyJERFRkFVTFRfTUFYX1ZBTFVFLCBudW1iZXJGb3JtYXR0ZXI6IGZvcm1hdHRlciwgc3RlcDogc3RlcCA9ICQyOGY5OWUzZTg2ZTZlYzQ1JHZhciRERUZBVUxUX1NURVBfVkFMVUUsIG9yaWVudGF0aW9uOiBvcmllbnRhdGlvbiA9IFwiaG9yaXpvbnRhbFwiIH0gPSBwcm9wcztcbiAgICAvLyBQYWdlIHN0ZXAgc2hvdWxkIGJlIGF0IGxlYXN0IGVxdWFsIHRvIHN0ZXAgYW5kIGFsd2F5cyBhIG11bHRpcGxlIG9mIHRoZSBzdGVwLlxuICAgIGxldCBwYWdlU2l6ZSA9ICgwLCAkYVR3dXgkdXNlTWVtbykoKCk9PntcbiAgICAgICAgbGV0IGNhbGNQYWdlU2l6ZSA9IChtYXhWYWx1ZSAtIG1pblZhbHVlKSAvIDEwO1xuICAgICAgICBjYWxjUGFnZVNpemUgPSAoMCwgJGFUd3V4JHNuYXBWYWx1ZVRvU3RlcCkoY2FsY1BhZ2VTaXplLCAwLCBjYWxjUGFnZVNpemUgKyBzdGVwLCBzdGVwKTtcbiAgICAgICAgcmV0dXJuIE1hdGgubWF4KGNhbGNQYWdlU2l6ZSwgc3RlcCk7XG4gICAgfSwgW1xuICAgICAgICBzdGVwLFxuICAgICAgICBtYXhWYWx1ZSxcbiAgICAgICAgbWluVmFsdWVcbiAgICBdKTtcbiAgICBsZXQgcmVzdHJpY3RWYWx1ZXMgPSAoMCwgJGFUd3V4JHVzZUNhbGxiYWNrKSgodmFsdWVzKT0+dmFsdWVzID09PSBudWxsIHx8IHZhbHVlcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogdmFsdWVzLm1hcCgodmFsLCBpZHgpPT57XG4gICAgICAgICAgICBsZXQgbWluID0gaWR4ID09PSAwID8gbWluVmFsdWUgOiB2YWxbaWR4IC0gMV07XG4gICAgICAgICAgICBsZXQgbWF4ID0gaWR4ID09PSB2YWx1ZXMubGVuZ3RoIC0gMSA/IG1heFZhbHVlIDogdmFsW2lkeCArIDFdO1xuICAgICAgICAgICAgcmV0dXJuICgwLCAkYVR3dXgkc25hcFZhbHVlVG9TdGVwKSh2YWwsIG1pbiwgbWF4LCBzdGVwKTtcbiAgICAgICAgfSksIFtcbiAgICAgICAgbWluVmFsdWUsXG4gICAgICAgIG1heFZhbHVlLFxuICAgICAgICBzdGVwXG4gICAgXSk7XG4gICAgbGV0IHZhbHVlID0gKDAsICRhVHd1eCR1c2VNZW1vKSgoKT0+cmVzdHJpY3RWYWx1ZXMoJDI4Zjk5ZTNlODZlNmVjNDUkdmFyJGNvbnZlcnRWYWx1ZShwcm9wcy52YWx1ZSkpLCBbXG4gICAgICAgIHByb3BzLnZhbHVlXG4gICAgXSk7XG4gICAgbGV0IGRlZmF1bHRWYWx1ZSA9ICgwLCAkYVR3dXgkdXNlTWVtbykoKCk9PntcbiAgICAgICAgdmFyIF9jb252ZXJ0VmFsdWU7XG4gICAgICAgIHJldHVybiByZXN0cmljdFZhbHVlcygoX2NvbnZlcnRWYWx1ZSA9ICQyOGY5OWUzZTg2ZTZlYzQ1JHZhciRjb252ZXJ0VmFsdWUocHJvcHMuZGVmYXVsdFZhbHVlKSkgIT09IG51bGwgJiYgX2NvbnZlcnRWYWx1ZSAhPT0gdm9pZCAwID8gX2NvbnZlcnRWYWx1ZSA6IFtcbiAgICAgICAgICAgIG1pblZhbHVlXG4gICAgICAgIF0pO1xuICAgIH0sIFtcbiAgICAgICAgcHJvcHMuZGVmYXVsdFZhbHVlLFxuICAgICAgICBtaW5WYWx1ZVxuICAgIF0pO1xuICAgIGxldCBvbkNoYW5nZSA9ICQyOGY5OWUzZTg2ZTZlYzQ1JHZhciRjcmVhdGVPbkNoYW5nZShwcm9wcy52YWx1ZSwgcHJvcHMuZGVmYXVsdFZhbHVlLCBwcm9wcy5vbkNoYW5nZSk7XG4gICAgbGV0IG9uQ2hhbmdlRW5kID0gJDI4Zjk5ZTNlODZlNmVjNDUkdmFyJGNyZWF0ZU9uQ2hhbmdlKHByb3BzLnZhbHVlLCBwcm9wcy5kZWZhdWx0VmFsdWUsIHByb3BzLm9uQ2hhbmdlRW5kKTtcbiAgICBjb25zdCBbdmFsdWVzLCBzZXRWYWx1ZXNTdGF0ZV0gPSAoMCwgJGFUd3V4JHVzZUNvbnRyb2xsZWRTdGF0ZSkodmFsdWUsIGRlZmF1bHRWYWx1ZSwgb25DaGFuZ2UpO1xuICAgIGNvbnN0IFtpc0RyYWdnaW5ncywgc2V0RHJhZ2dpbmdzU3RhdGVdID0gKDAsICRhVHd1eCR1c2VTdGF0ZSkobmV3IEFycmF5KHZhbHVlcy5sZW5ndGgpLmZpbGwoZmFsc2UpKTtcbiAgICBjb25zdCBpc0VkaXRhYmxlc1JlZiA9ICgwLCAkYVR3dXgkdXNlUmVmKShuZXcgQXJyYXkodmFsdWVzLmxlbmd0aCkuZmlsbCh0cnVlKSk7XG4gICAgY29uc3QgW2ZvY3VzZWRJbmRleCwgc2V0Rm9jdXNlZEluZGV4XSA9ICgwLCAkYVR3dXgkdXNlU3RhdGUpKHVuZGVmaW5lZCk7XG4gICAgY29uc3QgdmFsdWVzUmVmID0gKDAsICRhVHd1eCR1c2VSZWYpKHZhbHVlcyk7XG4gICAgY29uc3QgaXNEcmFnZ2luZ3NSZWYgPSAoMCwgJGFUd3V4JHVzZVJlZikoaXNEcmFnZ2luZ3MpO1xuICAgIGxldCBzZXRWYWx1ZXMgPSAodmFsdWVzKT0+e1xuICAgICAgICB2YWx1ZXNSZWYuY3VycmVudCA9IHZhbHVlcztcbiAgICAgICAgc2V0VmFsdWVzU3RhdGUodmFsdWVzKTtcbiAgICB9O1xuICAgIGxldCBzZXREcmFnZ2luZ3MgPSAoZHJhZ2dpbmdzKT0+e1xuICAgICAgICBpc0RyYWdnaW5nc1JlZi5jdXJyZW50ID0gZHJhZ2dpbmdzO1xuICAgICAgICBzZXREcmFnZ2luZ3NTdGF0ZShkcmFnZ2luZ3MpO1xuICAgIH07XG4gICAgZnVuY3Rpb24gZ2V0VmFsdWVQZXJjZW50KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiAodmFsdWUgLSBtaW5WYWx1ZSkgLyAobWF4VmFsdWUgLSBtaW5WYWx1ZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldFRodW1iTWluVmFsdWUoaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGluZGV4ID09PSAwID8gbWluVmFsdWUgOiB2YWx1ZXNbaW5kZXggLSAxXTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0VGh1bWJNYXhWYWx1ZShpbmRleCkge1xuICAgICAgICByZXR1cm4gaW5kZXggPT09IHZhbHVlcy5sZW5ndGggLSAxID8gbWF4VmFsdWUgOiB2YWx1ZXNbaW5kZXggKyAxXTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaXNUaHVtYkVkaXRhYmxlKGluZGV4KSB7XG4gICAgICAgIHJldHVybiBpc0VkaXRhYmxlc1JlZi5jdXJyZW50W2luZGV4XTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2V0VGh1bWJFZGl0YWJsZShpbmRleCwgZWRpdGFibGUpIHtcbiAgICAgICAgaXNFZGl0YWJsZXNSZWYuY3VycmVudFtpbmRleF0gPSBlZGl0YWJsZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdXBkYXRlVmFsdWUoaW5kZXgsIHZhbHVlKSB7XG4gICAgICAgIGlmIChpc0Rpc2FibGVkIHx8ICFpc1RodW1iRWRpdGFibGUoaW5kZXgpKSByZXR1cm47XG4gICAgICAgIGNvbnN0IHRoaXNNaW4gPSBnZXRUaHVtYk1pblZhbHVlKGluZGV4KTtcbiAgICAgICAgY29uc3QgdGhpc01heCA9IGdldFRodW1iTWF4VmFsdWUoaW5kZXgpO1xuICAgICAgICAvLyBSb3VuZCB2YWx1ZSB0byBtdWx0aXBsZSBvZiBzdGVwLCBjbGFtcCB2YWx1ZSBiZXR3ZWVuIG1pbiBhbmQgbWF4XG4gICAgICAgIHZhbHVlID0gKDAsICRhVHd1eCRzbmFwVmFsdWVUb1N0ZXApKHZhbHVlLCB0aGlzTWluLCB0aGlzTWF4LCBzdGVwKTtcbiAgICAgICAgbGV0IG5ld1ZhbHVlcyA9ICQyOGY5OWUzZTg2ZTZlYzQ1JHZhciRyZXBsYWNlSW5kZXgodmFsdWVzUmVmLmN1cnJlbnQsIGluZGV4LCB2YWx1ZSk7XG4gICAgICAgIHNldFZhbHVlcyhuZXdWYWx1ZXMpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1cGRhdGVEcmFnZ2luZyhpbmRleCwgZHJhZ2dpbmcpIHtcbiAgICAgICAgaWYgKGlzRGlzYWJsZWQgfHwgIWlzVGh1bWJFZGl0YWJsZShpbmRleCkpIHJldHVybjtcbiAgICAgICAgY29uc3Qgd2FzRHJhZ2dpbmcgPSBpc0RyYWdnaW5nc1JlZi5jdXJyZW50W2luZGV4XTtcbiAgICAgICAgaXNEcmFnZ2luZ3NSZWYuY3VycmVudCA9ICQyOGY5OWUzZTg2ZTZlYzQ1JHZhciRyZXBsYWNlSW5kZXgoaXNEcmFnZ2luZ3NSZWYuY3VycmVudCwgaW5kZXgsIGRyYWdnaW5nKTtcbiAgICAgICAgc2V0RHJhZ2dpbmdzKGlzRHJhZ2dpbmdzUmVmLmN1cnJlbnQpO1xuICAgICAgICAvLyBDYWxsIG9uQ2hhbmdlRW5kIGlmIG5vIGhhbmRsZXMgYXJlIGRyYWdnaW5nLlxuICAgICAgICBpZiAob25DaGFuZ2VFbmQgJiYgd2FzRHJhZ2dpbmcgJiYgIWlzRHJhZ2dpbmdzUmVmLmN1cnJlbnQuc29tZShCb29sZWFuKSkgb25DaGFuZ2VFbmQodmFsdWVzUmVmLmN1cnJlbnQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRGb3JtYXR0ZWRWYWx1ZSh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gZm9ybWF0dGVyLmZvcm1hdCh2YWx1ZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNldFRodW1iUGVyY2VudChpbmRleCwgcGVyY2VudCkge1xuICAgICAgICB1cGRhdGVWYWx1ZShpbmRleCwgZ2V0UGVyY2VudFZhbHVlKHBlcmNlbnQpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0Um91bmRlZFZhbHVlKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBNYXRoLnJvdW5kKCh2YWx1ZSAtIG1pblZhbHVlKSAvIHN0ZXApICogc3RlcCArIG1pblZhbHVlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRQZXJjZW50VmFsdWUocGVyY2VudCkge1xuICAgICAgICBjb25zdCB2YWwgPSBwZXJjZW50ICogKG1heFZhbHVlIC0gbWluVmFsdWUpICsgbWluVmFsdWU7XG4gICAgICAgIHJldHVybiAoMCwgJGFUd3V4JGNsYW1wKShnZXRSb3VuZGVkVmFsdWUodmFsKSwgbWluVmFsdWUsIG1heFZhbHVlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaW5jcmVtZW50VGh1bWIoaW5kZXgsIHN0ZXBTaXplID0gMSkge1xuICAgICAgICBsZXQgcyA9IE1hdGgubWF4KHN0ZXBTaXplLCBzdGVwKTtcbiAgICAgICAgdXBkYXRlVmFsdWUoaW5kZXgsICgwLCAkYVR3dXgkc25hcFZhbHVlVG9TdGVwKSh2YWx1ZXNbaW5kZXhdICsgcywgbWluVmFsdWUsIG1heFZhbHVlLCBzdGVwKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlY3JlbWVudFRodW1iKGluZGV4LCBzdGVwU2l6ZSA9IDEpIHtcbiAgICAgICAgbGV0IHMgPSBNYXRoLm1heChzdGVwU2l6ZSwgc3RlcCk7XG4gICAgICAgIHVwZGF0ZVZhbHVlKGluZGV4LCAoMCwgJGFUd3V4JHNuYXBWYWx1ZVRvU3RlcCkodmFsdWVzW2luZGV4XSAtIHMsIG1pblZhbHVlLCBtYXhWYWx1ZSwgc3RlcCkpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZXM6IHZhbHVlcyxcbiAgICAgICAgZ2V0VGh1bWJWYWx1ZTogKGluZGV4KT0+dmFsdWVzW2luZGV4XSxcbiAgICAgICAgc2V0VGh1bWJWYWx1ZTogdXBkYXRlVmFsdWUsXG4gICAgICAgIHNldFRodW1iUGVyY2VudDogc2V0VGh1bWJQZXJjZW50LFxuICAgICAgICBpc1RodW1iRHJhZ2dpbmc6IChpbmRleCk9PmlzRHJhZ2dpbmdzW2luZGV4XSxcbiAgICAgICAgc2V0VGh1bWJEcmFnZ2luZzogdXBkYXRlRHJhZ2dpbmcsXG4gICAgICAgIGZvY3VzZWRUaHVtYjogZm9jdXNlZEluZGV4LFxuICAgICAgICBzZXRGb2N1c2VkVGh1bWI6IHNldEZvY3VzZWRJbmRleCxcbiAgICAgICAgZ2V0VGh1bWJQZXJjZW50OiAoaW5kZXgpPT5nZXRWYWx1ZVBlcmNlbnQodmFsdWVzW2luZGV4XSksXG4gICAgICAgIGdldFZhbHVlUGVyY2VudDogZ2V0VmFsdWVQZXJjZW50LFxuICAgICAgICBnZXRUaHVtYlZhbHVlTGFiZWw6IChpbmRleCk9PmdldEZvcm1hdHRlZFZhbHVlKHZhbHVlc1tpbmRleF0pLFxuICAgICAgICBnZXRGb3JtYXR0ZWRWYWx1ZTogZ2V0Rm9ybWF0dGVkVmFsdWUsXG4gICAgICAgIGdldFRodW1iTWluVmFsdWU6IGdldFRodW1iTWluVmFsdWUsXG4gICAgICAgIGdldFRodW1iTWF4VmFsdWU6IGdldFRodW1iTWF4VmFsdWUsXG4gICAgICAgIGdldFBlcmNlbnRWYWx1ZTogZ2V0UGVyY2VudFZhbHVlLFxuICAgICAgICBpc1RodW1iRWRpdGFibGU6IGlzVGh1bWJFZGl0YWJsZSxcbiAgICAgICAgc2V0VGh1bWJFZGl0YWJsZTogc2V0VGh1bWJFZGl0YWJsZSxcbiAgICAgICAgaW5jcmVtZW50VGh1bWI6IGluY3JlbWVudFRodW1iLFxuICAgICAgICBkZWNyZW1lbnRUaHVtYjogZGVjcmVtZW50VGh1bWIsXG4gICAgICAgIHN0ZXA6IHN0ZXAsXG4gICAgICAgIHBhZ2VTaXplOiBwYWdlU2l6ZSxcbiAgICAgICAgb3JpZW50YXRpb246IG9yaWVudGF0aW9uLFxuICAgICAgICBpc0Rpc2FibGVkOiBpc0Rpc2FibGVkXG4gICAgfTtcbn1cbmZ1bmN0aW9uICQyOGY5OWUzZTg2ZTZlYzQ1JHZhciRyZXBsYWNlSW5kZXgoYXJyYXksIGluZGV4LCB2YWx1ZSkge1xuICAgIGlmIChhcnJheVtpbmRleF0gPT09IHZhbHVlKSByZXR1cm4gYXJyYXk7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgLi4uYXJyYXkuc2xpY2UoMCwgaW5kZXgpLFxuICAgICAgICB2YWx1ZSxcbiAgICAgICAgLi4uYXJyYXkuc2xpY2UoaW5kZXggKyAxKVxuICAgIF07XG59XG5mdW5jdGlvbiAkMjhmOTllM2U4NmU2ZWM0NSR2YXIkY29udmVydFZhbHVlKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlID09IG51bGwpIHJldHVybiB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodmFsdWUpID8gdmFsdWUgOiBbXG4gICAgICAgIHZhbHVlXG4gICAgXTtcbn1cbmZ1bmN0aW9uICQyOGY5OWUzZTg2ZTZlYzQ1JHZhciRjcmVhdGVPbkNoYW5nZSh2YWx1ZSwgZGVmYXVsdFZhbHVlLCBvbkNoYW5nZSkge1xuICAgIHJldHVybiAobmV3VmFsdWUpPT57XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIgfHwgdHlwZW9mIGRlZmF1bHRWYWx1ZSA9PT0gXCJudW1iZXJcIikgb25DaGFuZ2UgPT09IG51bGwgfHwgb25DaGFuZ2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9uQ2hhbmdlKG5ld1ZhbHVlWzBdKTtcbiAgICAgICAgZWxzZSBvbkNoYW5nZSA9PT0gbnVsbCB8fCBvbkNoYW5nZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogb25DaGFuZ2UobmV3VmFsdWUpO1xuICAgIH07XG59XG5cblxuXG5cbmV4cG9ydCB7JDI4Zjk5ZTNlODZlNmVjNDUkZXhwb3J0JGU1ZmRhMzI0N2Y1ZDY3ZjkgYXMgdXNlU2xpZGVyU3RhdGV9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bW9kdWxlLmpzLm1hcFxuIl0sIm5hbWVzIjpbInNuYXBWYWx1ZVRvU3RlcCIsIiRhVHd1eCRzbmFwVmFsdWVUb1N0ZXAiLCJ1c2VDb250cm9sbGVkU3RhdGUiLCIkYVR3dXgkdXNlQ29udHJvbGxlZFN0YXRlIiwiY2xhbXAiLCIkYVR3dXgkY2xhbXAiLCJ1c2VNZW1vIiwiJGFUd3V4JHVzZU1lbW8iLCJ1c2VDYWxsYmFjayIsIiRhVHd1eCR1c2VDYWxsYmFjayIsInVzZVN0YXRlIiwiJGFUd3V4JHVzZVN0YXRlIiwidXNlUmVmIiwiJGFUd3V4JHVzZVJlZiIsIiQyOGY5OWUzZTg2ZTZlYzQ1JHZhciRERUZBVUxUX01JTl9WQUxVRSIsIiQyOGY5OWUzZTg2ZTZlYzQ1JHZhciRERUZBVUxUX01BWF9WQUxVRSIsIiQyOGY5OWUzZTg2ZTZlYzQ1JHZhciRERUZBVUxUX1NURVBfVkFMVUUiLCIkMjhmOTllM2U4NmU2ZWM0NSRleHBvcnQkZTVmZGEzMjQ3ZjVkNjdmOSIsInByb3BzIiwiaXNEaXNhYmxlZCIsIm1pblZhbHVlIiwibWF4VmFsdWUiLCJudW1iZXJGb3JtYXR0ZXIiLCJmb3JtYXR0ZXIiLCJzdGVwIiwib3JpZW50YXRpb24iLCJwYWdlU2l6ZSIsImNhbGNQYWdlU2l6ZSIsIk1hdGgiLCJtYXgiLCJyZXN0cmljdFZhbHVlcyIsInZhbHVlcyIsIm1hcCIsInZhbCIsImlkeCIsIm1pbiIsImxlbmd0aCIsInZhbHVlIiwiJDI4Zjk5ZTNlODZlNmVjNDUkdmFyJGNvbnZlcnRWYWx1ZSIsImRlZmF1bHRWYWx1ZSIsIl9jb252ZXJ0VmFsdWUiLCJvbkNoYW5nZSIsIiQyOGY5OWUzZTg2ZTZlYzQ1JHZhciRjcmVhdGVPbkNoYW5nZSIsIm9uQ2hhbmdlRW5kIiwic2V0VmFsdWVzU3RhdGUiLCJpc0RyYWdnaW5ncyIsInNldERyYWdnaW5nc1N0YXRlIiwiQXJyYXkiLCJmaWxsIiwiaXNFZGl0YWJsZXNSZWYiLCJmb2N1c2VkSW5kZXgiLCJzZXRGb2N1c2VkSW5kZXgiLCJ1bmRlZmluZWQiLCJ2YWx1ZXNSZWYiLCJpc0RyYWdnaW5nc1JlZiIsInNldFZhbHVlcyIsImN1cnJlbnQiLCJzZXREcmFnZ2luZ3MiLCJkcmFnZ2luZ3MiLCJnZXRWYWx1ZVBlcmNlbnQiLCJnZXRUaHVtYk1pblZhbHVlIiwiaW5kZXgiLCJnZXRUaHVtYk1heFZhbHVlIiwiaXNUaHVtYkVkaXRhYmxlIiwic2V0VGh1bWJFZGl0YWJsZSIsImVkaXRhYmxlIiwidXBkYXRlVmFsdWUiLCJ0aGlzTWluIiwidGhpc01heCIsIm5ld1ZhbHVlcyIsIiQyOGY5OWUzZTg2ZTZlYzQ1JHZhciRyZXBsYWNlSW5kZXgiLCJ1cGRhdGVEcmFnZ2luZyIsImRyYWdnaW5nIiwid2FzRHJhZ2dpbmciLCJzb21lIiwiQm9vbGVhbiIsImdldEZvcm1hdHRlZFZhbHVlIiwiZm9ybWF0Iiwic2V0VGh1bWJQZXJjZW50IiwicGVyY2VudCIsImdldFBlcmNlbnRWYWx1ZSIsImdldFJvdW5kZWRWYWx1ZSIsInJvdW5kIiwiaW5jcmVtZW50VGh1bWIiLCJzdGVwU2l6ZSIsInMiLCJkZWNyZW1lbnRUaHVtYiIsImdldFRodW1iVmFsdWUiLCJzZXRUaHVtYlZhbHVlIiwiaXNUaHVtYkRyYWdnaW5nIiwic2V0VGh1bWJEcmFnZ2luZyIsImZvY3VzZWRUaHVtYiIsInNldEZvY3VzZWRUaHVtYiIsImdldFRodW1iUGVyY2VudCIsImdldFRodW1iVmFsdWVMYWJlbCIsImFycmF5Iiwic2xpY2UiLCJpc0FycmF5IiwibmV3VmFsdWUiLCJ1c2VTbGlkZXJTdGF0ZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-stately/slider/dist/import.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-stately/table/dist/import.mjs":
/*!***********************************************************!*\
  !*** ./node_modules/@react-stately/table/dist/import.mjs ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Cell: () => (/* binding */ $941d1d9a6a28982a$export$f6f0c3fe4ec306ea),\n/* harmony export */   Column: () => (/* binding */ $1cd244557c2f97d5$export$816b5d811295e6bc),\n/* harmony export */   Row: () => (/* binding */ $70d70eb16ea48428$export$b59bdbef9ce70de2),\n/* harmony export */   Section: () => (/* reexport safe */ _react_stately_collections__WEBPACK_IMPORTED_MODULE_2__.Section),\n/* harmony export */   TableBody: () => (/* binding */ $4ae5314bf50db1a3$export$76ccd210b9029917),\n/* harmony export */   TableCollection: () => (/* binding */ $788781baa30117fa$export$596e1b2e2cf93690),\n/* harmony export */   TableColumnLayout: () => (/* binding */ $a9e7ae544a4e41dd$export$7ff77a162970b30e),\n/* harmony export */   TableHeader: () => (/* binding */ $312ae3b56a94a86e$export$f850895b287ef28e),\n/* harmony export */   UNSTABLE_useTreeGridState: () => (/* binding */ $ee65a0057fd99531$export$34dfa8a1622185a4),\n/* harmony export */   buildHeaderRows: () => (/* binding */ $788781baa30117fa$export$7c127db850d4e81e),\n/* harmony export */   useTableColumnResizeState: () => (/* binding */ $292bc4e09cd0eb62$export$cb895dcf85db1319),\n/* harmony export */   useTableState: () => (/* binding */ $4a0dd036d492cee4$export$907bcc6c48325fd6)\n/* harmony export */ });\n/* harmony import */ var _react_stately_collections__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @react-stately/collections */ \"(ssr)/./node_modules/@react-stately/collections/dist/import.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _react_stately_grid__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @react-stately/grid */ \"(ssr)/./node_modules/@react-stately/grid/dist/import.mjs\");\n/* harmony import */ var _react_stately_flags__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @react-stately/flags */ \"(ssr)/./node_modules/@react-stately/flags/dist/import.mjs\");\n/* harmony import */ var _react_stately_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @react-stately/utils */ \"(ssr)/./node_modules/@react-stately/utils/dist/import.mjs\");\n\n\n\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n * Copyright 2022 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n * Copyright 2022 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n * Copyright 2022 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ function $6818b1c4fc67028d$export$1994a077b98ee0d5(width) {\n    return width != null && (!isNaN(width) || String(width).match(/^(\\d+)(?=%$)/) !== null);\n}\nfunction $6818b1c4fc67028d$export$9078bad4c3934604(width) {\n    if (!width) return 1;\n    let match = width.match(/^(.+)(?=fr$)/);\n    // if width is the incorrect format, just default it to a 1fr\n    if (!match) {\n        console.warn(`width: ${width} is not a supported format, width should be a number (ex. 150), percentage (ex. '50%') or fr unit (ex. '2fr')`, \"defaulting to '1fr'\");\n        return 1;\n    }\n    return parseFloat(match[0]);\n}\nfunction $6818b1c4fc67028d$export$7bbad27896f7ae9f(width, tableWidth) {\n    if (typeof width === \"string\") {\n        let match = width.match(/^(\\d+)(?=%$)/);\n        if (!match) throw new Error(\"Only percentages or numbers are supported for static column widths\");\n        return tableWidth * (parseFloat(match[0]) / 100);\n    }\n    return width;\n}\nfunction $6818b1c4fc67028d$export$59185c62a7544aa0(maxWidth, tableWidth) {\n    return maxWidth != null ? $6818b1c4fc67028d$export$7bbad27896f7ae9f(maxWidth, tableWidth) : Number.MAX_SAFE_INTEGER;\n}\nfunction $6818b1c4fc67028d$export$f556054ce4358701(minWidth, tableWidth) {\n    return minWidth != null ? $6818b1c4fc67028d$export$7bbad27896f7ae9f(minWidth, tableWidth) : 0;\n}\nfunction $6818b1c4fc67028d$export$55d50dc687385491(availableWidth, columns, changedColumns, getDefaultWidth, getDefaultMinWidth) {\n    let hasNonFrozenItems = false;\n    let flexItems = columns.map((column, index)=>{\n        var _column_width, _ref, _ref1;\n        let width = changedColumns.get(column.key) != null ? changedColumns.get(column.key) : (_ref1 = (_ref = (_column_width = column.width) !== null && _column_width !== void 0 ? _column_width : column.defaultWidth) !== null && _ref !== void 0 ? _ref : getDefaultWidth === null || getDefaultWidth === void 0 ? void 0 : getDefaultWidth(index)) !== null && _ref1 !== void 0 ? _ref1 : \"1fr\";\n        let frozen = false;\n        let baseSize = 0;\n        let flex = 0;\n        let targetMainSize = null;\n        if ($6818b1c4fc67028d$export$1994a077b98ee0d5(width)) {\n            baseSize = $6818b1c4fc67028d$export$7bbad27896f7ae9f(width, availableWidth);\n            frozen = true;\n        } else {\n            flex = $6818b1c4fc67028d$export$9078bad4c3934604(width);\n            if (flex <= 0) frozen = true;\n        }\n        var _column_minWidth, _ref2;\n        let min = $6818b1c4fc67028d$export$f556054ce4358701((_ref2 = (_column_minWidth = column.minWidth) !== null && _column_minWidth !== void 0 ? _column_minWidth : getDefaultMinWidth === null || getDefaultMinWidth === void 0 ? void 0 : getDefaultMinWidth(index)) !== null && _ref2 !== void 0 ? _ref2 : 0, availableWidth);\n        let max = $6818b1c4fc67028d$export$59185c62a7544aa0(column.maxWidth, availableWidth);\n        let hypotheticalMainSize = Math.max(min, Math.min(baseSize, max));\n        // 9.7.1\n        // We don't make use of flex basis, it's always 0, so we are always in 'grow' mode.\n        // 9.7.2\n        if (frozen) targetMainSize = hypotheticalMainSize;\n        else if (baseSize > hypotheticalMainSize) {\n            frozen = true;\n            targetMainSize = hypotheticalMainSize;\n        }\n        // 9.7.3\n        if (!frozen) hasNonFrozenItems = true;\n        return {\n            frozen: frozen,\n            baseSize: baseSize,\n            hypotheticalMainSize: hypotheticalMainSize,\n            min: min,\n            max: max,\n            flex: flex,\n            targetMainSize: targetMainSize,\n            violation: 0\n        };\n    });\n    // 9.7.4\n    // 9.7.4.a\n    while(hasNonFrozenItems){\n        // 9.7.4.b\n        /**\n     * Calculate the remaining free space as for initial free space,\n     * above (9.7.3). If the sum of the unfrozen flex itemsâ€™ flex factors is\n     * less than one, multiply the initial free space by this sum (of flex factors).\n     * If the magnitude of this value is less than the magnitude of\n     * the remaining free space, use this as the remaining free space.\n     */ let usedWidth = 0;\n        let flexFactors = 0;\n        flexItems.forEach((item)=>{\n            if (item.frozen) usedWidth += item.targetMainSize;\n            else {\n                usedWidth += item.baseSize;\n                flexFactors += item.flex;\n            }\n        });\n        let remainingFreeSpace = availableWidth - usedWidth;\n        // we only support integer FR's, and because of hasNonFrozenItems, we know that flexFactors > 0\n        // so no need to check for flexFactors < 1\n        // 9.7.4.c\n        /**\n     * If the remaining free space is zero\n     * - Do nothing.\n     * Else // remember, we're always in grow mode\n     * - Find the ratio of the itemâ€™s flex grow factor to the\n     * sum of the flex grow factors of all unfrozen items on\n     * the line. Set the itemâ€™s target main size to its flex\n     * base size plus a fraction of the remaining free space\n     * proportional to the ratio.\n     */ if (remainingFreeSpace > 0) flexItems.forEach((item)=>{\n            if (!item.frozen) {\n                let ratio = item.flex / flexFactors;\n                item.targetMainSize = item.baseSize + ratio * remainingFreeSpace;\n            }\n        });\n        // 9.7.4.d\n        /**\n     * Fix min/max violations. Clamp each non-frozen itemâ€™s\n     * target main size by its used min and max main sizes\n     * and floor its content-box size at zero. If the itemâ€™s\n     * target main size was made smaller by this, itâ€™s a max\n     * violation. If the itemâ€™s target main size was made\n     * larger by this, itâ€™s a min violation.\n     */ let totalViolation = 0;\n        flexItems.forEach((item)=>{\n            item.violation = 0;\n            if (!item.frozen) {\n                let { min: min, max: max, targetMainSize: targetMainSize } = item;\n                item.targetMainSize = Math.max(min, Math.min(targetMainSize, max));\n                item.violation = item.targetMainSize - targetMainSize;\n                totalViolation += item.violation;\n            }\n        });\n        // 9.7.4.e\n        /**\n     * Freeze over-flexed items. The total violation is the\n     * sum of the adjustments from the previous step\n     * âˆ‘(clamped size - unclamped size). If the total violation is:\n     * Zero\n     * - Freeze all items.\n     *\n     * Positive\n     * - Freeze all the items with min violations.\n     *\n     * Negative\n     * - Freeze all the items with max violations.\n     */ hasNonFrozenItems = false;\n        flexItems.forEach((item)=>{\n            if (totalViolation === 0 || Math.sign(totalViolation) === Math.sign(item.violation)) item.frozen = true;\n            else if (!item.frozen) hasNonFrozenItems = true;\n        });\n    }\n    return $6818b1c4fc67028d$var$cascadeRounding(flexItems);\n}\nfunction $6818b1c4fc67028d$var$cascadeRounding(flexItems) {\n    /*\n  Given an array of floats that sum to an integer, this rounds the floats\n  and returns an array of integers with the same sum.\n  */ let fpTotal = 0;\n    let intTotal = 0;\n    let roundedArray = [];\n    flexItems.forEach(function(item) {\n        let float = item.targetMainSize;\n        let integer = Math.round(float + fpTotal) - intTotal;\n        fpTotal += float;\n        intTotal += integer;\n        roundedArray.push(integer);\n    });\n    return roundedArray;\n}\nclass $a9e7ae544a4e41dd$export$7ff77a162970b30e {\n    /** Takes an array of columns and splits it into 2 maps of columns with controlled and columns with uncontrolled widths. */ splitColumnsIntoControlledAndUncontrolled(columns) {\n        return columns.reduce((acc, col)=>{\n            if (col.props.width != null) acc[0].set(col.key, col);\n            else acc[1].set(col.key, col);\n            return acc;\n        }, [\n            new Map(),\n            new Map()\n        ]);\n    }\n    /** Takes uncontrolled and controlled widths and joins them into a single Map. */ recombineColumns(columns, uncontrolledWidths, uncontrolledColumns, controlledColumns) {\n        return new Map(columns.map((col)=>{\n            if (uncontrolledColumns.has(col.key)) return [\n                col.key,\n                uncontrolledWidths.get(col.key)\n            ];\n            else return [\n                col.key,\n                controlledColumns.get(col.key).props.width\n            ];\n        }));\n    }\n    /** Used to make an initial Map of the uncontrolled widths based on default widths. */ getInitialUncontrolledWidths(uncontrolledColumns) {\n        return new Map(Array.from(uncontrolledColumns).map(([key, col])=>{\n            var _this_getDefaultWidth, _this;\n            var _col_props_defaultWidth, _ref;\n            return [\n                key,\n                (_ref = (_col_props_defaultWidth = col.props.defaultWidth) !== null && _col_props_defaultWidth !== void 0 ? _col_props_defaultWidth : (_this_getDefaultWidth = (_this = this).getDefaultWidth) === null || _this_getDefaultWidth === void 0 ? void 0 : _this_getDefaultWidth.call(_this, col)) !== null && _ref !== void 0 ? _ref : \"1fr\"\n            ];\n        }));\n    }\n    getColumnWidth(key) {\n        var _this_columnWidths_get;\n        return (_this_columnWidths_get = this.columnWidths.get(key)) !== null && _this_columnWidths_get !== void 0 ? _this_columnWidths_get : 0;\n    }\n    getColumnMinWidth(key) {\n        var _this_columnMinWidths_get;\n        return (_this_columnMinWidths_get = this.columnMinWidths.get(key)) !== null && _this_columnMinWidths_get !== void 0 ? _this_columnMinWidths_get : 0;\n    }\n    getColumnMaxWidth(key) {\n        var _this_columnMaxWidths_get;\n        return (_this_columnMaxWidths_get = this.columnMaxWidths.get(key)) !== null && _this_columnMaxWidths_get !== void 0 ? _this_columnMaxWidths_get : 0;\n    }\n    resizeColumnWidth(tableWidth, collection, controlledWidths, uncontrolledWidths, col = null, width) {\n        let prevColumnWidths = this.columnWidths;\n        // resizing a column\n        let resizeIndex = Infinity;\n        let resizingChanged = new Map([\n            ...controlledWidths,\n            ...uncontrolledWidths\n        ]);\n        let percentKeys = new Map();\n        let frKeysToTheRight = new Map();\n        let minWidths = new Map();\n        // freeze columns to the left to their previous pixel value\n        collection.columns.forEach((column, i)=>{\n            var _column_props_width_endsWith, _column_props_width;\n            let frKey;\n            let frValue;\n            minWidths.set(column.key, this.getDefaultMinWidth(collection.columns[i]));\n            if (col !== column.key && !column.props.width && !(0, $6818b1c4fc67028d$export$1994a077b98ee0d5)(uncontrolledWidths.get(column.key))) {\n                // uncontrolled don't have props.width for us, so instead get from our state\n                frKey = column.key;\n                frValue = (0, $6818b1c4fc67028d$export$9078bad4c3934604)(uncontrolledWidths.get(column.key));\n            } else if (col !== column.key && !(0, $6818b1c4fc67028d$export$1994a077b98ee0d5)(column.props.width) && !uncontrolledWidths.get(column.key)) {\n                // controlledWidths will be the same in the collection\n                frKey = column.key;\n                frValue = (0, $6818b1c4fc67028d$export$9078bad4c3934604)(column.props.width);\n            } else if (col !== column.key && ((_column_props_width = column.props.width) === null || _column_props_width === void 0 ? void 0 : (_column_props_width_endsWith = _column_props_width.endsWith) === null || _column_props_width_endsWith === void 0 ? void 0 : _column_props_width_endsWith.call(_column_props_width, \"%\"))) percentKeys.set(column.key, column.props.width);\n            // don't freeze columns to the right of the resizing one\n            if (resizeIndex < i) {\n                if (frKey) frKeysToTheRight.set(frKey, frValue);\n                return;\n            }\n            // we already know the new size of the resizing column\n            if (column.key === col) {\n                resizeIndex = i;\n                resizingChanged.set(column.key, Math.floor(width));\n                return;\n            }\n            // freeze column to previous value\n            resizingChanged.set(column.key, prevColumnWidths.get(column.key));\n        });\n        // predict pixels sizes for all columns based on resize\n        let columnWidths = (0, $6818b1c4fc67028d$export$55d50dc687385491)(tableWidth, collection.columns.map((col)=>({\n                ...col.props,\n                key: col.key\n            })), resizingChanged, (i)=>this.getDefaultWidth(collection.columns[i]), (i)=>this.getDefaultMinWidth(collection.columns[i]));\n        // set all new column widths for onResize event\n        // columns going in will be the same order as the columns coming out\n        let newWidths = new Map();\n        // set all column widths based on calculateColumnSize\n        columnWidths.forEach((width, index)=>{\n            let key = collection.columns[index].key;\n            newWidths.set(key, width);\n        });\n        // add FR's back as they were to columns to the right\n        Array.from(frKeysToTheRight).forEach(([key])=>{\n            newWidths.set(key, `${frKeysToTheRight.get(key)}fr`);\n        });\n        // put back in percents\n        Array.from(percentKeys).forEach(([key, width])=>{\n            // resizing locks a column to a px width\n            if (key === col) return;\n            newWidths.set(key, width);\n        });\n        return newWidths;\n    }\n    buildColumnWidths(tableWidth, collection, widths) {\n        this.columnWidths = new Map();\n        this.columnMinWidths = new Map();\n        this.columnMaxWidths = new Map();\n        // initial layout or table/window resizing\n        let columnWidths = (0, $6818b1c4fc67028d$export$55d50dc687385491)(tableWidth, collection.columns.map((col)=>({\n                ...col.props,\n                key: col.key\n            })), widths, (i)=>this.getDefaultWidth(collection.columns[i]), (i)=>this.getDefaultMinWidth(collection.columns[i]));\n        // columns going in will be the same order as the columns coming out\n        columnWidths.forEach((width, index)=>{\n            let key = collection.columns[index].key;\n            let column = collection.columns[index];\n            this.columnWidths.set(key, width);\n            var _column_props_minWidth;\n            this.columnMinWidths.set(key, (0, $6818b1c4fc67028d$export$f556054ce4358701)((_column_props_minWidth = column.props.minWidth) !== null && _column_props_minWidth !== void 0 ? _column_props_minWidth : this.getDefaultMinWidth(column), tableWidth));\n            this.columnMaxWidths.set(key, (0, $6818b1c4fc67028d$export$59185c62a7544aa0)(column.props.maxWidth, tableWidth));\n        });\n        return this.columnWidths;\n    }\n    constructor(options){\n        this.columnWidths = new Map();\n        this.columnMinWidths = new Map();\n        this.columnMaxWidths = new Map();\n        var _options_getDefaultWidth;\n        this.getDefaultWidth = (_options_getDefaultWidth = options === null || options === void 0 ? void 0 : options.getDefaultWidth) !== null && _options_getDefaultWidth !== void 0 ? _options_getDefaultWidth : ()=>\"1fr\";\n        var _options_getDefaultMinWidth;\n        this.getDefaultMinWidth = (_options_getDefaultMinWidth = options === null || options === void 0 ? void 0 : options.getDefaultMinWidth) !== null && _options_getDefaultMinWidth !== void 0 ? _options_getDefaultMinWidth : ()=>75;\n    }\n}\nfunction $292bc4e09cd0eb62$export$cb895dcf85db1319(props, state) {\n    let { getDefaultWidth: getDefaultWidth, getDefaultMinWidth: getDefaultMinWidth, tableWidth: tableWidth = 0 } = props;\n    let [resizingColumn, setResizingColumn] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    let columnLayout = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>new (0, $a9e7ae544a4e41dd$export$7ff77a162970b30e)({\n            getDefaultWidth: getDefaultWidth,\n            getDefaultMinWidth: getDefaultMinWidth\n        }), [\n        getDefaultWidth,\n        getDefaultMinWidth\n    ]);\n    let [controlledColumns, uncontrolledColumns] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>columnLayout.splitColumnsIntoControlledAndUncontrolled(state.collection.columns), [\n        state.collection.columns,\n        columnLayout\n    ]);\n    // uncontrolled column widths\n    let [uncontrolledWidths, setUncontrolledWidths] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(()=>columnLayout.getInitialUncontrolledWidths(uncontrolledColumns));\n    // Update uncontrolled widths if the columns changed.\n    let [lastColumns, setLastColumns] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(state.collection.columns);\n    if (state.collection.columns !== lastColumns) {\n        if (state.collection.columns.length !== lastColumns.length || state.collection.columns.some((c, i)=>c.key !== lastColumns[i].key)) {\n            let newUncontrolledWidths = columnLayout.getInitialUncontrolledWidths(uncontrolledColumns);\n            setUncontrolledWidths(newUncontrolledWidths);\n        }\n        setLastColumns(state.collection.columns);\n    }\n    // combine columns back into one map that maintains same order as the columns\n    let colWidths = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>columnLayout.recombineColumns(state.collection.columns, uncontrolledWidths, uncontrolledColumns, controlledColumns), [\n        state.collection.columns,\n        uncontrolledWidths,\n        uncontrolledColumns,\n        controlledColumns,\n        columnLayout\n    ]);\n    let startResize = (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((key)=>{\n        setResizingColumn(key);\n    }, [\n        setResizingColumn\n    ]);\n    let updateResizedColumns = (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((key, width)=>{\n        let newControlled = new Map(Array.from(controlledColumns).map(([key, entry])=>[\n                key,\n                entry.props.width\n            ]));\n        let newSizes = columnLayout.resizeColumnWidth(tableWidth, state.collection, newControlled, uncontrolledWidths, key, width);\n        let map = new Map(Array.from(uncontrolledColumns).map(([key])=>[\n                key,\n                newSizes.get(key)\n            ]));\n        map.set(key, width);\n        setUncontrolledWidths(map);\n        return newSizes;\n    }, [\n        controlledColumns,\n        uncontrolledColumns,\n        setUncontrolledWidths,\n        tableWidth,\n        columnLayout,\n        state.collection,\n        uncontrolledWidths\n    ]);\n    let endResize = (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        setResizingColumn(null);\n    }, [\n        setResizingColumn\n    ]);\n    (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>columnLayout.buildColumnWidths(tableWidth, state.collection, colWidths), [\n        tableWidth,\n        state.collection,\n        colWidths,\n        columnLayout\n    ]);\n    return (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>({\n            resizingColumn: resizingColumn,\n            updateResizedColumns: updateResizedColumns,\n            startResize: startResize,\n            endResize: endResize,\n            getColumnWidth: (key)=>columnLayout.getColumnWidth(key),\n            getColumnMinWidth: (key)=>columnLayout.getColumnMinWidth(key),\n            getColumnMaxWidth: (key)=>columnLayout.getColumnMaxWidth(key),\n            tableState: state\n        }), [\n        columnLayout,\n        resizingColumn,\n        updateResizedColumns,\n        startResize,\n        endResize,\n        state\n    ]);\n}\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ const $788781baa30117fa$var$ROW_HEADER_COLUMN_KEY = \"row-header-column-\" + Math.random().toString(36).slice(2);\nlet $788781baa30117fa$var$ROW_HEADER_COLUMN_KEY_DRAG = \"row-header-column-\" + Math.random().toString(36).slice(2);\nwhile($788781baa30117fa$var$ROW_HEADER_COLUMN_KEY === $788781baa30117fa$var$ROW_HEADER_COLUMN_KEY_DRAG)$788781baa30117fa$var$ROW_HEADER_COLUMN_KEY_DRAG = \"row-header-column-\" + Math.random().toString(36).slice(2);\nfunction $788781baa30117fa$export$7c127db850d4e81e(keyMap, columnNodes) {\n    if (columnNodes.length === 0) return [];\n    let columns = [];\n    let seen = new Map();\n    for (let column of columnNodes){\n        let parentKey = column.parentKey;\n        let col = [\n            column\n        ];\n        while(parentKey){\n            let parent = keyMap.get(parentKey);\n            if (!parent) break;\n            // If we've already seen this parent, than it is shared\n            // with a previous column. If the current column is taller\n            // than the previous column, than we need to shift the parent\n            // in the previous column so it's level with the current column.\n            if (seen.has(parent)) {\n                parent.colspan++;\n                let { column: column, index: index } = seen.get(parent);\n                if (index > col.length) break;\n                for(let i = index; i < col.length; i++)column.splice(i, 0, null);\n                // Adjust shifted indices\n                for(let i = col.length; i < column.length; i++)if (column[i] && seen.has(column[i])) seen.get(column[i]).index = i;\n            } else {\n                parent.colspan = 1;\n                col.push(parent);\n                seen.set(parent, {\n                    column: col,\n                    index: col.length - 1\n                });\n            }\n            parentKey = parent.parentKey;\n        }\n        columns.push(col);\n        column.index = columns.length - 1;\n    }\n    let maxLength = Math.max(...columns.map((c)=>c.length));\n    let headerRows = Array(maxLength).fill(0).map(()=>[]);\n    // Convert columns into rows.\n    let colIndex = 0;\n    for (let column of columns){\n        let i = maxLength - 1;\n        for (let item of column){\n            if (item) {\n                // Fill the space up until the current column with a placeholder\n                let row = headerRows[i];\n                let rowLength = row.reduce((p, c)=>p + c.colspan, 0);\n                if (rowLength < colIndex) {\n                    let placeholder = {\n                        type: \"placeholder\",\n                        key: \"placeholder-\" + item.key,\n                        colspan: colIndex - rowLength,\n                        index: rowLength,\n                        value: null,\n                        rendered: null,\n                        level: i,\n                        hasChildNodes: false,\n                        childNodes: [],\n                        textValue: null\n                    };\n                    // eslint-disable-next-line max-depth\n                    if (row.length > 0) {\n                        row[row.length - 1].nextKey = placeholder.key;\n                        placeholder.prevKey = row[row.length - 1].key;\n                    }\n                    row.push(placeholder);\n                }\n                if (row.length > 0) {\n                    row[row.length - 1].nextKey = item.key;\n                    item.prevKey = row[row.length - 1].key;\n                }\n                item.level = i;\n                item.colIndex = colIndex;\n                row.push(item);\n            }\n            i--;\n        }\n        colIndex++;\n    }\n    // Add placeholders at the end of each row that is shorter than the maximum\n    let i = 0;\n    for (let row of headerRows){\n        let rowLength = row.reduce((p, c)=>p + c.colspan, 0);\n        if (rowLength < columnNodes.length) {\n            let placeholder = {\n                type: \"placeholder\",\n                key: \"placeholder-\" + row[row.length - 1].key,\n                colspan: columnNodes.length - rowLength,\n                index: rowLength,\n                value: null,\n                rendered: null,\n                level: i,\n                hasChildNodes: false,\n                childNodes: [],\n                textValue: null,\n                prevKey: row[row.length - 1].key\n            };\n            row.push(placeholder);\n        }\n        i++;\n    }\n    return headerRows.map((childNodes, index)=>{\n        let row = {\n            type: \"headerrow\",\n            key: \"headerrow-\" + index,\n            index: index,\n            value: null,\n            rendered: null,\n            level: 0,\n            hasChildNodes: true,\n            childNodes: childNodes,\n            textValue: null\n        };\n        return row;\n    });\n}\nclass $788781baa30117fa$export$596e1b2e2cf93690 extends (0, _react_stately_grid__WEBPACK_IMPORTED_MODULE_1__.GridCollection) {\n    *[Symbol.iterator]() {\n        yield* this.body.childNodes;\n    }\n    get size() {\n        return this._size;\n    }\n    getKeys() {\n        return this.keyMap.keys();\n    }\n    getKeyBefore(key) {\n        let node = this.keyMap.get(key);\n        return node ? node.prevKey : null;\n    }\n    getKeyAfter(key) {\n        let node = this.keyMap.get(key);\n        return node ? node.nextKey : null;\n    }\n    getFirstKey() {\n        var _getFirstItem;\n        return (_getFirstItem = (0, _react_stately_collections__WEBPACK_IMPORTED_MODULE_2__.getFirstItem)(this.body.childNodes)) === null || _getFirstItem === void 0 ? void 0 : _getFirstItem.key;\n    }\n    getLastKey() {\n        var _getLastItem;\n        return (_getLastItem = (0, _react_stately_collections__WEBPACK_IMPORTED_MODULE_2__.getLastItem)(this.body.childNodes)) === null || _getLastItem === void 0 ? void 0 : _getLastItem.key;\n    }\n    getItem(key) {\n        return this.keyMap.get(key);\n    }\n    at(idx) {\n        const keys = [\n            ...this.getKeys()\n        ];\n        return this.getItem(keys[idx]);\n    }\n    getTextValue(key) {\n        let row = this.getItem(key);\n        if (!row) return \"\";\n        // If the row has a textValue, use that.\n        if (row.textValue) return row.textValue;\n        // Otherwise combine the text of each of the row header columns.\n        let rowHeaderColumnKeys = this.rowHeaderColumnKeys;\n        if (rowHeaderColumnKeys) {\n            let text = [];\n            for (let cell of row.childNodes){\n                let column = this.columns[cell.index];\n                if (rowHeaderColumnKeys.has(column.key) && cell.textValue) text.push(cell.textValue);\n                if (text.length === rowHeaderColumnKeys.size) break;\n            }\n            return text.join(\" \");\n        }\n        return \"\";\n    }\n    constructor(nodes, prev, opts){\n        let rowHeaderColumnKeys = new Set();\n        let body;\n        let columns = [];\n        // Add cell for selection checkboxes if needed.\n        if (opts === null || opts === void 0 ? void 0 : opts.showSelectionCheckboxes) {\n            let rowHeaderColumn = {\n                type: \"column\",\n                key: $788781baa30117fa$var$ROW_HEADER_COLUMN_KEY,\n                value: null,\n                textValue: \"\",\n                level: 0,\n                index: (opts === null || opts === void 0 ? void 0 : opts.showDragButtons) ? 1 : 0,\n                hasChildNodes: false,\n                rendered: null,\n                childNodes: [],\n                props: {\n                    isSelectionCell: true\n                }\n            };\n            columns.unshift(rowHeaderColumn);\n        }\n        // Add cell for drag buttons if needed.\n        if (opts === null || opts === void 0 ? void 0 : opts.showDragButtons) {\n            let rowHeaderColumn = {\n                type: \"column\",\n                key: $788781baa30117fa$var$ROW_HEADER_COLUMN_KEY_DRAG,\n                value: null,\n                textValue: \"\",\n                level: 0,\n                index: 0,\n                hasChildNodes: false,\n                rendered: null,\n                childNodes: [],\n                props: {\n                    isDragButtonCell: true\n                }\n            };\n            columns.unshift(rowHeaderColumn);\n        }\n        let rows = [];\n        let columnKeyMap = new Map();\n        let visit = (node)=>{\n            switch(node.type){\n                case \"body\":\n                    body = node;\n                    break;\n                case \"column\":\n                    columnKeyMap.set(node.key, node);\n                    if (!node.hasChildNodes) {\n                        columns.push(node);\n                        if (node.props.isRowHeader) rowHeaderColumnKeys.add(node.key);\n                    }\n                    break;\n                case \"item\":\n                    rows.push(node);\n                    return; // do not go into childNodes\n            }\n            for (let child of node.childNodes)visit(child);\n        };\n        for (let node of nodes)visit(node);\n        let headerRows = $788781baa30117fa$export$7c127db850d4e81e(columnKeyMap, columns);\n        headerRows.forEach((row, i)=>rows.splice(i, 0, row));\n        super({\n            columnCount: columns.length,\n            items: rows,\n            visitNode: (node)=>{\n                node.column = columns[node.index];\n                return node;\n            }\n        });\n        this._size = 0;\n        this.columns = columns;\n        this.rowHeaderColumnKeys = rowHeaderColumnKeys;\n        this.body = body;\n        this.headerRows = headerRows;\n        this._size = [\n            ...body.childNodes\n        ].length;\n        // Default row header column to the first one.\n        if (this.rowHeaderColumnKeys.size === 0) {\n            if (opts === null || opts === void 0 ? void 0 : opts.showSelectionCheckboxes) {\n                if (opts === null || opts === void 0 ? void 0 : opts.showDragButtons) this.rowHeaderColumnKeys.add(this.columns[2].key);\n                else this.rowHeaderColumnKeys.add(this.columns[1].key);\n            } else this.rowHeaderColumnKeys.add(this.columns[0].key);\n        }\n    }\n}\nconst $4a0dd036d492cee4$var$OPPOSITE_SORT_DIRECTION = {\n    ascending: \"descending\",\n    descending: \"ascending\"\n};\nfunction $4a0dd036d492cee4$export$907bcc6c48325fd6(props) {\n    let [isKeyboardNavigationDisabled, setKeyboardNavigationDisabled] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    let { selectionMode: selectionMode = \"none\", showSelectionCheckboxes: showSelectionCheckboxes, showDragButtons: showDragButtons } = props;\n    let context = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>({\n            showSelectionCheckboxes: showSelectionCheckboxes && selectionMode !== \"none\",\n            showDragButtons: showDragButtons,\n            selectionMode: selectionMode,\n            columns: []\n        }), [\n        props.children,\n        showSelectionCheckboxes,\n        selectionMode,\n        showDragButtons\n    ]);\n    let collection = (0, _react_stately_collections__WEBPACK_IMPORTED_MODULE_2__.useCollection)(props, (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((nodes)=>new (0, $788781baa30117fa$export$596e1b2e2cf93690)(nodes, null, context), [\n        context\n    ]), context);\n    let { disabledKeys: disabledKeys, selectionManager: selectionManager } = (0, _react_stately_grid__WEBPACK_IMPORTED_MODULE_1__.useGridState)({\n        ...props,\n        collection: collection,\n        disabledBehavior: props.disabledBehavior || \"selection\"\n    });\n    return {\n        collection: collection,\n        disabledKeys: disabledKeys,\n        selectionManager: selectionManager,\n        showSelectionCheckboxes: props.showSelectionCheckboxes || false,\n        sortDescriptor: props.sortDescriptor,\n        isKeyboardNavigationDisabled: collection.size === 0 || isKeyboardNavigationDisabled,\n        setKeyboardNavigationDisabled: setKeyboardNavigationDisabled,\n        sort (columnKey, direction) {\n            var _props_sortDescriptor;\n            props.onSortChange({\n                column: columnKey,\n                direction: direction !== null && direction !== void 0 ? direction : ((_props_sortDescriptor = props.sortDescriptor) === null || _props_sortDescriptor === void 0 ? void 0 : _props_sortDescriptor.column) === columnKey ? $4a0dd036d492cee4$var$OPPOSITE_SORT_DIRECTION[props.sortDescriptor.direction] : \"ascending\"\n            });\n        }\n    };\n}\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ function $312ae3b56a94a86e$var$TableHeader(props) {\n    return null;\n}\n$312ae3b56a94a86e$var$TableHeader.getCollectionNode = function* getCollectionNode(props, context) {\n    let { children: children, columns: columns } = props;\n    // Clear columns so they aren't double added in strict mode.\n    context.columns = [];\n    if (typeof children === \"function\") {\n        if (!columns) throw new Error(\"props.children was a function but props.columns is missing\");\n        for (let column of columns)yield {\n            type: \"column\",\n            value: column,\n            renderer: children\n        };\n    } else {\n        let columns = [];\n        (0, react__WEBPACK_IMPORTED_MODULE_0__).Children.forEach(children, (column)=>{\n            columns.push({\n                type: \"column\",\n                element: column\n            });\n        });\n        yield* columns;\n    }\n};\n/**\n * A TableHeader is a container for the Column elements in a Table. Columns can be statically defined\n * as children, or generated dynamically using a function based on the data passed to the `columns` prop.\n */ // We don't want getCollectionNode to show up in the type definition\nlet $312ae3b56a94a86e$export$f850895b287ef28e = $312ae3b56a94a86e$var$TableHeader;\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ function $4ae5314bf50db1a3$var$TableBody(props) {\n    return null;\n}\n$4ae5314bf50db1a3$var$TableBody.getCollectionNode = function* getCollectionNode(props) {\n    let { children: children, items: items } = props;\n    yield {\n        type: \"body\",\n        hasChildNodes: true,\n        props: props,\n        *childNodes () {\n            if (typeof children === \"function\") {\n                if (!items) throw new Error(\"props.children was a function but props.items is missing\");\n                for (let item of items)yield {\n                    type: \"item\",\n                    value: item,\n                    renderer: children\n                };\n            } else {\n                let items = [];\n                (0, react__WEBPACK_IMPORTED_MODULE_0__).Children.forEach(children, (item)=>{\n                    items.push({\n                        type: \"item\",\n                        element: item\n                    });\n                });\n                yield* items;\n            }\n        }\n    };\n};\n/**\n * A TableBody is a container for the Row elements of a Table. Rows can be statically defined\n * as children, or generated dynamically using a function based on the data passed to the `items` prop.\n */ // We don't want getCollectionNode to show up in the type definition\nlet $4ae5314bf50db1a3$export$76ccd210b9029917 = $4ae5314bf50db1a3$var$TableBody;\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ function $1cd244557c2f97d5$var$Column(props) {\n    return null;\n}\n$1cd244557c2f97d5$var$Column.getCollectionNode = function* getCollectionNode(props, context) {\n    let { title: title, children: children, childColumns: childColumns } = props;\n    let rendered = title || children;\n    let textValue = props.textValue || (typeof rendered === \"string\" ? rendered : \"\") || props[\"aria-label\"];\n    let fullNodes = yield {\n        type: \"column\",\n        hasChildNodes: !!childColumns || title && (0, react__WEBPACK_IMPORTED_MODULE_0__).Children.count(children) > 0,\n        rendered: rendered,\n        textValue: textValue,\n        props: props,\n        *childNodes () {\n            if (childColumns) for (let child of childColumns)yield {\n                type: \"column\",\n                value: child\n            };\n            else if (title) {\n                let childColumns = [];\n                (0, react__WEBPACK_IMPORTED_MODULE_0__).Children.forEach(children, (child)=>{\n                    childColumns.push({\n                        type: \"column\",\n                        element: child\n                    });\n                });\n                yield* childColumns;\n            }\n        },\n        shouldInvalidate (newContext) {\n            // This is a bit of a hack, but it works.\n            // If this method is called, then there's a cached version of this node available.\n            // But, we need to keep the list of columns in the new context up to date.\n            updateContext(newContext);\n            return false;\n        }\n    };\n    let updateContext = (context)=>{\n        // register leaf columns on the context so that <Row> can access them\n        for (let node of fullNodes)if (!node.hasChildNodes) context.columns.push(node);\n    };\n    updateContext(context);\n};\n/**\n * A Column represents a field of each item within a Table. Columns may also contain nested\n * Column elements to represent column groups. Nested columns can be statically defined as\n * children, or dynamically generated using a function based on the `childColumns` prop.\n */ // We don't want getCollectionNode to show up in the type definition\nlet $1cd244557c2f97d5$export$816b5d811295e6bc = $1cd244557c2f97d5$var$Column;\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ function $70d70eb16ea48428$var$Row(props) {\n    return null;\n}\n$70d70eb16ea48428$var$Row.getCollectionNode = function* getCollectionNode(props, context) {\n    let { children: children, textValue: textValue, UNSTABLE_childItems: UNSTABLE_childItems } = props;\n    yield {\n        type: \"item\",\n        props: props,\n        textValue: textValue,\n        \"aria-label\": props[\"aria-label\"],\n        hasChildNodes: true,\n        *childNodes () {\n            // Process cells first\n            if (context.showDragButtons) yield {\n                type: \"cell\",\n                key: \"header-drag\",\n                props: {\n                    isDragButtonCell: true\n                }\n            };\n            if (context.showSelectionCheckboxes && context.selectionMode !== \"none\") yield {\n                type: \"cell\",\n                key: \"header\",\n                props: {\n                    isSelectionCell: true\n                }\n            };\n            if (typeof children === \"function\") {\n                for (let column of context.columns)yield {\n                    type: \"cell\",\n                    element: children(column.key),\n                    key: column.key // this is combined with the row key by CollectionBuilder\n                };\n                if (UNSTABLE_childItems) for (let child of UNSTABLE_childItems)// the parent renderer and use that to build the full node of this child row, using the value provided here to generate the cells\n                yield {\n                    type: \"item\",\n                    value: child\n                };\n            } else {\n                let cells = [];\n                let childRows = [];\n                (0, react__WEBPACK_IMPORTED_MODULE_0__).Children.forEach(children, (node)=>{\n                    if (node.type === $70d70eb16ea48428$var$Row) {\n                        if (cells.length < context.columns.length) throw new Error(\"All of a Row's child Cells must be positioned before any child Rows.\");\n                        childRows.push({\n                            type: \"item\",\n                            element: node\n                        });\n                    } else cells.push({\n                        type: \"cell\",\n                        element: node\n                    });\n                });\n                if (cells.length !== context.columns.length) throw new Error(`Cell count must match column count. Found ${cells.length} cells and ${context.columns.length} columns.`);\n                yield* cells;\n                yield* childRows;\n            }\n        },\n        shouldInvalidate (newContext) {\n            // Invalidate all rows if the columns changed.\n            return newContext.columns.length !== context.columns.length || newContext.columns.some((c, i)=>c.key !== context.columns[i].key) || newContext.showSelectionCheckboxes !== context.showSelectionCheckboxes || newContext.showDragButtons !== context.showDragButtons || newContext.selectionMode !== context.selectionMode;\n        }\n    };\n};\n/**\n * A Row represents a single item in a Table and contains Cell elements for each column.\n * Cells can be statically defined as children, or generated dynamically using a function\n * based on the columns defined in the TableHeader.\n */ // We don't want getCollectionNode to show up in the type definition\nlet $70d70eb16ea48428$export$b59bdbef9ce70de2 = $70d70eb16ea48428$var$Row;\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ function $941d1d9a6a28982a$var$Cell(props) {\n    return null;\n}\n$941d1d9a6a28982a$var$Cell.getCollectionNode = function* getCollectionNode(props) {\n    let { children: children } = props;\n    let textValue = props.textValue || (typeof children === \"string\" ? children : \"\") || props[\"aria-label\"] || \"\";\n    yield {\n        type: \"cell\",\n        props: props,\n        rendered: children,\n        textValue: textValue,\n        \"aria-label\": props[\"aria-label\"],\n        hasChildNodes: false\n    };\n};\n/**\n * A Cell represents the value of a single Column within a Table Row.\n */ // We don't want getCollectionNode to show up in the type definition\nlet $941d1d9a6a28982a$export$f6f0c3fe4ec306ea = $941d1d9a6a28982a$var$Cell;\n/*\n * Copyright 2023 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ function $ee65a0057fd99531$export$34dfa8a1622185a4(props) {\n    let { selectionMode: selectionMode = \"none\", showSelectionCheckboxes: showSelectionCheckboxes, showDragButtons: showDragButtons, UNSTABLE_expandedKeys: propExpandedKeys, UNSTABLE_defaultExpandedKeys: propDefaultExpandedKeys, UNSTABLE_onExpandedChange: UNSTABLE_onExpandedChange, children: children } = props;\n    if (!(0, _react_stately_flags__WEBPACK_IMPORTED_MODULE_3__.tableNestedRows)()) throw new Error(\"Feature flag for table nested rows must be enabled to use useTreeGridState.\");\n    let [expandedKeys, setExpandedKeys] = (0, _react_stately_utils__WEBPACK_IMPORTED_MODULE_4__.useControlledState)(propExpandedKeys ? $ee65a0057fd99531$var$convertExpanded(propExpandedKeys) : undefined, propDefaultExpandedKeys ? $ee65a0057fd99531$var$convertExpanded(propDefaultExpandedKeys) : new Set(), UNSTABLE_onExpandedChange);\n    let context = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>({\n            showSelectionCheckboxes: showSelectionCheckboxes && selectionMode !== \"none\",\n            showDragButtons: showDragButtons,\n            selectionMode: selectionMode,\n            columns: []\n        }), [\n        children,\n        showSelectionCheckboxes,\n        selectionMode,\n        showDragButtons\n    ]);\n    let builder = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>new (0, _react_stately_collections__WEBPACK_IMPORTED_MODULE_2__.CollectionBuilder)(), []);\n    let nodes = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>builder.build({\n            children: children\n        }, context), [\n        builder,\n        children,\n        context\n    ]);\n    let treeGridCollection = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        return $ee65a0057fd99531$var$generateTreeGridCollection(nodes, {\n            showSelectionCheckboxes: showSelectionCheckboxes,\n            showDragButtons: showDragButtons,\n            expandedKeys: expandedKeys\n        });\n    }, [\n        nodes,\n        showSelectionCheckboxes,\n        showDragButtons,\n        expandedKeys\n    ]);\n    let onToggle = (key)=>{\n        setExpandedKeys($ee65a0057fd99531$var$toggleKey(expandedKeys, key, treeGridCollection));\n    };\n    let collection = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        return new (0, $788781baa30117fa$export$596e1b2e2cf93690)(treeGridCollection.tableNodes, null, context);\n    }, [\n        context,\n        treeGridCollection.tableNodes\n    ]);\n    let tableState = (0, $4a0dd036d492cee4$export$907bcc6c48325fd6)({\n        ...props,\n        collection: collection\n    });\n    return {\n        ...tableState,\n        keyMap: treeGridCollection.keyMap,\n        userColumnCount: treeGridCollection.userColumnCount,\n        expandedKeys: expandedKeys,\n        toggleKey: onToggle\n    };\n}\nfunction $ee65a0057fd99531$var$toggleKey(currentExpandedKeys, key, collection) {\n    let updatedExpandedKeys;\n    if (currentExpandedKeys === \"all\") {\n        updatedExpandedKeys = new Set(collection.flattenedRows.filter((row)=>row.props.UNSTABLE_childItems || row.props.children.length > collection.userColumnCount).map((row)=>row.key));\n        updatedExpandedKeys.delete(key);\n    } else {\n        updatedExpandedKeys = new Set(currentExpandedKeys);\n        if (updatedExpandedKeys.has(key)) updatedExpandedKeys.delete(key);\n        else updatedExpandedKeys.add(key);\n    }\n    return updatedExpandedKeys;\n}\nfunction $ee65a0057fd99531$var$convertExpanded(expanded) {\n    if (!expanded) return new Set();\n    return expanded === \"all\" ? \"all\" : new Set(expanded);\n}\nfunction $ee65a0057fd99531$var$generateTreeGridCollection(nodes, opts) {\n    let { expandedKeys: expandedKeys = new Set() } = opts;\n    let body;\n    let flattenedRows = [];\n    let columnCount = 0;\n    let userColumnCount = 0;\n    let originalColumns = [];\n    let keyMap = new Map();\n    if (opts === null || opts === void 0 ? void 0 : opts.showSelectionCheckboxes) columnCount++;\n    if (opts === null || opts === void 0 ? void 0 : opts.showDragButtons) columnCount++;\n    let topLevelRows = [];\n    let visit = (node)=>{\n        switch(node.type){\n            case \"body\":\n                body = node;\n                keyMap.set(body.key, body);\n                break;\n            case \"column\":\n                if (!node.hasChildNodes) userColumnCount++;\n                break;\n            case \"item\":\n                topLevelRows.push(node);\n                return;\n        }\n        for (let child of node.childNodes)visit(child);\n    };\n    for (let node of nodes){\n        if (node.type === \"column\") originalColumns.push(node);\n        visit(node);\n    }\n    columnCount += userColumnCount;\n    // Update each grid node in the treegrid table with values specific to a treegrid structure. Also store a set of flattened row nodes for TableCollection to consume\n    let globalRowCount = 0;\n    let visitNode = (node, i)=>{\n        // Clone row node and its children so modifications to the node for treegrid specific values aren't applied on the nodes provided\n        // to TableCollection. Index, level, and parent keys are all changed to reflect a flattened row structure rather than the treegrid structure\n        // values automatically calculated via CollectionBuilder\n        if (node.type === \"item\") {\n            let childNodes = [];\n            for (let child of node.childNodes)if (child.type === \"cell\") {\n                let cellClone = {\n                    ...child\n                };\n                if (cellClone.index + 1 === columnCount) cellClone.nextKey = null;\n                childNodes.push({\n                    ...cellClone\n                });\n            }\n            let clone = {\n                ...node,\n                childNodes: childNodes,\n                parentKey: body.key,\n                level: 1,\n                index: globalRowCount++\n            };\n            flattenedRows.push(clone);\n        }\n        let newProps = {};\n        // Assign indexOfType to cells and rows for aria-posinset\n        if (node.type !== \"placeholder\" && node.type !== \"column\") newProps[\"indexOfType\"] = i;\n        // Use Object.assign instead of spread to preserve object reference for keyMap. Also ensures retrieving nodes\n        // via .childNodes returns the same object as the one found via keyMap look up\n        Object.assign(node, newProps);\n        keyMap.set(node.key, node);\n        let lastNode;\n        let rowIndex = 0;\n        for (let child of node.childNodes)if (!(child.type === \"item\" && expandedKeys !== \"all\" && !expandedKeys.has(node.key))) {\n            if (child.parentKey == null) child.parentKey = node.key;\n            if (lastNode) {\n                lastNode.nextKey = child.key;\n                child.prevKey = lastNode.key;\n            } else child.prevKey = null;\n            if (child.type === \"item\") visitNode(child, rowIndex++);\n            else visitNode(child, child.index);\n            lastNode = child;\n        }\n        if (lastNode) lastNode.nextKey = null;\n    };\n    let last;\n    topLevelRows.forEach((node, i)=>{\n        visitNode(node, i);\n        if (last) {\n            last.nextKey = node.key;\n            node.prevKey = last.key;\n        } else node.prevKey = null;\n        last = node;\n    });\n    if (last) last.nextKey = null;\n    return {\n        keyMap: keyMap,\n        userColumnCount: userColumnCount,\n        flattenedRows: flattenedRows,\n        tableNodes: [\n            ...originalColumns,\n            {\n                ...body,\n                childNodes: flattenedRows\n            }\n        ]\n    };\n}\n //# sourceMappingURL=module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXN0YXRlbHkvdGFibGUvZGlzdC9pbXBvcnQubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQXdQO0FBQzFIO0FBQ2I7QUFDbEM7QUFDTTtBQUVyRjs7Ozs7Ozs7OztDQVVDLEdBQUc7Ozs7Ozs7Ozs7Q0FVSCxHQUFHOzs7Ozs7Ozs7O0NBVUgsR0FBRzs7Ozs7Ozs7OztDQVVILEdBQUcsU0FBU3lCLDBDQUEwQ0MsS0FBSztJQUN4RCxPQUFPQSxTQUFTLFFBQVMsRUFBQ0MsTUFBTUQsVUFBVUUsT0FBT0YsT0FBT0csS0FBSyxDQUFDLG9CQUFvQixJQUFHO0FBQ3pGO0FBQ0EsU0FBU0MsMENBQTBDSixLQUFLO0lBQ3BELElBQUksQ0FBQ0EsT0FBTyxPQUFPO0lBQ25CLElBQUlHLFFBQVFILE1BQU1HLEtBQUssQ0FBQztJQUN4Qiw2REFBNkQ7SUFDN0QsSUFBSSxDQUFDQSxPQUFPO1FBQ1JFLFFBQVFDLElBQUksQ0FBQyxDQUFDLE9BQU8sRUFBRU4sTUFBTSw2R0FBNkcsQ0FBQyxFQUFFO1FBQzdJLE9BQU87SUFDWDtJQUNBLE9BQU9PLFdBQVdKLEtBQUssQ0FBQyxFQUFFO0FBQzlCO0FBQ0EsU0FBU0ssMENBQTBDUixLQUFLLEVBQUVTLFVBQVU7SUFDaEUsSUFBSSxPQUFPVCxVQUFVLFVBQVU7UUFDM0IsSUFBSUcsUUFBUUgsTUFBTUcsS0FBSyxDQUFDO1FBQ3hCLElBQUksQ0FBQ0EsT0FBTyxNQUFNLElBQUlPLE1BQU07UUFDNUIsT0FBT0QsYUFBY0YsQ0FBQUEsV0FBV0osS0FBSyxDQUFDLEVBQUUsSUFBSSxHQUFFO0lBQ2xEO0lBQ0EsT0FBT0g7QUFDWDtBQUNBLFNBQVNXLDBDQUEwQ0MsUUFBUSxFQUFFSCxVQUFVO0lBQ25FLE9BQU9HLFlBQVksT0FBT0osMENBQTBDSSxVQUFVSCxjQUFjSSxPQUFPQyxnQkFBZ0I7QUFDdkg7QUFDQSxTQUFTQywwQ0FBMENDLFFBQVEsRUFBRVAsVUFBVTtJ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TUFBTUEsS0FBS3pILE9BQU8sR0FBRztJQUN6QixPQUFPO1FBQ0h0QixRQUFRQTtRQUNSNkgsaUJBQWlCQTtRQUNqQkksZUFBZUE7UUFDZkwsWUFBWTtlQUNMUztZQUNIO2dCQUNJLEdBQUcxRyxJQUFJO2dCQUNQUCxZQUFZNkc7WUFDaEI7U0FDSDtJQUNMO0FBQ0o7QUFLNHNCLENBQzVzQixrQ0FBa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LWZsYXNrLy4vbm9kZV9tb2R1bGVzL0ByZWFjdC1zdGF0ZWx5L3RhYmxlL2Rpc3QvaW1wb3J0Lm1qcz82Y2RjIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7U2VjdGlvbiBhcyAkNjU1NTEwNGZmMDg1YmVmNCRyZV9leHBvcnQkU2VjdGlvbiwgdXNlQ29sbGVjdGlvbiBhcyAkMUJmalckdXNlQ29sbGVjdGlvbiwgZ2V0Rmlyc3RJdGVtIGFzICQxQmZqVyRnZXRGaXJzdEl0ZW0sIGdldExhc3RJdGVtIGFzICQxQmZqVyRnZXRMYXN0SXRlbSwgQ29sbGVjdGlvbkJ1aWxkZXIgYXMgJDFCZmpXJENvbGxlY3Rpb25CdWlsZGVyfSBmcm9tIFwiQHJlYWN0LXN0YXRlbHkvY29sbGVjdGlvbnNcIjtcbmltcG9ydCAkMUJmalckcmVhY3QsIHt1c2VTdGF0ZSBhcyAkMUJmalckdXNlU3RhdGUsIHVzZU1lbW8gYXMgJDFCZmpXJHVzZU1lbW8sIHVzZUNhbGxiYWNrIGFzICQxQmZqVyR1c2VDYWxsYmFja30gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQge3VzZUdyaWRTdGF0ZSBhcyAkMUJmalckdXNlR3JpZFN0YXRlLCBHcmlkQ29sbGVjdGlvbiBhcyAkMUJmalckR3JpZENvbGxlY3Rpb259IGZyb20gXCJAcmVhY3Qtc3RhdGVseS9ncmlkXCI7XG5pbXBvcnQge3RhYmxlTmVzdGVkUm93cyBhcyAkMUJmalckdGFibGVOZXN0ZWRSb3dzfSBmcm9tIFwiQHJlYWN0LXN0YXRlbHkvZmxhZ3NcIjtcbmltcG9ydCB7dXNlQ29udHJvbGxlZFN0YXRlIGFzICQxQmZqVyR1c2VDb250cm9sbGVkU3RhdGV9IGZyb20gXCJAcmVhY3Qtc3RhdGVseS91dGlsc1wiO1xuXG4vKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gLypcbiAqIENvcHlyaWdodCAyMDIyIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIC8qXG4gKiBDb3B5cmlnaHQgMjAyMiBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyAvKlxuICogQ29weXJpZ2h0IDIwMjIgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gZnVuY3Rpb24gJDY4MThiMWM0ZmM2NzAyOGQkZXhwb3J0JDE5OTRhMDc3Yjk4ZWUwZDUod2lkdGgpIHtcbiAgICByZXR1cm4gd2lkdGggIT0gbnVsbCAmJiAoIWlzTmFOKHdpZHRoKSB8fCBTdHJpbmcod2lkdGgpLm1hdGNoKC9eKFxcZCspKD89JSQpLykgIT09IG51bGwpO1xufVxuZnVuY3Rpb24gJDY4MThiMWM0ZmM2NzAyOGQkZXhwb3J0JDkwNzhiYWQ0YzM5MzQ2MDQod2lkdGgpIHtcbiAgICBpZiAoIXdpZHRoKSByZXR1cm4gMTtcbiAgICBsZXQgbWF0Y2ggPSB3aWR0aC5tYXRjaCgvXiguKykoPz1mciQpLyk7XG4gICAgLy8gaWYgd2lkdGggaXMgdGhlIGluY29ycmVjdCBmb3JtYXQsIGp1c3QgZGVmYXVsdCBpdCB0byBhIDFmclxuICAgIGlmICghbWF0Y2gpIHtcbiAgICAgICAgY29uc29sZS53YXJuKGB3aWR0aDogJHt3aWR0aH0gaXMgbm90IGEgc3VwcG9ydGVkIGZvcm1hdCwgd2lkdGggc2hvdWxkIGJlIGEgbnVtYmVyIChleC4gMTUwKSwgcGVyY2VudGFnZSAoZXguICc1MCUnKSBvciBmciB1bml0IChleC4gJzJmcicpYCwgXCJkZWZhdWx0aW5nIHRvICcxZnInXCIpO1xuICAgICAgICByZXR1cm4gMTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcnNlRmxvYXQobWF0Y2hbMF0pO1xufVxuZnVuY3Rpb24gJDY4MThiMWM0ZmM2NzAyOGQkZXhwb3J0JDdiYmFkMjc4OTZmN2FlOWYod2lkdGgsIHRhYmxlV2lkdGgpIHtcbiAgICBpZiAodHlwZW9mIHdpZHRoID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGxldCBtYXRjaCA9IHdpZHRoLm1hdGNoKC9eKFxcZCspKD89JSQpLyk7XG4gICAgICAgIGlmICghbWF0Y2gpIHRocm93IG5ldyBFcnJvcihcIk9ubHkgcGVyY2VudGFnZXMgb3IgbnVtYmVycyBhcmUgc3VwcG9ydGVkIGZvciBzdGF0aWMgY29sdW1uIHdpZHRoc1wiKTtcbiAgICAgICAgcmV0dXJuIHRhYmxlV2lkdGggKiAocGFyc2VGbG9hdChtYXRjaFswXSkgLyAxMDApO1xuICAgIH1cbiAgICByZXR1cm4gd2lkdGg7XG59XG5mdW5jdGlvbiAkNjgxOGIxYzRmYzY3MDI4ZCRleHBvcnQkNTkxODVjNjJhNzU0NGFhMChtYXhXaWR0aCwgdGFibGVXaWR0aCkge1xuICAgIHJldHVybiBtYXhXaWR0aCAhPSBudWxsID8gJDY4MThiMWM0ZmM2NzAyOGQkZXhwb3J0JDdiYmFkMjc4OTZmN2FlOWYobWF4V2lkdGgsIHRhYmxlV2lkdGgpIDogTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVI7XG59XG5mdW5jdGlvbiAkNjgxOGIxYzRmYzY3MDI4ZCRleHBvcnQkZjU1NjA1NGNlNDM1ODcwMShtaW5XaWR0aCwgdGFibGVXaWR0aCkge1xuICAgIHJldHVybiBtaW5XaWR0aCAhPSBudWxsID8gJDY4MThiMWM0ZmM2NzAyOGQkZXhwb3J0JDdiYmFkMjc4OTZmN2FlOWYobWluV2lkdGgsIHRhYmxlV2lkdGgpIDogMDtcbn1cbmZ1bmN0aW9uICQ2ODE4YjFjNGZjNjcwMjhkJGV4cG9ydCQ1NWQ1MGRjNjg3Mzg1NDkxKGF2YWlsYWJsZVdpZHRoLCBjb2x1bW5zLCBjaGFuZ2VkQ29sdW1ucywgZ2V0RGVmYXVsdFdpZHRoLCBnZXREZWZhdWx0TWluV2lkdGgpIHtcbiAgICBsZXQgaGFzTm9uRnJvemVuSXRlbXMgPSBmYWxzZTtcbiAgICBsZXQgZmxleEl0ZW1zID0gY29sdW1ucy5tYXAoKGNvbHVtbiwgaW5kZXgpPT57XG4gICAgICAgIHZhciBfY29sdW1uX3dpZHRoLCBfcmVmLCBfcmVmMTtcbiAgICAgICAgbGV0IHdpZHRoID0gY2hhbmdlZENvbHVtbnMuZ2V0KGNvbHVtbi5rZXkpICE9IG51bGwgPyBjaGFuZ2VkQ29sdW1ucy5nZXQoY29sdW1uLmtleSkgOiAoX3JlZjEgPSAoX3JlZiA9IChfY29sdW1uX3dpZHRoID0gY29sdW1uLndpZHRoKSAhPT0gbnVsbCAmJiBfY29sdW1uX3dpZHRoICE9PSB2b2lkIDAgPyBfY29sdW1uX3dpZHRoIDogY29sdW1uLmRlZmF1bHRXaWR0aCkgIT09IG51bGwgJiYgX3JlZiAhPT0gdm9pZCAwID8gX3JlZiA6IGdldERlZmF1bHRXaWR0aCA9PT0gbnVsbCB8fCBnZXREZWZhdWx0V2lkdGggPT09IHZvaWQgMCA/IHZvaWQgMCA6IGdldERlZmF1bHRXaWR0aChpbmRleCkpICE9PSBudWxsICYmIF9yZWYxICE9PSB2b2lkIDAgPyBfcmVmMSA6IFwiMWZyXCI7XG4gICAgICAgIGxldCBmcm96ZW4gPSBmYWxzZTtcbiAgICAgICAgbGV0IGJhc2VTaXplID0gMDtcbiAgICAgICAgbGV0IGZsZXggPSAwO1xuICAgICAgICBsZXQgdGFyZ2V0TWFpblNpemUgPSBudWxsO1xuICAgICAgICBpZiAoJDY4MThiMWM0ZmM2NzAyOGQkZXhwb3J0JDE5OTRhMDc3Yjk4ZWUwZDUod2lkdGgpKSB7XG4gICAgICAgICAgICBiYXNlU2l6ZSA9ICQ2ODE4YjFjNGZjNjcwMjhkJGV4cG9ydCQ3YmJhZDI3ODk2ZjdhZTlmKHdpZHRoLCBhdmFpbGFibGVXaWR0aCk7XG4gICAgICAgICAgICBmcm96ZW4gPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZmxleCA9ICQ2ODE4YjFjNGZjNjcwMjhkJGV4cG9ydCQ5MDc4YmFkNGMzOTM0NjA0KHdpZHRoKTtcbiAgICAgICAgICAgIGlmIChmbGV4IDw9IDApIGZyb3plbiA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIF9jb2x1bW5fbWluV2lkdGgsIF9yZWYyO1xuICAgICAgICBsZXQgbWluID0gJDY4MThiMWM0ZmM2NzAyOGQkZXhwb3J0JGY1NTYwNTRjZTQzNTg3MDEoKF9yZWYyID0gKF9jb2x1bW5fbWluV2lkdGggPSBjb2x1bW4ubWluV2lkdGgpICE9PSBudWxsICYmIF9jb2x1bW5fbWluV2lkdGggIT09IHZvaWQgMCA/IF9jb2x1bW5fbWluV2lkdGggOiBnZXREZWZhdWx0TWluV2lkdGggPT09IG51bGwgfHwgZ2V0RGVmYXVsdE1pbldpZHRoID09PSB2b2lkIDAgPyB2b2lkIDAgOiBnZXREZWZhdWx0TWluV2lkdGgoaW5kZXgpKSAhPT0gbnVsbCAmJiBfcmVmMiAhPT0gdm9pZCAwID8gX3JlZjIgOiAwLCBhdmFpbGFibGVXaWR0aCk7XG4gICAgICAgIGxldCBtYXggPSAkNjgxOGIxYzRmYzY3MDI4ZCRleHBvcnQkNTkxODVjNjJhNzU0NGFhMChjb2x1bW4ubWF4V2lkdGgsIGF2YWlsYWJsZVdpZHRoKTtcbiAgICAgICAgbGV0IGh5cG90aGV0aWNhbE1haW5TaXplID0gTWF0aC5tYXgobWluLCBNYXRoLm1pbihiYXNlU2l6ZSwgbWF4KSk7XG4gICAgICAgIC8vIDkuNy4xXG4gICAgICAgIC8vIFdlIGRvbid0IG1ha2UgdXNlIG9mIGZsZXggYmFzaXMsIGl0J3MgYWx3YXlzIDAsIHNvIHdlIGFyZSBhbHdheXMgaW4gJ2dyb3cnIG1vZGUuXG4gICAgICAgIC8vIDkuNy4yXG4gICAgICAgIGlmIChmcm96ZW4pIHRhcmdldE1haW5TaXplID0gaHlwb3RoZXRpY2FsTWFpblNpemU7XG4gICAgICAgIGVsc2UgaWYgKGJhc2VTaXplID4gaHlwb3RoZXRpY2FsTWFpblNpemUpIHtcbiAgICAgICAgICAgIGZyb3plbiA9IHRydWU7XG4gICAgICAgICAgICB0YXJnZXRNYWluU2l6ZSA9IGh5cG90aGV0aWNhbE1haW5TaXplO1xuICAgICAgICB9XG4gICAgICAgIC8vIDkuNy4zXG4gICAgICAgIGlmICghZnJvemVuKSBoYXNOb25Gcm96ZW5JdGVtcyA9IHRydWU7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBmcm96ZW46IGZyb3plbixcbiAgICAgICAgICAgIGJhc2VTaXplOiBiYXNlU2l6ZSxcbiAgICAgICAgICAgIGh5cG90aGV0aWNhbE1haW5TaXplOiBoeXBvdGhldGljYWxNYWluU2l6ZSxcbiAgICAgICAgICAgIG1pbjogbWluLFxuICAgICAgICAgICAgbWF4OiBtYXgsXG4gICAgICAgICAgICBmbGV4OiBmbGV4LFxuICAgICAgICAgICAgdGFyZ2V0TWFpblNpemU6IHRhcmdldE1haW5TaXplLFxuICAgICAgICAgICAgdmlvbGF0aW9uOiAwXG4gICAgICAgIH07XG4gICAgfSk7XG4gICAgLy8gOS43LjRcbiAgICAvLyA5LjcuNC5hXG4gICAgd2hpbGUoaGFzTm9uRnJvemVuSXRlbXMpe1xuICAgICAgICAvLyA5LjcuNC5iXG4gICAgICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZSB0aGUgcmVtYWluaW5nIGZyZWUgc3BhY2UgYXMgZm9yIGluaXRpYWwgZnJlZSBzcGFjZSxcbiAgICAgKiBhYm92ZSAoOS43LjMpLiBJZiB0aGUgc3VtIG9mIHRoZSB1bmZyb3plbiBmbGV4IGl0ZW1z4oCZIGZsZXggZmFjdG9ycyBpc1xuICAgICAqIGxlc3MgdGhhbiBvbmUsIG11bHRpcGx5IHRoZSBpbml0aWFsIGZyZWUgc3BhY2UgYnkgdGhpcyBzdW0gKG9mIGZsZXggZmFjdG9ycykuXG4gICAgICogSWYgdGhlIG1hZ25pdHVkZSBvZiB0aGlzIHZhbHVlIGlzIGxlc3MgdGhhbiB0aGUgbWFnbml0dWRlIG9mXG4gICAgICogdGhlIHJlbWFpbmluZyBmcmVlIHNwYWNlLCB1c2UgdGhpcyBhcyB0aGUgcmVtYWluaW5nIGZyZWUgc3BhY2UuXG4gICAgICovIGxldCB1c2VkV2lkdGggPSAwO1xuICAgICAgICBsZXQgZmxleEZhY3RvcnMgPSAwO1xuICAgICAgICBmbGV4SXRlbXMuZm9yRWFjaCgoaXRlbSk9PntcbiAgICAgICAgICAgIGlmIChpdGVtLmZyb3plbikgdXNlZFdpZHRoICs9IGl0ZW0udGFyZ2V0TWFpblNpemU7XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB1c2VkV2lkdGggKz0gaXRlbS5iYXNlU2l6ZTtcbiAgICAgICAgICAgICAgICBmbGV4RmFjdG9ycyArPSBpdGVtLmZsZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBsZXQgcmVtYWluaW5nRnJlZVNwYWNlID0gYXZhaWxhYmxlV2lkdGggLSB1c2VkV2lkdGg7XG4gICAgICAgIC8vIHdlIG9ubHkgc3VwcG9ydCBpbnRlZ2VyIEZSJ3MsIGFuZCBiZWNhdXNlIG9mIGhhc05vbkZyb3plbkl0ZW1zLCB3ZSBrbm93IHRoYXQgZmxleEZhY3RvcnMgPiAwXG4gICAgICAgIC8vIHNvIG5vIG5lZWQgdG8gY2hlY2sgZm9yIGZsZXhGYWN0b3JzIDwgMVxuICAgICAgICAvLyA5LjcuNC5jXG4gICAgICAgIC8qKlxuICAgICAqIElmIHRoZSByZW1haW5pbmcgZnJlZSBzcGFjZSBpcyB6ZXJvXG4gICAgICogLSBEbyBub3RoaW5nLlxuICAgICAqIEVsc2UgLy8gcmVtZW1iZXIsIHdlJ3JlIGFsd2F5cyBpbiBncm93IG1vZGVcbiAgICAgKiAtIEZpbmQgdGhlIHJhdGlvIG9mIHRoZSBpdGVt4oCZcyBmbGV4IGdyb3cgZmFjdG9yIHRvIHRoZVxuICAgICAqIHN1bSBvZiB0aGUgZmxleCBncm93IGZhY3RvcnMgb2YgYWxsIHVuZnJvemVuIGl0ZW1zIG9uXG4gICAgICogdGhlIGxpbmUuIFNldCB0aGUgaXRlbeKAmXMgdGFyZ2V0IG1haW4gc2l6ZSB0byBpdHMgZmxleFxuICAgICAqIGJhc2Ugc2l6ZSBwbHVzIGEgZnJhY3Rpb24gb2YgdGhlIHJlbWFpbmluZyBmcmVlIHNwYWNlXG4gICAgICogcHJvcG9ydGlvbmFsIHRvIHRoZSByYXRpby5cbiAgICAgKi8gaWYgKHJlbWFpbmluZ0ZyZWVTcGFjZSA+IDApIGZsZXhJdGVtcy5mb3JFYWNoKChpdGVtKT0+e1xuICAgICAgICAgICAgaWYgKCFpdGVtLmZyb3plbikge1xuICAgICAgICAgICAgICAgIGxldCByYXRpbyA9IGl0ZW0uZmxleCAvIGZsZXhGYWN0b3JzO1xuICAgICAgICAgICAgICAgIGl0ZW0udGFyZ2V0TWFpblNpemUgPSBpdGVtLmJhc2VTaXplICsgcmF0aW8gKiByZW1haW5pbmdGcmVlU3BhY2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAvLyA5LjcuNC5kXG4gICAgICAgIC8qKlxuICAgICAqIEZpeCBtaW4vbWF4IHZpb2xhdGlvbnMuIENsYW1wIGVhY2ggbm9uLWZyb3plbiBpdGVt4oCZc1xuICAgICAqIHRhcmdldCBtYWluIHNpemUgYnkgaXRzIHVzZWQgbWluIGFuZCBtYXggbWFpbiBzaXplc1xuICAgICAqIGFuZCBmbG9vciBpdHMgY29udGVudC1ib3ggc2l6ZSBhdCB6ZXJvLiBJZiB0aGUgaXRlbeKAmXNcbiAgICAgKiB0YXJnZXQgbWFpbiBzaXplIHdhcyBtYWRlIHNtYWxsZXIgYnkgdGhpcywgaXTigJlzIGEgbWF4XG4gICAgICogdmlvbGF0aW9uLiBJZiB0aGUgaXRlbeKAmXMgdGFyZ2V0IG1haW4gc2l6ZSB3YXMgbWFkZVxuICAgICAqIGxhcmdlciBieSB0aGlzLCBpdOKAmXMgYSBtaW4gdmlvbGF0aW9uLlxuICAgICAqLyBsZXQgdG90YWxWaW9sYXRpb24gPSAwO1xuICAgICAgICBmbGV4SXRlbXMuZm9yRWFjaCgoaXRlbSk9PntcbiAgICAgICAgICAgIGl0ZW0udmlvbGF0aW9uID0gMDtcbiAgICAgICAgICAgIGlmICghaXRlbS5mcm96ZW4pIHtcbiAgICAgICAgICAgICAgICBsZXQgeyBtaW46IG1pbiwgbWF4OiBtYXgsIHRhcmdldE1haW5TaXplOiB0YXJnZXRNYWluU2l6ZSB9ID0gaXRlbTtcbiAgICAgICAgICAgICAgICBpdGVtLnRhcmdldE1haW5TaXplID0gTWF0aC5tYXgobWluLCBNYXRoLm1pbih0YXJnZXRNYWluU2l6ZSwgbWF4KSk7XG4gICAgICAgICAgICAgICAgaXRlbS52aW9sYXRpb24gPSBpdGVtLnRhcmdldE1haW5TaXplIC0gdGFyZ2V0TWFpblNpemU7XG4gICAgICAgICAgICAgICAgdG90YWxWaW9sYXRpb24gKz0gaXRlbS52aW9sYXRpb247XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAvLyA5LjcuNC5lXG4gICAgICAgIC8qKlxuICAgICAqIEZyZWV6ZSBvdmVyLWZsZXhlZCBpdGVtcy4gVGhlIHRvdGFsIHZpb2xhdGlvbiBpcyB0aGVcbiAgICAgKiBzdW0gb2YgdGhlIGFkanVzdG1lbnRzIGZyb20gdGhlIHByZXZpb3VzIHN0ZXBcbiAgICAgKiDiiJEoY2xhbXBlZCBzaXplIC0gdW5jbGFtcGVkIHNpemUpLiBJZiB0aGUgdG90YWwgdmlvbGF0aW9uIGlzOlxuICAgICAqIFplcm9cbiAgICAgKiAtIEZyZWV6ZSBhbGwgaXRlbXMuXG4gICAgICpcbiAgICAgKiBQb3NpdGl2ZVxuICAgICAqIC0gRnJlZXplIGFsbCB0aGUgaXRlbXMgd2l0aCBtaW4gdmlvbGF0aW9ucy5cbiAgICAgKlxuICAgICAqIE5lZ2F0aXZlXG4gICAgICogLSBGcmVlemUgYWxsIHRoZSBpdGVtcyB3aXRoIG1heCB2aW9sYXRpb25zLlxuICAgICAqLyBoYXNOb25Gcm96ZW5JdGVtcyA9IGZhbHNlO1xuICAgICAgICBmbGV4SXRlbXMuZm9yRWFjaCgoaXRlbSk9PntcbiAgICAgICAgICAgIGlmICh0b3RhbFZpb2xhdGlvbiA9PT0gMCB8fCBNYXRoLnNpZ24odG90YWxWaW9sYXRpb24pID09PSBNYXRoLnNpZ24oaXRlbS52aW9sYXRpb24pKSBpdGVtLmZyb3plbiA9IHRydWU7XG4gICAgICAgICAgICBlbHNlIGlmICghaXRlbS5mcm96ZW4pIGhhc05vbkZyb3plbkl0ZW1zID0gdHJ1ZTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiAkNjgxOGIxYzRmYzY3MDI4ZCR2YXIkY2FzY2FkZVJvdW5kaW5nKGZsZXhJdGVtcyk7XG59XG5mdW5jdGlvbiAkNjgxOGIxYzRmYzY3MDI4ZCR2YXIkY2FzY2FkZVJvdW5kaW5nKGZsZXhJdGVtcykge1xuICAgIC8qXG4gIEdpdmVuIGFuIGFycmF5IG9mIGZsb2F0cyB0aGF0IHN1bSB0byBhbiBpbnRlZ2VyLCB0aGlzIHJvdW5kcyB0aGUgZmxvYXRzXG4gIGFuZCByZXR1cm5zIGFuIGFycmF5IG9mIGludGVnZXJzIHdpdGggdGhlIHNhbWUgc3VtLlxuICAqLyBsZXQgZnBUb3RhbCA9IDA7XG4gICAgbGV0IGludFRvdGFsID0gMDtcbiAgICBsZXQgcm91bmRlZEFycmF5ID0gW107XG4gICAgZmxleEl0ZW1zLmZvckVhY2goZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICBsZXQgZmxvYXQgPSBpdGVtLnRhcmdldE1haW5TaXplO1xuICAgICAgICBsZXQgaW50ZWdlciA9IE1hdGgucm91bmQoZmxvYXQgKyBmcFRvdGFsKSAtIGludFRvdGFsO1xuICAgICAgICBmcFRvdGFsICs9IGZsb2F0O1xuICAgICAgICBpbnRUb3RhbCArPSBpbnRlZ2VyO1xuICAgICAgICByb3VuZGVkQXJyYXkucHVzaChpbnRlZ2VyKTtcbiAgICB9KTtcbiAgICByZXR1cm4gcm91bmRlZEFycmF5O1xufVxuXG5cbmNsYXNzICRhOWU3YWU1NDRhNGU0MWRkJGV4cG9ydCQ3ZmY3N2ExNjI5NzBiMzBlIHtcbiAgICAvKiogVGFrZXMgYW4gYXJyYXkgb2YgY29sdW1ucyBhbmQgc3BsaXRzIGl0IGludG8gMiBtYXBzIG9mIGNvbHVtbnMgd2l0aCBjb250cm9sbGVkIGFuZCBjb2x1bW5zIHdpdGggdW5jb250cm9sbGVkIHdpZHRocy4gKi8gc3BsaXRDb2x1bW5zSW50b0NvbnRyb2xsZWRBbmRVbmNvbnRyb2xsZWQoY29sdW1ucykge1xuICAgICAgICByZXR1cm4gY29sdW1ucy5yZWR1Y2UoKGFjYywgY29sKT0+e1xuICAgICAgICAgICAgaWYgKGNvbC5wcm9wcy53aWR0aCAhPSBudWxsKSBhY2NbMF0uc2V0KGNvbC5rZXksIGNvbCk7XG4gICAgICAgICAgICBlbHNlIGFjY1sxXS5zZXQoY29sLmtleSwgY29sKTtcbiAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgIH0sIFtcbiAgICAgICAgICAgIG5ldyBNYXAoKSxcbiAgICAgICAgICAgIG5ldyBNYXAoKVxuICAgICAgICBdKTtcbiAgICB9XG4gICAgLyoqIFRha2VzIHVuY29udHJvbGxlZCBhbmQgY29udHJvbGxlZCB3aWR0aHMgYW5kIGpvaW5zIHRoZW0gaW50byBhIHNpbmdsZSBNYXAuICovIHJlY29tYmluZUNvbHVtbnMoY29sdW1ucywgdW5jb250cm9sbGVkV2lkdGhzLCB1bmNvbnRyb2xsZWRDb2x1bW5zLCBjb250cm9sbGVkQ29sdW1ucykge1xuICAgICAgICByZXR1cm4gbmV3IE1hcChjb2x1bW5zLm1hcCgoY29sKT0+e1xuICAgICAgICAgICAgaWYgKHVuY29udHJvbGxlZENvbHVtbnMuaGFzKGNvbC5rZXkpKSByZXR1cm4gW1xuICAgICAgICAgICAgICAgIGNvbC5rZXksXG4gICAgICAgICAgICAgICAgdW5jb250cm9sbGVkV2lkdGhzLmdldChjb2wua2V5KVxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIGVsc2UgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICBjb2wua2V5LFxuICAgICAgICAgICAgICAgIGNvbnRyb2xsZWRDb2x1bW5zLmdldChjb2wua2V5KS5wcm9wcy53aWR0aFxuICAgICAgICAgICAgXTtcbiAgICAgICAgfSkpO1xuICAgIH1cbiAgICAvKiogVXNlZCB0byBtYWtlIGFuIGluaXRpYWwgTWFwIG9mIHRoZSB1bmNvbnRyb2xsZWQgd2lkdGhzIGJhc2VkIG9uIGRlZmF1bHQgd2lkdGhzLiAqLyBnZXRJbml0aWFsVW5jb250cm9sbGVkV2lkdGhzKHVuY29udHJvbGxlZENvbHVtbnMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBNYXAoQXJyYXkuZnJvbSh1bmNvbnRyb2xsZWRDb2x1bW5zKS5tYXAoKFtrZXksIGNvbF0pPT57XG4gICAgICAgICAgICB2YXIgX3RoaXNfZ2V0RGVmYXVsdFdpZHRoLCBfdGhpcztcbiAgICAgICAgICAgIHZhciBfY29sX3Byb3BzX2RlZmF1bHRXaWR0aCwgX3JlZjtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICAgIChfcmVmID0gKF9jb2xfcHJvcHNfZGVmYXVsdFdpZHRoID0gY29sLnByb3BzLmRlZmF1bHRXaWR0aCkgIT09IG51bGwgJiYgX2NvbF9wcm9wc19kZWZhdWx0V2lkdGggIT09IHZvaWQgMCA/IF9jb2xfcHJvcHNfZGVmYXVsdFdpZHRoIDogKF90aGlzX2dldERlZmF1bHRXaWR0aCA9IChfdGhpcyA9IHRoaXMpLmdldERlZmF1bHRXaWR0aCkgPT09IG51bGwgfHwgX3RoaXNfZ2V0RGVmYXVsdFdpZHRoID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfdGhpc19nZXREZWZhdWx0V2lkdGguY2FsbChfdGhpcywgY29sKSkgIT09IG51bGwgJiYgX3JlZiAhPT0gdm9pZCAwID8gX3JlZiA6IFwiMWZyXCJcbiAgICAgICAgICAgIF07XG4gICAgICAgIH0pKTtcbiAgICB9XG4gICAgZ2V0Q29sdW1uV2lkdGgoa2V5KSB7XG4gICAgICAgIHZhciBfdGhpc19jb2x1bW5XaWR0aHNfZ2V0O1xuICAgICAgICByZXR1cm4gKF90aGlzX2NvbHVtbldpZHRoc19nZXQgPSB0aGlzLmNvbHVtbldpZHRocy5nZXQoa2V5KSkgIT09IG51bGwgJiYgX3RoaXNfY29sdW1uV2lkdGhzX2dldCAhPT0gdm9pZCAwID8gX3RoaXNfY29sdW1uV2lkdGhzX2dldCA6IDA7XG4gICAgfVxuICAgIGdldENvbHVtbk1pbldpZHRoKGtleSkge1xuICAgICAgICB2YXIgX3RoaXNfY29sdW1uTWluV2lkdGhzX2dldDtcbiAgICAgICAgcmV0dXJuIChfdGhpc19jb2x1bW5NaW5XaWR0aHNfZ2V0ID0gdGhpcy5jb2x1bW5NaW5XaWR0aHMuZ2V0KGtleSkpICE9PSBudWxsICYmIF90aGlzX2NvbHVtbk1pbldpZHRoc19nZXQgIT09IHZvaWQgMCA/IF90aGlzX2NvbHVtbk1pbldpZHRoc19nZXQgOiAwO1xuICAgIH1cbiAgICBnZXRDb2x1bW5NYXhXaWR0aChrZXkpIHtcbiAgICAgICAgdmFyIF90aGlzX2NvbHVtbk1heFdpZHRoc19nZXQ7XG4gICAgICAgIHJldHVybiAoX3RoaXNfY29sdW1uTWF4V2lkdGhzX2dldCA9IHRoaXMuY29sdW1uTWF4V2lkdGhzLmdldChrZXkpKSAhPT0gbnVsbCAmJiBfdGhpc19jb2x1bW5NYXhXaWR0aHNfZ2V0ICE9PSB2b2lkIDAgPyBfdGhpc19jb2x1bW5NYXhXaWR0aHNfZ2V0IDogMDtcbiAgICB9XG4gICAgcmVzaXplQ29sdW1uV2lkdGgodGFibGVXaWR0aCwgY29sbGVjdGlvbiwgY29udHJvbGxlZFdpZHRocywgdW5jb250cm9sbGVkV2lkdGhzLCBjb2wgPSBudWxsLCB3aWR0aCkge1xuICAgICAgICBsZXQgcHJldkNvbHVtbldpZHRocyA9IHRoaXMuY29sdW1uV2lkdGhzO1xuICAgICAgICAvLyByZXNpemluZyBhIGNvbHVtblxuICAgICAgICBsZXQgcmVzaXplSW5kZXggPSBJbmZpbml0eTtcbiAgICAgICAgbGV0IHJlc2l6aW5nQ2hhbmdlZCA9IG5ldyBNYXAoW1xuICAgICAgICAgICAgLi4uY29udHJvbGxlZFdpZHRocyxcbiAgICAgICAgICAgIC4uLnVuY29udHJvbGxlZFdpZHRoc1xuICAgICAgICBdKTtcbiAgICAgICAgbGV0IHBlcmNlbnRLZXlzID0gbmV3IE1hcCgpO1xuICAgICAgICBsZXQgZnJLZXlzVG9UaGVSaWdodCA9IG5ldyBNYXAoKTtcbiAgICAgICAgbGV0IG1pbldpZHRocyA9IG5ldyBNYXAoKTtcbiAgICAgICAgLy8gZnJlZXplIGNvbHVtbnMgdG8gdGhlIGxlZnQgdG8gdGhlaXIgcHJldmlvdXMgcGl4ZWwgdmFsdWVcbiAgICAgICAgY29sbGVjdGlvbi5jb2x1bW5zLmZvckVhY2goKGNvbHVtbiwgaSk9PntcbiAgICAgICAgICAgIHZhciBfY29sdW1uX3Byb3BzX3dpZHRoX2VuZHNXaXRoLCBfY29sdW1uX3Byb3BzX3dpZHRoO1xuICAgICAgICAgICAgbGV0IGZyS2V5O1xuICAgICAgICAgICAgbGV0IGZyVmFsdWU7XG4gICAgICAgICAgICBtaW5XaWR0aHMuc2V0KGNvbHVtbi5rZXksIHRoaXMuZ2V0RGVmYXVsdE1pbldpZHRoKGNvbGxlY3Rpb24uY29sdW1uc1tpXSkpO1xuICAgICAgICAgICAgaWYgKGNvbCAhPT0gY29sdW1uLmtleSAmJiAhY29sdW1uLnByb3BzLndpZHRoICYmICEoMCwgJDY4MThiMWM0ZmM2NzAyOGQkZXhwb3J0JDE5OTRhMDc3Yjk4ZWUwZDUpKHVuY29udHJvbGxlZFdpZHRocy5nZXQoY29sdW1uLmtleSkpKSB7XG4gICAgICAgICAgICAgICAgLy8gdW5jb250cm9sbGVkIGRvbid0IGhhdmUgcHJvcHMud2lkdGggZm9yIHVzLCBzbyBpbnN0ZWFkIGdldCBmcm9tIG91ciBzdGF0ZVxuICAgICAgICAgICAgICAgIGZyS2V5ID0gY29sdW1uLmtleTtcbiAgICAgICAgICAgICAgICBmclZhbHVlID0gKDAsICQ2ODE4YjFjNGZjNjcwMjhkJGV4cG9ydCQ5MDc4YmFkNGMzOTM0NjA0KSh1bmNvbnRyb2xsZWRXaWR0aHMuZ2V0KGNvbHVtbi5rZXkpKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY29sICE9PSBjb2x1bW4ua2V5ICYmICEoMCwgJDY4MThiMWM0ZmM2NzAyOGQkZXhwb3J0JDE5OTRhMDc3Yjk4ZWUwZDUpKGNvbHVtbi5wcm9wcy53aWR0aCkgJiYgIXVuY29udHJvbGxlZFdpZHRocy5nZXQoY29sdW1uLmtleSkpIHtcbiAgICAgICAgICAgICAgICAvLyBjb250cm9sbGVkV2lkdGhzIHdpbGwgYmUgdGhlIHNhbWUgaW4gdGhlIGNvbGxlY3Rpb25cbiAgICAgICAgICAgICAgICBmcktleSA9IGNvbHVtbi5rZXk7XG4gICAgICAgICAgICAgICAgZnJWYWx1ZSA9ICgwLCAkNjgxOGIxYzRmYzY3MDI4ZCRleHBvcnQkOTA3OGJhZDRjMzkzNDYwNCkoY29sdW1uLnByb3BzLndpZHRoKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY29sICE9PSBjb2x1bW4ua2V5ICYmICgoX2NvbHVtbl9wcm9wc193aWR0aCA9IGNvbHVtbi5wcm9wcy53aWR0aCkgPT09IG51bGwgfHwgX2NvbHVtbl9wcm9wc193aWR0aCA9PT0gdm9pZCAwID8gdm9pZCAwIDogKF9jb2x1bW5fcHJvcHNfd2lkdGhfZW5kc1dpdGggPSBfY29sdW1uX3Byb3BzX3dpZHRoLmVuZHNXaXRoKSA9PT0gbnVsbCB8fCBfY29sdW1uX3Byb3BzX3dpZHRoX2VuZHNXaXRoID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfY29sdW1uX3Byb3BzX3dpZHRoX2VuZHNXaXRoLmNhbGwoX2NvbHVtbl9wcm9wc193aWR0aCwgXCIlXCIpKSkgcGVyY2VudEtleXMuc2V0KGNvbHVtbi5rZXksIGNvbHVtbi5wcm9wcy53aWR0aCk7XG4gICAgICAgICAgICAvLyBkb24ndCBmcmVlemUgY29sdW1ucyB0byB0aGUgcmlnaHQgb2YgdGhlIHJlc2l6aW5nIG9uZVxuICAgICAgICAgICAgaWYgKHJlc2l6ZUluZGV4IDwgaSkge1xuICAgICAgICAgICAgICAgIGlmIChmcktleSkgZnJLZXlzVG9UaGVSaWdodC5zZXQoZnJLZXksIGZyVmFsdWUpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHdlIGFscmVhZHkga25vdyB0aGUgbmV3IHNpemUgb2YgdGhlIHJlc2l6aW5nIGNvbHVtblxuICAgICAgICAgICAgaWYgKGNvbHVtbi5rZXkgPT09IGNvbCkge1xuICAgICAgICAgICAgICAgIHJlc2l6ZUluZGV4ID0gaTtcbiAgICAgICAgICAgICAgICByZXNpemluZ0NoYW5nZWQuc2V0KGNvbHVtbi5rZXksIE1hdGguZmxvb3Iod2lkdGgpKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBmcmVlemUgY29sdW1uIHRvIHByZXZpb3VzIHZhbHVlXG4gICAgICAgICAgICByZXNpemluZ0NoYW5nZWQuc2V0KGNvbHVtbi5rZXksIHByZXZDb2x1bW5XaWR0aHMuZ2V0KGNvbHVtbi5rZXkpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIHByZWRpY3QgcGl4ZWxzIHNpemVzIGZvciBhbGwgY29sdW1ucyBiYXNlZCBvbiByZXNpemVcbiAgICAgICAgbGV0IGNvbHVtbldpZHRocyA9ICgwLCAkNjgxOGIxYzRmYzY3MDI4ZCRleHBvcnQkNTVkNTBkYzY4NzM4NTQ5MSkodGFibGVXaWR0aCwgY29sbGVjdGlvbi5jb2x1bW5zLm1hcCgoY29sKT0+KHtcbiAgICAgICAgICAgICAgICAuLi5jb2wucHJvcHMsXG4gICAgICAgICAgICAgICAga2V5OiBjb2wua2V5XG4gICAgICAgICAgICB9KSksIHJlc2l6aW5nQ2hhbmdlZCwgKGkpPT50aGlzLmdldERlZmF1bHRXaWR0aChjb2xsZWN0aW9uLmNvbHVtbnNbaV0pLCAoaSk9PnRoaXMuZ2V0RGVmYXVsdE1pbldpZHRoKGNvbGxlY3Rpb24uY29sdW1uc1tpXSkpO1xuICAgICAgICAvLyBzZXQgYWxsIG5ldyBjb2x1bW4gd2lkdGhzIGZvciBvblJlc2l6ZSBldmVudFxuICAgICAgICAvLyBjb2x1bW5zIGdvaW5nIGluIHdpbGwgYmUgdGhlIHNhbWUgb3JkZXIgYXMgdGhlIGNvbHVtbnMgY29taW5nIG91dFxuICAgICAgICBsZXQgbmV3V2lkdGhzID0gbmV3IE1hcCgpO1xuICAgICAgICAvLyBzZXQgYWxsIGNvbHVtbiB3aWR0aHMgYmFzZWQgb24gY2FsY3VsYXRlQ29sdW1uU2l6ZVxuICAgICAgICBjb2x1bW5XaWR0aHMuZm9yRWFjaCgod2lkdGgsIGluZGV4KT0+e1xuICAgICAgICAgICAgbGV0IGtleSA9IGNvbGxlY3Rpb24uY29sdW1uc1tpbmRleF0ua2V5O1xuICAgICAgICAgICAgbmV3V2lkdGhzLnNldChrZXksIHdpZHRoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIGFkZCBGUidzIGJhY2sgYXMgdGhleSB3ZXJlIHRvIGNvbHVtbnMgdG8gdGhlIHJpZ2h0XG4gICAgICAgIEFycmF5LmZyb20oZnJLZXlzVG9UaGVSaWdodCkuZm9yRWFjaCgoW2tleV0pPT57XG4gICAgICAgICAgICBuZXdXaWR0aHMuc2V0KGtleSwgYCR7ZnJLZXlzVG9UaGVSaWdodC5nZXQoa2V5KX1mcmApO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gcHV0IGJhY2sgaW4gcGVyY2VudHNcbiAgICAgICAgQXJyYXkuZnJvbShwZXJjZW50S2V5cykuZm9yRWFjaCgoW2tleSwgd2lkdGhdKT0+e1xuICAgICAgICAgICAgLy8gcmVzaXppbmcgbG9ja3MgYSBjb2x1bW4gdG8gYSBweCB3aWR0aFxuICAgICAgICAgICAgaWYgKGtleSA9PT0gY29sKSByZXR1cm47XG4gICAgICAgICAgICBuZXdXaWR0aHMuc2V0KGtleSwgd2lkdGgpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG5ld1dpZHRocztcbiAgICB9XG4gICAgYnVpbGRDb2x1bW5XaWR0aHModGFibGVXaWR0aCwgY29sbGVjdGlvbiwgd2lkdGhzKSB7XG4gICAgICAgIHRoaXMuY29sdW1uV2lkdGhzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLmNvbHVtbk1pbldpZHRocyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5jb2x1bW5NYXhXaWR0aHMgPSBuZXcgTWFwKCk7XG4gICAgICAgIC8vIGluaXRpYWwgbGF5b3V0IG9yIHRhYmxlL3dpbmRvdyByZXNpemluZ1xuICAgICAgICBsZXQgY29sdW1uV2lkdGhzID0gKDAsICQ2ODE4YjFjNGZjNjcwMjhkJGV4cG9ydCQ1NWQ1MGRjNjg3Mzg1NDkxKSh0YWJsZVdpZHRoLCBjb2xsZWN0aW9uLmNvbHVtbnMubWFwKChjb2wpPT4oe1xuICAgICAgICAgICAgICAgIC4uLmNvbC5wcm9wcyxcbiAgICAgICAgICAgICAgICBrZXk6IGNvbC5rZXlcbiAgICAgICAgICAgIH0pKSwgd2lkdGhzLCAoaSk9PnRoaXMuZ2V0RGVmYXVsdFdpZHRoKGNvbGxlY3Rpb24uY29sdW1uc1tpXSksIChpKT0+dGhpcy5nZXREZWZhdWx0TWluV2lkdGgoY29sbGVjdGlvbi5jb2x1bW5zW2ldKSk7XG4gICAgICAgIC8vIGNvbHVtbnMgZ29pbmcgaW4gd2lsbCBiZSB0aGUgc2FtZSBvcmRlciBhcyB0aGUgY29sdW1ucyBjb21pbmcgb3V0XG4gICAgICAgIGNvbHVtbldpZHRocy5mb3JFYWNoKCh3aWR0aCwgaW5kZXgpPT57XG4gICAgICAgICAgICBsZXQga2V5ID0gY29sbGVjdGlvbi5jb2x1bW5zW2luZGV4XS5rZXk7XG4gICAgICAgICAgICBsZXQgY29sdW1uID0gY29sbGVjdGlvbi5jb2x1bW5zW2luZGV4XTtcbiAgICAgICAgICAgIHRoaXMuY29sdW1uV2lkdGhzLnNldChrZXksIHdpZHRoKTtcbiAgICAgICAgICAgIHZhciBfY29sdW1uX3Byb3BzX21pbldpZHRoO1xuICAgICAgICAgICAgdGhpcy5jb2x1bW5NaW5XaWR0aHMuc2V0KGtleSwgKDAsICQ2ODE4YjFjNGZjNjcwMjhkJGV4cG9ydCRmNTU2MDU0Y2U0MzU4NzAxKSgoX2NvbHVtbl9wcm9wc19taW5XaWR0aCA9IGNvbHVtbi5wcm9wcy5taW5XaWR0aCkgIT09IG51bGwgJiYgX2NvbHVtbl9wcm9wc19taW5XaWR0aCAhPT0gdm9pZCAwID8gX2NvbHVtbl9wcm9wc19taW5XaWR0aCA6IHRoaXMuZ2V0RGVmYXVsdE1pbldpZHRoKGNvbHVtbiksIHRhYmxlV2lkdGgpKTtcbiAgICAgICAgICAgIHRoaXMuY29sdW1uTWF4V2lkdGhzLnNldChrZXksICgwLCAkNjgxOGIxYzRmYzY3MDI4ZCRleHBvcnQkNTkxODVjNjJhNzU0NGFhMCkoY29sdW1uLnByb3BzLm1heFdpZHRoLCB0YWJsZVdpZHRoKSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcy5jb2x1bW5XaWR0aHM7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpe1xuICAgICAgICB0aGlzLmNvbHVtbldpZHRocyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5jb2x1bW5NaW5XaWR0aHMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuY29sdW1uTWF4V2lkdGhzID0gbmV3IE1hcCgpO1xuICAgICAgICB2YXIgX29wdGlvbnNfZ2V0RGVmYXVsdFdpZHRoO1xuICAgICAgICB0aGlzLmdldERlZmF1bHRXaWR0aCA9IChfb3B0aW9uc19nZXREZWZhdWx0V2lkdGggPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuZ2V0RGVmYXVsdFdpZHRoKSAhPT0gbnVsbCAmJiBfb3B0aW9uc19nZXREZWZhdWx0V2lkdGggIT09IHZvaWQgMCA/IF9vcHRpb25zX2dldERlZmF1bHRXaWR0aCA6ICgpPT5cIjFmclwiO1xuICAgICAgICB2YXIgX29wdGlvbnNfZ2V0RGVmYXVsdE1pbldpZHRoO1xuICAgICAgICB0aGlzLmdldERlZmF1bHRNaW5XaWR0aCA9IChfb3B0aW9uc19nZXREZWZhdWx0TWluV2lkdGggPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuZ2V0RGVmYXVsdE1pbldpZHRoKSAhPT0gbnVsbCAmJiBfb3B0aW9uc19nZXREZWZhdWx0TWluV2lkdGggIT09IHZvaWQgMCA/IF9vcHRpb25zX2dldERlZmF1bHRNaW5XaWR0aCA6ICgpPT43NTtcbiAgICB9XG59XG5cblxuXG5mdW5jdGlvbiAkMjkyYmM0ZTA5Y2QwZWI2MiRleHBvcnQkY2I4OTVkY2Y4NWRiMTMxOShwcm9wcywgc3RhdGUpIHtcbiAgICBsZXQgeyBnZXREZWZhdWx0V2lkdGg6IGdldERlZmF1bHRXaWR0aCwgZ2V0RGVmYXVsdE1pbldpZHRoOiBnZXREZWZhdWx0TWluV2lkdGgsIHRhYmxlV2lkdGg6IHRhYmxlV2lkdGggPSAwIH0gPSBwcm9wcztcbiAgICBsZXQgW3Jlc2l6aW5nQ29sdW1uLCBzZXRSZXNpemluZ0NvbHVtbl0gPSAoMCwgJDFCZmpXJHVzZVN0YXRlKShudWxsKTtcbiAgICBsZXQgY29sdW1uTGF5b3V0ID0gKDAsICQxQmZqVyR1c2VNZW1vKSgoKT0+bmV3ICgwLCAkYTllN2FlNTQ0YTRlNDFkZCRleHBvcnQkN2ZmNzdhMTYyOTcwYjMwZSkoe1xuICAgICAgICAgICAgZ2V0RGVmYXVsdFdpZHRoOiBnZXREZWZhdWx0V2lkdGgsXG4gICAgICAgICAgICBnZXREZWZhdWx0TWluV2lkdGg6IGdldERlZmF1bHRNaW5XaWR0aFxuICAgICAgICB9KSwgW1xuICAgICAgICBnZXREZWZhdWx0V2lkdGgsXG4gICAgICAgIGdldERlZmF1bHRNaW5XaWR0aFxuICAgIF0pO1xuICAgIGxldCBbY29udHJvbGxlZENvbHVtbnMsIHVuY29udHJvbGxlZENvbHVtbnNdID0gKDAsICQxQmZqVyR1c2VNZW1vKSgoKT0+Y29sdW1uTGF5b3V0LnNwbGl0Q29sdW1uc0ludG9Db250cm9sbGVkQW5kVW5jb250cm9sbGVkKHN0YXRlLmNvbGxlY3Rpb24uY29sdW1ucyksIFtcbiAgICAgICAgc3RhdGUuY29sbGVjdGlvbi5jb2x1bW5zLFxuICAgICAgICBjb2x1bW5MYXlvdXRcbiAgICBdKTtcbiAgICAvLyB1bmNvbnRyb2xsZWQgY29sdW1uIHdpZHRoc1xuICAgIGxldCBbdW5jb250cm9sbGVkV2lkdGhzLCBzZXRVbmNvbnRyb2xsZWRXaWR0aHNdID0gKDAsICQxQmZqVyR1c2VTdGF0ZSkoKCk9PmNvbHVtbkxheW91dC5nZXRJbml0aWFsVW5jb250cm9sbGVkV2lkdGhzKHVuY29udHJvbGxlZENvbHVtbnMpKTtcbiAgICAvLyBVcGRhdGUgdW5jb250cm9sbGVkIHdpZHRocyBpZiB0aGUgY29sdW1ucyBjaGFuZ2VkLlxuICAgIGxldCBbbGFzdENvbHVtbnMsIHNldExhc3RDb2x1bW5zXSA9ICgwLCAkMUJmalckdXNlU3RhdGUpKHN0YXRlLmNvbGxlY3Rpb24uY29sdW1ucyk7XG4gICAgaWYgKHN0YXRlLmNvbGxlY3Rpb24uY29sdW1ucyAhPT0gbGFzdENvbHVtbnMpIHtcbiAgICAgICAgaWYgKHN0YXRlLmNvbGxlY3Rpb24uY29sdW1ucy5sZW5ndGggIT09IGxhc3RDb2x1bW5zLmxlbmd0aCB8fCBzdGF0ZS5jb2xsZWN0aW9uLmNvbHVtbnMuc29tZSgoYywgaSk9PmMua2V5ICE9PSBsYXN0Q29sdW1uc1tpXS5rZXkpKSB7XG4gICAgICAgICAgICBsZXQgbmV3VW5jb250cm9sbGVkV2lkdGhzID0gY29sdW1uTGF5b3V0LmdldEluaXRpYWxVbmNvbnRyb2xsZWRXaWR0aHModW5jb250cm9sbGVkQ29sdW1ucyk7XG4gICAgICAgICAgICBzZXRVbmNvbnRyb2xsZWRXaWR0aHMobmV3VW5jb250cm9sbGVkV2lkdGhzKTtcbiAgICAgICAgfVxuICAgICAgICBzZXRMYXN0Q29sdW1ucyhzdGF0ZS5jb2xsZWN0aW9uLmNvbHVtbnMpO1xuICAgIH1cbiAgICAvLyBjb21iaW5lIGNvbHVtbnMgYmFjayBpbnRvIG9uZSBtYXAgdGhhdCBtYWludGFpbnMgc2FtZSBvcmRlciBhcyB0aGUgY29sdW1uc1xuICAgIGxldCBjb2xXaWR0aHMgPSAoMCwgJDFCZmpXJHVzZU1lbW8pKCgpPT5jb2x1bW5MYXlvdXQucmVjb21iaW5lQ29sdW1ucyhzdGF0ZS5jb2xsZWN0aW9uLmNvbHVtbnMsIHVuY29udHJvbGxlZFdpZHRocywgdW5jb250cm9sbGVkQ29sdW1ucywgY29udHJvbGxlZENvbHVtbnMpLCBbXG4gICAgICAgIHN0YXRlLmNvbGxlY3Rpb24uY29sdW1ucyxcbiAgICAgICAgdW5jb250cm9sbGVkV2lkdGhzLFxuICAgICAgICB1bmNvbnRyb2xsZWRDb2x1bW5zLFxuICAgICAgICBjb250cm9sbGVkQ29sdW1ucyxcbiAgICAgICAgY29sdW1uTGF5b3V0XG4gICAgXSk7XG4gICAgbGV0IHN0YXJ0UmVzaXplID0gKDAsICQxQmZqVyR1c2VDYWxsYmFjaykoKGtleSk9PntcbiAgICAgICAgc2V0UmVzaXppbmdDb2x1bW4oa2V5KTtcbiAgICB9LCBbXG4gICAgICAgIHNldFJlc2l6aW5nQ29sdW1uXG4gICAgXSk7XG4gICAgbGV0IHVwZGF0ZVJlc2l6ZWRDb2x1bW5zID0gKDAsICQxQmZqVyR1c2VDYWxsYmFjaykoKGtleSwgd2lkdGgpPT57XG4gICAgICAgIGxldCBuZXdDb250cm9sbGVkID0gbmV3IE1hcChBcnJheS5mcm9tKGNvbnRyb2xsZWRDb2x1bW5zKS5tYXAoKFtrZXksIGVudHJ5XSk9PltcbiAgICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgICAgZW50cnkucHJvcHMud2lkdGhcbiAgICAgICAgICAgIF0pKTtcbiAgICAgICAgbGV0IG5ld1NpemVzID0gY29sdW1uTGF5b3V0LnJlc2l6ZUNvbHVtbldpZHRoKHRhYmxlV2lkdGgsIHN0YXRlLmNvbGxlY3Rpb24sIG5ld0NvbnRyb2xsZWQsIHVuY29udHJvbGxlZFdpZHRocywga2V5LCB3aWR0aCk7XG4gICAgICAgIGxldCBtYXAgPSBuZXcgTWFwKEFycmF5LmZyb20odW5jb250cm9sbGVkQ29sdW1ucykubWFwKChba2V5XSk9PltcbiAgICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgICAgbmV3U2l6ZXMuZ2V0KGtleSlcbiAgICAgICAgICAgIF0pKTtcbiAgICAgICAgbWFwLnNldChrZXksIHdpZHRoKTtcbiAgICAgICAgc2V0VW5jb250cm9sbGVkV2lkdGhzKG1hcCk7XG4gICAgICAgIHJldHVybiBuZXdTaXplcztcbiAgICB9LCBbXG4gICAgICAgIGNvbnRyb2xsZWRDb2x1bW5zLFxuICAgICAgICB1bmNvbnRyb2xsZWRDb2x1bW5zLFxuICAgICAgICBzZXRVbmNvbnRyb2xsZWRXaWR0aHMsXG4gICAgICAgIHRhYmxlV2lkdGgsXG4gICAgICAgIGNvbHVtbkxheW91dCxcbiAgICAgICAgc3RhdGUuY29sbGVjdGlvbixcbiAgICAgICAgdW5jb250cm9sbGVkV2lkdGhzXG4gICAgXSk7XG4gICAgbGV0IGVuZFJlc2l6ZSA9ICgwLCAkMUJmalckdXNlQ2FsbGJhY2spKCgpPT57XG4gICAgICAgIHNldFJlc2l6aW5nQ29sdW1uKG51bGwpO1xuICAgIH0sIFtcbiAgICAgICAgc2V0UmVzaXppbmdDb2x1bW5cbiAgICBdKTtcbiAgICAoMCwgJDFCZmpXJHVzZU1lbW8pKCgpPT5jb2x1bW5MYXlvdXQuYnVpbGRDb2x1bW5XaWR0aHModGFibGVXaWR0aCwgc3RhdGUuY29sbGVjdGlvbiwgY29sV2lkdGhzKSwgW1xuICAgICAgICB0YWJsZVdpZHRoLFxuICAgICAgICBzdGF0ZS5jb2xsZWN0aW9uLFxuICAgICAgICBjb2xXaWR0aHMsXG4gICAgICAgIGNvbHVtbkxheW91dFxuICAgIF0pO1xuICAgIHJldHVybiAoMCwgJDFCZmpXJHVzZU1lbW8pKCgpPT4oe1xuICAgICAgICAgICAgcmVzaXppbmdDb2x1bW46IHJlc2l6aW5nQ29sdW1uLFxuICAgICAgICAgICAgdXBkYXRlUmVzaXplZENvbHVtbnM6IHVwZGF0ZVJlc2l6ZWRDb2x1bW5zLFxuICAgICAgICAgICAgc3RhcnRSZXNpemU6IHN0YXJ0UmVzaXplLFxuICAgICAgICAgICAgZW5kUmVzaXplOiBlbmRSZXNpemUsXG4gICAgICAgICAgICBnZXRDb2x1bW5XaWR0aDogKGtleSk9PmNvbHVtbkxheW91dC5nZXRDb2x1bW5XaWR0aChrZXkpLFxuICAgICAgICAgICAgZ2V0Q29sdW1uTWluV2lkdGg6IChrZXkpPT5jb2x1bW5MYXlvdXQuZ2V0Q29sdW1uTWluV2lkdGgoa2V5KSxcbiAgICAgICAgICAgIGdldENvbHVtbk1heFdpZHRoOiAoa2V5KT0+Y29sdW1uTGF5b3V0LmdldENvbHVtbk1heFdpZHRoKGtleSksXG4gICAgICAgICAgICB0YWJsZVN0YXRlOiBzdGF0ZVxuICAgICAgICB9KSwgW1xuICAgICAgICBjb2x1bW5MYXlvdXQsXG4gICAgICAgIHJlc2l6aW5nQ29sdW1uLFxuICAgICAgICB1cGRhdGVSZXNpemVkQ29sdW1ucyxcbiAgICAgICAgc3RhcnRSZXNpemUsXG4gICAgICAgIGVuZFJlc2l6ZSxcbiAgICAgICAgc3RhdGVcbiAgICBdKTtcbn1cblxuXG4vKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gXG5cbi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyBcblxuY29uc3QgJDc4ODc4MWJhYTMwMTE3ZmEkdmFyJFJPV19IRUFERVJfQ09MVU1OX0tFWSA9IFwicm93LWhlYWRlci1jb2x1bW4tXCIgKyBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zbGljZSgyKTtcbmxldCAkNzg4NzgxYmFhMzAxMTdmYSR2YXIkUk9XX0hFQURFUl9DT0xVTU5fS0VZX0RSQUcgPSBcInJvdy1oZWFkZXItY29sdW1uLVwiICsgTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc2xpY2UoMik7XG53aGlsZSgkNzg4NzgxYmFhMzAxMTdmYSR2YXIkUk9XX0hFQURFUl9DT0xVTU5fS0VZID09PSAkNzg4NzgxYmFhMzAxMTdmYSR2YXIkUk9XX0hFQURFUl9DT0xVTU5fS0VZX0RSQUcpJDc4ODc4MWJhYTMwMTE3ZmEkdmFyJFJPV19IRUFERVJfQ09MVU1OX0tFWV9EUkFHID0gXCJyb3ctaGVhZGVyLWNvbHVtbi1cIiArIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnNsaWNlKDIpO1xuZnVuY3Rpb24gJDc4ODc4MWJhYTMwMTE3ZmEkZXhwb3J0JDdjMTI3ZGI4NTBkNGU4MWUoa2V5TWFwLCBjb2x1bW5Ob2Rlcykge1xuICAgIGlmIChjb2x1bW5Ob2Rlcy5sZW5ndGggPT09IDApIHJldHVybiBbXTtcbiAgICBsZXQgY29sdW1ucyA9IFtdO1xuICAgIGxldCBzZWVuID0gbmV3IE1hcCgpO1xuICAgIGZvciAobGV0IGNvbHVtbiBvZiBjb2x1bW5Ob2Rlcyl7XG4gICAgICAgIGxldCBwYXJlbnRLZXkgPSBjb2x1bW4ucGFyZW50S2V5O1xuICAgICAgICBsZXQgY29sID0gW1xuICAgICAgICAgICAgY29sdW1uXG4gICAgICAgIF07XG4gICAgICAgIHdoaWxlKHBhcmVudEtleSl7XG4gICAgICAgICAgICBsZXQgcGFyZW50ID0ga2V5TWFwLmdldChwYXJlbnRLZXkpO1xuICAgICAgICAgICAgaWYgKCFwYXJlbnQpIGJyZWFrO1xuICAgICAgICAgICAgLy8gSWYgd2UndmUgYWxyZWFkeSBzZWVuIHRoaXMgcGFyZW50LCB0aGFuIGl0IGlzIHNoYXJlZFxuICAgICAgICAgICAgLy8gd2l0aCBhIHByZXZpb3VzIGNvbHVtbi4gSWYgdGhlIGN1cnJlbnQgY29sdW1uIGlzIHRhbGxlclxuICAgICAgICAgICAgLy8gdGhhbiB0aGUgcHJldmlvdXMgY29sdW1uLCB0aGFuIHdlIG5lZWQgdG8gc2hpZnQgdGhlIHBhcmVudFxuICAgICAgICAgICAgLy8gaW4gdGhlIHByZXZpb3VzIGNvbHVtbiBzbyBpdCdzIGxldmVsIHdpdGggdGhlIGN1cnJlbnQgY29sdW1uLlxuICAgICAgICAgICAgaWYgKHNlZW4uaGFzKHBhcmVudCkpIHtcbiAgICAgICAgICAgICAgICBwYXJlbnQuY29sc3BhbisrO1xuICAgICAgICAgICAgICAgIGxldCB7IGNvbHVtbjogY29sdW1uLCBpbmRleDogaW5kZXggfSA9IHNlZW4uZ2V0KHBhcmVudCk7XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4ID4gY29sLmxlbmd0aCkgYnJlYWs7XG4gICAgICAgICAgICAgICAgZm9yKGxldCBpID0gaW5kZXg7IGkgPCBjb2wubGVuZ3RoOyBpKyspY29sdW1uLnNwbGljZShpLCAwLCBudWxsKTtcbiAgICAgICAgICAgICAgICAvLyBBZGp1c3Qgc2hpZnRlZCBpbmRpY2VzXG4gICAgICAgICAgICAgICAgZm9yKGxldCBpID0gY29sLmxlbmd0aDsgaSA8IGNvbHVtbi5sZW5ndGg7IGkrKykvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbWF4LWRlcHRoXG4gICAgICAgICAgICAgICAgaWYgKGNvbHVtbltpXSAmJiBzZWVuLmhhcyhjb2x1bW5baV0pKSBzZWVuLmdldChjb2x1bW5baV0pLmluZGV4ID0gaTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcGFyZW50LmNvbHNwYW4gPSAxO1xuICAgICAgICAgICAgICAgIGNvbC5wdXNoKHBhcmVudCk7XG4gICAgICAgICAgICAgICAgc2Vlbi5zZXQocGFyZW50LCB7XG4gICAgICAgICAgICAgICAgICAgIGNvbHVtbjogY29sLFxuICAgICAgICAgICAgICAgICAgICBpbmRleDogY29sLmxlbmd0aCAtIDFcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBhcmVudEtleSA9IHBhcmVudC5wYXJlbnRLZXk7XG4gICAgICAgIH1cbiAgICAgICAgY29sdW1ucy5wdXNoKGNvbCk7XG4gICAgICAgIGNvbHVtbi5pbmRleCA9IGNvbHVtbnMubGVuZ3RoIC0gMTtcbiAgICB9XG4gICAgbGV0IG1heExlbmd0aCA9IE1hdGgubWF4KC4uLmNvbHVtbnMubWFwKChjKT0+Yy5sZW5ndGgpKTtcbiAgICBsZXQgaGVhZGVyUm93cyA9IEFycmF5KG1heExlbmd0aCkuZmlsbCgwKS5tYXAoKCk9PltdKTtcbiAgICAvLyBDb252ZXJ0IGNvbHVtbnMgaW50byByb3dzLlxuICAgIGxldCBjb2xJbmRleCA9IDA7XG4gICAgZm9yIChsZXQgY29sdW1uIG9mIGNvbHVtbnMpe1xuICAgICAgICBsZXQgaSA9IG1heExlbmd0aCAtIDE7XG4gICAgICAgIGZvciAobGV0IGl0ZW0gb2YgY29sdW1uKXtcbiAgICAgICAgICAgIGlmIChpdGVtKSB7XG4gICAgICAgICAgICAgICAgLy8gRmlsbCB0aGUgc3BhY2UgdXAgdW50aWwgdGhlIGN1cnJlbnQgY29sdW1uIHdpdGggYSBwbGFjZWhvbGRlclxuICAgICAgICAgICAgICAgIGxldCByb3cgPSBoZWFkZXJSb3dzW2ldO1xuICAgICAgICAgICAgICAgIGxldCByb3dMZW5ndGggPSByb3cucmVkdWNlKChwLCBjKT0+cCArIGMuY29sc3BhbiwgMCk7XG4gICAgICAgICAgICAgICAgaWYgKHJvd0xlbmd0aCA8IGNvbEluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBwbGFjZWhvbGRlciA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwicGxhY2Vob2xkZXJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleTogXCJwbGFjZWhvbGRlci1cIiArIGl0ZW0ua2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sc3BhbjogY29sSW5kZXggLSByb3dMZW5ndGgsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleDogcm93TGVuZ3RoLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICByZW5kZXJlZDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldmVsOiBpLFxuICAgICAgICAgICAgICAgICAgICAgICAgaGFzQ2hpbGROb2RlczogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGlsZE5vZGVzOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHRWYWx1ZTogbnVsbFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbWF4LWRlcHRoXG4gICAgICAgICAgICAgICAgICAgIGlmIChyb3cubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcm93W3Jvdy5sZW5ndGggLSAxXS5uZXh0S2V5ID0gcGxhY2Vob2xkZXIua2V5O1xuICAgICAgICAgICAgICAgICAgICAgICAgcGxhY2Vob2xkZXIucHJldktleSA9IHJvd1tyb3cubGVuZ3RoIC0gMV0ua2V5O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJvdy5wdXNoKHBsYWNlaG9sZGVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHJvdy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJvd1tyb3cubGVuZ3RoIC0gMV0ubmV4dEtleSA9IGl0ZW0ua2V5O1xuICAgICAgICAgICAgICAgICAgICBpdGVtLnByZXZLZXkgPSByb3dbcm93Lmxlbmd0aCAtIDFdLmtleTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaXRlbS5sZXZlbCA9IGk7XG4gICAgICAgICAgICAgICAgaXRlbS5jb2xJbmRleCA9IGNvbEluZGV4O1xuICAgICAgICAgICAgICAgIHJvdy5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaS0tO1xuICAgICAgICB9XG4gICAgICAgIGNvbEluZGV4Kys7XG4gICAgfVxuICAgIC8vIEFkZCBwbGFjZWhvbGRlcnMgYXQgdGhlIGVuZCBvZiBlYWNoIHJvdyB0aGF0IGlzIHNob3J0ZXIgdGhhbiB0aGUgbWF4aW11bVxuICAgIGxldCBpID0gMDtcbiAgICBmb3IgKGxldCByb3cgb2YgaGVhZGVyUm93cyl7XG4gICAgICAgIGxldCByb3dMZW5ndGggPSByb3cucmVkdWNlKChwLCBjKT0+cCArIGMuY29sc3BhbiwgMCk7XG4gICAgICAgIGlmIChyb3dMZW5ndGggPCBjb2x1bW5Ob2Rlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGxldCBwbGFjZWhvbGRlciA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcInBsYWNlaG9sZGVyXCIsXG4gICAgICAgICAgICAgICAga2V5OiBcInBsYWNlaG9sZGVyLVwiICsgcm93W3Jvdy5sZW5ndGggLSAxXS5rZXksXG4gICAgICAgICAgICAgICAgY29sc3BhbjogY29sdW1uTm9kZXMubGVuZ3RoIC0gcm93TGVuZ3RoLFxuICAgICAgICAgICAgICAgIGluZGV4OiByb3dMZW5ndGgsXG4gICAgICAgICAgICAgICAgdmFsdWU6IG51bGwsXG4gICAgICAgICAgICAgICAgcmVuZGVyZWQ6IG51bGwsXG4gICAgICAgICAgICAgICAgbGV2ZWw6IGksXG4gICAgICAgICAgICAgICAgaGFzQ2hpbGROb2RlczogZmFsc2UsXG4gICAgICAgICAgICAgICAgY2hpbGROb2RlczogW10sXG4gICAgICAgICAgICAgICAgdGV4dFZhbHVlOiBudWxsLFxuICAgICAgICAgICAgICAgIHByZXZLZXk6IHJvd1tyb3cubGVuZ3RoIC0gMV0ua2V5XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcm93LnB1c2gocGxhY2Vob2xkZXIpO1xuICAgICAgICB9XG4gICAgICAgIGkrKztcbiAgICB9XG4gICAgcmV0dXJuIGhlYWRlclJvd3MubWFwKChjaGlsZE5vZGVzLCBpbmRleCk9PntcbiAgICAgICAgbGV0IHJvdyA9IHtcbiAgICAgICAgICAgIHR5cGU6IFwiaGVhZGVycm93XCIsXG4gICAgICAgICAgICBrZXk6IFwiaGVhZGVycm93LVwiICsgaW5kZXgsXG4gICAgICAgICAgICBpbmRleDogaW5kZXgsXG4gICAgICAgICAgICB2YWx1ZTogbnVsbCxcbiAgICAgICAgICAgIHJlbmRlcmVkOiBudWxsLFxuICAgICAgICAgICAgbGV2ZWw6IDAsXG4gICAgICAgICAgICBoYXNDaGlsZE5vZGVzOiB0cnVlLFxuICAgICAgICAgICAgY2hpbGROb2RlczogY2hpbGROb2RlcyxcbiAgICAgICAgICAgIHRleHRWYWx1ZTogbnVsbFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gcm93O1xuICAgIH0pO1xufVxuY2xhc3MgJDc4ODc4MWJhYTMwMTE3ZmEkZXhwb3J0JDU5NmUxYjJlMmNmOTM2OTAgZXh0ZW5kcyAoMCwgJDFCZmpXJEdyaWRDb2xsZWN0aW9uKSB7XG4gICAgKltTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgICAgICB5aWVsZCogdGhpcy5ib2R5LmNoaWxkTm9kZXM7XG4gICAgfVxuICAgIGdldCBzaXplKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2l6ZTtcbiAgICB9XG4gICAgZ2V0S2V5cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMua2V5TWFwLmtleXMoKTtcbiAgICB9XG4gICAgZ2V0S2V5QmVmb3JlKGtleSkge1xuICAgICAgICBsZXQgbm9kZSA9IHRoaXMua2V5TWFwLmdldChrZXkpO1xuICAgICAgICByZXR1cm4gbm9kZSA/IG5vZGUucHJldktleSA6IG51bGw7XG4gICAgfVxuICAgIGdldEtleUFmdGVyKGtleSkge1xuICAgICAgICBsZXQgbm9kZSA9IHRoaXMua2V5TWFwLmdldChrZXkpO1xuICAgICAgICByZXR1cm4gbm9kZSA/IG5vZGUubmV4dEtleSA6IG51bGw7XG4gICAgfVxuICAgIGdldEZpcnN0S2V5KCkge1xuICAgICAgICB2YXIgX2dldEZpcnN0SXRlbTtcbiAgICAgICAgcmV0dXJuIChfZ2V0Rmlyc3RJdGVtID0gKDAsICQxQmZqVyRnZXRGaXJzdEl0ZW0pKHRoaXMuYm9keS5jaGlsZE5vZGVzKSkgPT09IG51bGwgfHwgX2dldEZpcnN0SXRlbSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2dldEZpcnN0SXRlbS5rZXk7XG4gICAgfVxuICAgIGdldExhc3RLZXkoKSB7XG4gICAgICAgIHZhciBfZ2V0TGFzdEl0ZW07XG4gICAgICAgIHJldHVybiAoX2dldExhc3RJdGVtID0gKDAsICQxQmZqVyRnZXRMYXN0SXRlbSkodGhpcy5ib2R5LmNoaWxkTm9kZXMpKSA9PT0gbnVsbCB8fCBfZ2V0TGFzdEl0ZW0gPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9nZXRMYXN0SXRlbS5rZXk7XG4gICAgfVxuICAgIGdldEl0ZW0oa2V5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmtleU1hcC5nZXQoa2V5KTtcbiAgICB9XG4gICAgYXQoaWR4KSB7XG4gICAgICAgIGNvbnN0IGtleXMgPSBbXG4gICAgICAgICAgICAuLi50aGlzLmdldEtleXMoKVxuICAgICAgICBdO1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRJdGVtKGtleXNbaWR4XSk7XG4gICAgfVxuICAgIGdldFRleHRWYWx1ZShrZXkpIHtcbiAgICAgICAgbGV0IHJvdyA9IHRoaXMuZ2V0SXRlbShrZXkpO1xuICAgICAgICBpZiAoIXJvdykgcmV0dXJuIFwiXCI7XG4gICAgICAgIC8vIElmIHRoZSByb3cgaGFzIGEgdGV4dFZhbHVlLCB1c2UgdGhhdC5cbiAgICAgICAgaWYgKHJvdy50ZXh0VmFsdWUpIHJldHVybiByb3cudGV4dFZhbHVlO1xuICAgICAgICAvLyBPdGhlcndpc2UgY29tYmluZSB0aGUgdGV4dCBvZiBlYWNoIG9mIHRoZSByb3cgaGVhZGVyIGNvbHVtbnMuXG4gICAgICAgIGxldCByb3dIZWFkZXJDb2x1bW5LZXlzID0gdGhpcy5yb3dIZWFkZXJDb2x1bW5LZXlzO1xuICAgICAgICBpZiAocm93SGVhZGVyQ29sdW1uS2V5cykge1xuICAgICAgICAgICAgbGV0IHRleHQgPSBbXTtcbiAgICAgICAgICAgIGZvciAobGV0IGNlbGwgb2Ygcm93LmNoaWxkTm9kZXMpe1xuICAgICAgICAgICAgICAgIGxldCBjb2x1bW4gPSB0aGlzLmNvbHVtbnNbY2VsbC5pbmRleF07XG4gICAgICAgICAgICAgICAgaWYgKHJvd0hlYWRlckNvbHVtbktleXMuaGFzKGNvbHVtbi5rZXkpICYmIGNlbGwudGV4dFZhbHVlKSB0ZXh0LnB1c2goY2VsbC50ZXh0VmFsdWUpO1xuICAgICAgICAgICAgICAgIGlmICh0ZXh0Lmxlbmd0aCA9PT0gcm93SGVhZGVyQ29sdW1uS2V5cy5zaXplKSBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0ZXh0LmpvaW4oXCIgXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBcIlwiO1xuICAgIH1cbiAgICBjb25zdHJ1Y3Rvcihub2RlcywgcHJldiwgb3B0cyl7XG4gICAgICAgIGxldCByb3dIZWFkZXJDb2x1bW5LZXlzID0gbmV3IFNldCgpO1xuICAgICAgICBsZXQgYm9keTtcbiAgICAgICAgbGV0IGNvbHVtbnMgPSBbXTtcbiAgICAgICAgLy8gQWRkIGNlbGwgZm9yIHNlbGVjdGlvbiBjaGVja2JveGVzIGlmIG5lZWRlZC5cbiAgICAgICAgaWYgKG9wdHMgPT09IG51bGwgfHwgb3B0cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0cy5zaG93U2VsZWN0aW9uQ2hlY2tib3hlcykge1xuICAgICAgICAgICAgbGV0IHJvd0hlYWRlckNvbHVtbiA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImNvbHVtblwiLFxuICAgICAgICAgICAgICAgIGtleTogJDc4ODc4MWJhYTMwMTE3ZmEkdmFyJFJPV19IRUFERVJfQ09MVU1OX0tFWSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogbnVsbCxcbiAgICAgICAgICAgICAgICB0ZXh0VmFsdWU6IFwiXCIsXG4gICAgICAgICAgICAgICAgbGV2ZWw6IDAsXG4gICAgICAgICAgICAgICAgaW5kZXg6IChvcHRzID09PSBudWxsIHx8IG9wdHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdHMuc2hvd0RyYWdCdXR0b25zKSA/IDEgOiAwLFxuICAgICAgICAgICAgICAgIGhhc0NoaWxkTm9kZXM6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHJlbmRlcmVkOiBudWxsLFxuICAgICAgICAgICAgICAgIGNoaWxkTm9kZXM6IFtdLFxuICAgICAgICAgICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgICAgICAgICAgIGlzU2VsZWN0aW9uQ2VsbDogdHJ1ZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb2x1bW5zLnVuc2hpZnQocm93SGVhZGVyQ29sdW1uKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBBZGQgY2VsbCBmb3IgZHJhZyBidXR0b25zIGlmIG5lZWRlZC5cbiAgICAgICAgaWYgKG9wdHMgPT09IG51bGwgfHwgb3B0cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0cy5zaG93RHJhZ0J1dHRvbnMpIHtcbiAgICAgICAgICAgIGxldCByb3dIZWFkZXJDb2x1bW4gPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJjb2x1bW5cIixcbiAgICAgICAgICAgICAgICBrZXk6ICQ3ODg3ODFiYWEzMDExN2ZhJHZhciRST1dfSEVBREVSX0NPTFVNTl9LRVlfRFJBRyxcbiAgICAgICAgICAgICAgICB2YWx1ZTogbnVsbCxcbiAgICAgICAgICAgICAgICB0ZXh0VmFsdWU6IFwiXCIsXG4gICAgICAgICAgICAgICAgbGV2ZWw6IDAsXG4gICAgICAgICAgICAgICAgaW5kZXg6IDAsXG4gICAgICAgICAgICAgICAgaGFzQ2hpbGROb2RlczogZmFsc2UsXG4gICAgICAgICAgICAgICAgcmVuZGVyZWQ6IG51bGwsXG4gICAgICAgICAgICAgICAgY2hpbGROb2RlczogW10sXG4gICAgICAgICAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICAgICAgICAgICAgaXNEcmFnQnV0dG9uQ2VsbDogdHJ1ZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb2x1bW5zLnVuc2hpZnQocm93SGVhZGVyQ29sdW1uKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcm93cyA9IFtdO1xuICAgICAgICBsZXQgY29sdW1uS2V5TWFwID0gbmV3IE1hcCgpO1xuICAgICAgICBsZXQgdmlzaXQgPSAobm9kZSk9PntcbiAgICAgICAgICAgIHN3aXRjaChub2RlLnR5cGUpe1xuICAgICAgICAgICAgICAgIGNhc2UgXCJib2R5XCI6XG4gICAgICAgICAgICAgICAgICAgIGJvZHkgPSBub2RlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwiY29sdW1uXCI6XG4gICAgICAgICAgICAgICAgICAgIGNvbHVtbktleU1hcC5zZXQobm9kZS5rZXksIG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW5vZGUuaGFzQ2hpbGROb2Rlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29sdW1ucy5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUucHJvcHMuaXNSb3dIZWFkZXIpIHJvd0hlYWRlckNvbHVtbktleXMuYWRkKG5vZGUua2V5KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwiaXRlbVwiOlxuICAgICAgICAgICAgICAgICAgICByb3dzLnB1c2gobm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjsgLy8gZG8gbm90IGdvIGludG8gY2hpbGROb2Rlc1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChsZXQgY2hpbGQgb2Ygbm9kZS5jaGlsZE5vZGVzKXZpc2l0KGNoaWxkKTtcbiAgICAgICAgfTtcbiAgICAgICAgZm9yIChsZXQgbm9kZSBvZiBub2Rlcyl2aXNpdChub2RlKTtcbiAgICAgICAgbGV0IGhlYWRlclJvd3MgPSAkNzg4NzgxYmFhMzAxMTdmYSRleHBvcnQkN2MxMjdkYjg1MGQ0ZTgxZShjb2x1bW5LZXlNYXAsIGNvbHVtbnMpO1xuICAgICAgICBoZWFkZXJSb3dzLmZvckVhY2goKHJvdywgaSk9PnJvd3Muc3BsaWNlKGksIDAsIHJvdykpO1xuICAgICAgICBzdXBlcih7XG4gICAgICAgICAgICBjb2x1bW5Db3VudDogY29sdW1ucy5sZW5ndGgsXG4gICAgICAgICAgICBpdGVtczogcm93cyxcbiAgICAgICAgICAgIHZpc2l0Tm9kZTogKG5vZGUpPT57XG4gICAgICAgICAgICAgICAgbm9kZS5jb2x1bW4gPSBjb2x1bW5zW25vZGUuaW5kZXhdO1xuICAgICAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fc2l6ZSA9IDA7XG4gICAgICAgIHRoaXMuY29sdW1ucyA9IGNvbHVtbnM7XG4gICAgICAgIHRoaXMucm93SGVhZGVyQ29sdW1uS2V5cyA9IHJvd0hlYWRlckNvbHVtbktleXM7XG4gICAgICAgIHRoaXMuYm9keSA9IGJvZHk7XG4gICAgICAgIHRoaXMuaGVhZGVyUm93cyA9IGhlYWRlclJvd3M7XG4gICAgICAgIHRoaXMuX3NpemUgPSBbXG4gICAgICAgICAgICAuLi5ib2R5LmNoaWxkTm9kZXNcbiAgICAgICAgXS5sZW5ndGg7XG4gICAgICAgIC8vIERlZmF1bHQgcm93IGhlYWRlciBjb2x1bW4gdG8gdGhlIGZpcnN0IG9uZS5cbiAgICAgICAgaWYgKHRoaXMucm93SGVhZGVyQ29sdW1uS2V5cy5zaXplID09PSAwKSB7XG4gICAgICAgICAgICBpZiAob3B0cyA9PT0gbnVsbCB8fCBvcHRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRzLnNob3dTZWxlY3Rpb25DaGVja2JveGVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKG9wdHMgPT09IG51bGwgfHwgb3B0cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0cy5zaG93RHJhZ0J1dHRvbnMpIHRoaXMucm93SGVhZGVyQ29sdW1uS2V5cy5hZGQodGhpcy5jb2x1bW5zWzJdLmtleSk7XG4gICAgICAgICAgICAgICAgZWxzZSB0aGlzLnJvd0hlYWRlckNvbHVtbktleXMuYWRkKHRoaXMuY29sdW1uc1sxXS5rZXkpO1xuICAgICAgICAgICAgfSBlbHNlIHRoaXMucm93SGVhZGVyQ29sdW1uS2V5cy5hZGQodGhpcy5jb2x1bW5zWzBdLmtleSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cblxuXG5jb25zdCAkNGEwZGQwMzZkNDkyY2VlNCR2YXIkT1BQT1NJVEVfU09SVF9ESVJFQ1RJT04gPSB7XG4gICAgYXNjZW5kaW5nOiBcImRlc2NlbmRpbmdcIixcbiAgICBkZXNjZW5kaW5nOiBcImFzY2VuZGluZ1wiXG59O1xuZnVuY3Rpb24gJDRhMGRkMDM2ZDQ5MmNlZTQkZXhwb3J0JDkwN2JjYzZjNDgzMjVmZDYocHJvcHMpIHtcbiAgICBsZXQgW2lzS2V5Ym9hcmROYXZpZ2F0aW9uRGlzYWJsZWQsIHNldEtleWJvYXJkTmF2aWdhdGlvbkRpc2FibGVkXSA9ICgwLCAkMUJmalckdXNlU3RhdGUpKGZhbHNlKTtcbiAgICBsZXQgeyBzZWxlY3Rpb25Nb2RlOiBzZWxlY3Rpb25Nb2RlID0gXCJub25lXCIsIHNob3dTZWxlY3Rpb25DaGVja2JveGVzOiBzaG93U2VsZWN0aW9uQ2hlY2tib3hlcywgc2hvd0RyYWdCdXR0b25zOiBzaG93RHJhZ0J1dHRvbnMgfSA9IHByb3BzO1xuICAgIGxldCBjb250ZXh0ID0gKDAsICQxQmZqVyR1c2VNZW1vKSgoKT0+KHtcbiAgICAgICAgICAgIHNob3dTZWxlY3Rpb25DaGVja2JveGVzOiBzaG93U2VsZWN0aW9uQ2hlY2tib3hlcyAmJiBzZWxlY3Rpb25Nb2RlICE9PSBcIm5vbmVcIixcbiAgICAgICAgICAgIHNob3dEcmFnQnV0dG9uczogc2hvd0RyYWdCdXR0b25zLFxuICAgICAgICAgICAgc2VsZWN0aW9uTW9kZTogc2VsZWN0aW9uTW9kZSxcbiAgICAgICAgICAgIGNvbHVtbnM6IFtdXG4gICAgICAgIH0pLCBbXG4gICAgICAgIHByb3BzLmNoaWxkcmVuLFxuICAgICAgICBzaG93U2VsZWN0aW9uQ2hlY2tib3hlcyxcbiAgICAgICAgc2VsZWN0aW9uTW9kZSxcbiAgICAgICAgc2hvd0RyYWdCdXR0b25zXG4gICAgXSk7XG4gICAgbGV0IGNvbGxlY3Rpb24gPSAoMCwgJDFCZmpXJHVzZUNvbGxlY3Rpb24pKHByb3BzLCAoMCwgJDFCZmpXJHVzZUNhbGxiYWNrKSgobm9kZXMpPT5uZXcgKDAsICQ3ODg3ODFiYWEzMDExN2ZhJGV4cG9ydCQ1OTZlMWIyZTJjZjkzNjkwKShub2RlcywgbnVsbCwgY29udGV4dCksIFtcbiAgICAgICAgY29udGV4dFxuICAgIF0pLCBjb250ZXh0KTtcbiAgICBsZXQgeyBkaXNhYmxlZEtleXM6IGRpc2FibGVkS2V5cywgc2VsZWN0aW9uTWFuYWdlcjogc2VsZWN0aW9uTWFuYWdlciB9ID0gKDAsICQxQmZqVyR1c2VHcmlkU3RhdGUpKHtcbiAgICAgICAgLi4ucHJvcHMsXG4gICAgICAgIGNvbGxlY3Rpb246IGNvbGxlY3Rpb24sXG4gICAgICAgIGRpc2FibGVkQmVoYXZpb3I6IHByb3BzLmRpc2FibGVkQmVoYXZpb3IgfHwgXCJzZWxlY3Rpb25cIlxuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICAgIGNvbGxlY3Rpb246IGNvbGxlY3Rpb24sXG4gICAgICAgIGRpc2FibGVkS2V5czogZGlzYWJsZWRLZXlzLFxuICAgICAgICBzZWxlY3Rpb25NYW5hZ2VyOiBzZWxlY3Rpb25NYW5hZ2VyLFxuICAgICAgICBzaG93U2VsZWN0aW9uQ2hlY2tib3hlczogcHJvcHMuc2hvd1NlbGVjdGlvbkNoZWNrYm94ZXMgfHwgZmFsc2UsXG4gICAgICAgIHNvcnREZXNjcmlwdG9yOiBwcm9wcy5zb3J0RGVzY3JpcHRvcixcbiAgICAgICAgaXNLZXlib2FyZE5hdmlnYXRpb25EaXNhYmxlZDogY29sbGVjdGlvbi5zaXplID09PSAwIHx8IGlzS2V5Ym9hcmROYXZpZ2F0aW9uRGlzYWJsZWQsXG4gICAgICAgIHNldEtleWJvYXJkTmF2aWdhdGlvbkRpc2FibGVkOiBzZXRLZXlib2FyZE5hdmlnYXRpb25EaXNhYmxlZCxcbiAgICAgICAgc29ydCAoY29sdW1uS2V5LCBkaXJlY3Rpb24pIHtcbiAgICAgICAgICAgIHZhciBfcHJvcHNfc29ydERlc2NyaXB0b3I7XG4gICAgICAgICAgICBwcm9wcy5vblNvcnRDaGFuZ2Uoe1xuICAgICAgICAgICAgICAgIGNvbHVtbjogY29sdW1uS2V5LFxuICAgICAgICAgICAgICAgIGRpcmVjdGlvbjogZGlyZWN0aW9uICE9PSBudWxsICYmIGRpcmVjdGlvbiAhPT0gdm9pZCAwID8gZGlyZWN0aW9uIDogKChfcHJvcHNfc29ydERlc2NyaXB0b3IgPSBwcm9wcy5zb3J0RGVzY3JpcHRvcikgPT09IG51bGwgfHwgX3Byb3BzX3NvcnREZXNjcmlwdG9yID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfcHJvcHNfc29ydERlc2NyaXB0b3IuY29sdW1uKSA9PT0gY29sdW1uS2V5ID8gJDRhMGRkMDM2ZDQ5MmNlZTQkdmFyJE9QUE9TSVRFX1NPUlRfRElSRUNUSU9OW3Byb3BzLnNvcnREZXNjcmlwdG9yLmRpcmVjdGlvbl0gOiBcImFzY2VuZGluZ1wiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG59XG5cblxuLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIFxuZnVuY3Rpb24gJDMxMmFlM2I1NmE5NGE4NmUkdmFyJFRhYmxlSGVhZGVyKHByb3BzKSB7XG4gICAgcmV0dXJuIG51bGw7XG59XG4kMzEyYWUzYjU2YTk0YTg2ZSR2YXIkVGFibGVIZWFkZXIuZ2V0Q29sbGVjdGlvbk5vZGUgPSBmdW5jdGlvbiogZ2V0Q29sbGVjdGlvbk5vZGUocHJvcHMsIGNvbnRleHQpIHtcbiAgICBsZXQgeyBjaGlsZHJlbjogY2hpbGRyZW4sIGNvbHVtbnM6IGNvbHVtbnMgfSA9IHByb3BzO1xuICAgIC8vIENsZWFyIGNvbHVtbnMgc28gdGhleSBhcmVuJ3QgZG91YmxlIGFkZGVkIGluIHN0cmljdCBtb2RlLlxuICAgIGNvbnRleHQuY29sdW1ucyA9IFtdO1xuICAgIGlmICh0eXBlb2YgY2hpbGRyZW4gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBpZiAoIWNvbHVtbnMpIHRocm93IG5ldyBFcnJvcihcInByb3BzLmNoaWxkcmVuIHdhcyBhIGZ1bmN0aW9uIGJ1dCBwcm9wcy5jb2x1bW5zIGlzIG1pc3NpbmdcIik7XG4gICAgICAgIGZvciAobGV0IGNvbHVtbiBvZiBjb2x1bW5zKXlpZWxkIHtcbiAgICAgICAgICAgIHR5cGU6IFwiY29sdW1uXCIsXG4gICAgICAgICAgICB2YWx1ZTogY29sdW1uLFxuICAgICAgICAgICAgcmVuZGVyZXI6IGNoaWxkcmVuXG4gICAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgbGV0IGNvbHVtbnMgPSBbXTtcbiAgICAgICAgKDAsICQxQmZqVyRyZWFjdCkuQ2hpbGRyZW4uZm9yRWFjaChjaGlsZHJlbiwgKGNvbHVtbik9PntcbiAgICAgICAgICAgIGNvbHVtbnMucHVzaCh7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJjb2x1bW5cIixcbiAgICAgICAgICAgICAgICBlbGVtZW50OiBjb2x1bW5cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgeWllbGQqIGNvbHVtbnM7XG4gICAgfVxufTtcbi8qKlxuICogQSBUYWJsZUhlYWRlciBpcyBhIGNvbnRhaW5lciBmb3IgdGhlIENvbHVtbiBlbGVtZW50cyBpbiBhIFRhYmxlLiBDb2x1bW5zIGNhbiBiZSBzdGF0aWNhbGx5IGRlZmluZWRcbiAqIGFzIGNoaWxkcmVuLCBvciBnZW5lcmF0ZWQgZHluYW1pY2FsbHkgdXNpbmcgYSBmdW5jdGlvbiBiYXNlZCBvbiB0aGUgZGF0YSBwYXNzZWQgdG8gdGhlIGBjb2x1bW5zYCBwcm9wLlxuICovIC8vIFdlIGRvbid0IHdhbnQgZ2V0Q29sbGVjdGlvbk5vZGUgdG8gc2hvdyB1cCBpbiB0aGUgdHlwZSBkZWZpbml0aW9uXG5sZXQgJDMxMmFlM2I1NmE5NGE4NmUkZXhwb3J0JGY4NTA4OTViMjg3ZWYyOGUgPSAkMzEyYWUzYjU2YTk0YTg2ZSR2YXIkVGFibGVIZWFkZXI7XG5cblxuLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIFxuZnVuY3Rpb24gJDRhZTUzMTRiZjUwZGIxYTMkdmFyJFRhYmxlQm9keShwcm9wcykge1xuICAgIHJldHVybiBudWxsO1xufVxuJDRhZTUzMTRiZjUwZGIxYTMkdmFyJFRhYmxlQm9keS5nZXRDb2xsZWN0aW9uTm9kZSA9IGZ1bmN0aW9uKiBnZXRDb2xsZWN0aW9uTm9kZShwcm9wcykge1xuICAgIGxldCB7IGNoaWxkcmVuOiBjaGlsZHJlbiwgaXRlbXM6IGl0ZW1zIH0gPSBwcm9wcztcbiAgICB5aWVsZCB7XG4gICAgICAgIHR5cGU6IFwiYm9keVwiLFxuICAgICAgICBoYXNDaGlsZE5vZGVzOiB0cnVlLFxuICAgICAgICBwcm9wczogcHJvcHMsXG4gICAgICAgICpjaGlsZE5vZGVzICgpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY2hpbGRyZW4gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIGlmICghaXRlbXMpIHRocm93IG5ldyBFcnJvcihcInByb3BzLmNoaWxkcmVuIHdhcyBhIGZ1bmN0aW9uIGJ1dCBwcm9wcy5pdGVtcyBpcyBtaXNzaW5nXCIpO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGl0ZW0gb2YgaXRlbXMpeWllbGQge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcIml0ZW1cIixcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGl0ZW0sXG4gICAgICAgICAgICAgICAgICAgIHJlbmRlcmVyOiBjaGlsZHJlblxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBpdGVtcyA9IFtdO1xuICAgICAgICAgICAgICAgICgwLCAkMUJmalckcmVhY3QpLkNoaWxkcmVuLmZvckVhY2goY2hpbGRyZW4sIChpdGVtKT0+e1xuICAgICAgICAgICAgICAgICAgICBpdGVtcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiaXRlbVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudDogaXRlbVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB5aWVsZCogaXRlbXM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xufTtcbi8qKlxuICogQSBUYWJsZUJvZHkgaXMgYSBjb250YWluZXIgZm9yIHRoZSBSb3cgZWxlbWVudHMgb2YgYSBUYWJsZS4gUm93cyBjYW4gYmUgc3RhdGljYWxseSBkZWZpbmVkXG4gKiBhcyBjaGlsZHJlbiwgb3IgZ2VuZXJhdGVkIGR5bmFtaWNhbGx5IHVzaW5nIGEgZnVuY3Rpb24gYmFzZWQgb24gdGhlIGRhdGEgcGFzc2VkIHRvIHRoZSBgaXRlbXNgIHByb3AuXG4gKi8gLy8gV2UgZG9uJ3Qgd2FudCBnZXRDb2xsZWN0aW9uTm9kZSB0byBzaG93IHVwIGluIHRoZSB0eXBlIGRlZmluaXRpb25cbmxldCAkNGFlNTMxNGJmNTBkYjFhMyRleHBvcnQkNzZjY2QyMTBiOTAyOTkxNyA9ICQ0YWU1MzE0YmY1MGRiMWEzJHZhciRUYWJsZUJvZHk7XG5cblxuLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIFxuZnVuY3Rpb24gJDFjZDI0NDU1N2MyZjk3ZDUkdmFyJENvbHVtbihwcm9wcykge1xuICAgIHJldHVybiBudWxsO1xufVxuJDFjZDI0NDU1N2MyZjk3ZDUkdmFyJENvbHVtbi5nZXRDb2xsZWN0aW9uTm9kZSA9IGZ1bmN0aW9uKiBnZXRDb2xsZWN0aW9uTm9kZShwcm9wcywgY29udGV4dCkge1xuICAgIGxldCB7IHRpdGxlOiB0aXRsZSwgY2hpbGRyZW46IGNoaWxkcmVuLCBjaGlsZENvbHVtbnM6IGNoaWxkQ29sdW1ucyB9ID0gcHJvcHM7XG4gICAgbGV0IHJlbmRlcmVkID0gdGl0bGUgfHwgY2hpbGRyZW47XG4gICAgbGV0IHRleHRWYWx1ZSA9IHByb3BzLnRleHRWYWx1ZSB8fCAodHlwZW9mIHJlbmRlcmVkID09PSBcInN0cmluZ1wiID8gcmVuZGVyZWQgOiBcIlwiKSB8fCBwcm9wc1tcImFyaWEtbGFiZWxcIl07XG4gICAgbGV0IGZ1bGxOb2RlcyA9IHlpZWxkIHtcbiAgICAgICAgdHlwZTogXCJjb2x1bW5cIixcbiAgICAgICAgaGFzQ2hpbGROb2RlczogISFjaGlsZENvbHVtbnMgfHwgdGl0bGUgJiYgKDAsICQxQmZqVyRyZWFjdCkuQ2hpbGRyZW4uY291bnQoY2hpbGRyZW4pID4gMCxcbiAgICAgICAgcmVuZGVyZWQ6IHJlbmRlcmVkLFxuICAgICAgICB0ZXh0VmFsdWU6IHRleHRWYWx1ZSxcbiAgICAgICAgcHJvcHM6IHByb3BzLFxuICAgICAgICAqY2hpbGROb2RlcyAoKSB7XG4gICAgICAgICAgICBpZiAoY2hpbGRDb2x1bW5zKSBmb3IgKGxldCBjaGlsZCBvZiBjaGlsZENvbHVtbnMpeWllbGQge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiY29sdW1uXCIsXG4gICAgICAgICAgICAgICAgdmFsdWU6IGNoaWxkXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZWxzZSBpZiAodGl0bGUpIHtcbiAgICAgICAgICAgICAgICBsZXQgY2hpbGRDb2x1bW5zID0gW107XG4gICAgICAgICAgICAgICAgKDAsICQxQmZqVyRyZWFjdCkuQ2hpbGRyZW4uZm9yRWFjaChjaGlsZHJlbiwgKGNoaWxkKT0+e1xuICAgICAgICAgICAgICAgICAgICBjaGlsZENvbHVtbnMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImNvbHVtblwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudDogY2hpbGRcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgeWllbGQqIGNoaWxkQ29sdW1ucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgc2hvdWxkSW52YWxpZGF0ZSAobmV3Q29udGV4dCkge1xuICAgICAgICAgICAgLy8gVGhpcyBpcyBhIGJpdCBvZiBhIGhhY2ssIGJ1dCBpdCB3b3Jrcy5cbiAgICAgICAgICAgIC8vIElmIHRoaXMgbWV0aG9kIGlzIGNhbGxlZCwgdGhlbiB0aGVyZSdzIGEgY2FjaGVkIHZlcnNpb24gb2YgdGhpcyBub2RlIGF2YWlsYWJsZS5cbiAgICAgICAgICAgIC8vIEJ1dCwgd2UgbmVlZCB0byBrZWVwIHRoZSBsaXN0IG9mIGNvbHVtbnMgaW4gdGhlIG5ldyBjb250ZXh0IHVwIHRvIGRhdGUuXG4gICAgICAgICAgICB1cGRhdGVDb250ZXh0KG5ld0NvbnRleHQpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBsZXQgdXBkYXRlQ29udGV4dCA9IChjb250ZXh0KT0+e1xuICAgICAgICAvLyByZWdpc3RlciBsZWFmIGNvbHVtbnMgb24gdGhlIGNvbnRleHQgc28gdGhhdCA8Um93PiBjYW4gYWNjZXNzIHRoZW1cbiAgICAgICAgZm9yIChsZXQgbm9kZSBvZiBmdWxsTm9kZXMpaWYgKCFub2RlLmhhc0NoaWxkTm9kZXMpIGNvbnRleHQuY29sdW1ucy5wdXNoKG5vZGUpO1xuICAgIH07XG4gICAgdXBkYXRlQ29udGV4dChjb250ZXh0KTtcbn07XG4vKipcbiAqIEEgQ29sdW1uIHJlcHJlc2VudHMgYSBmaWVsZCBvZiBlYWNoIGl0ZW0gd2l0aGluIGEgVGFibGUuIENvbHVtbnMgbWF5IGFsc28gY29udGFpbiBuZXN0ZWRcbiAqIENvbHVtbiBlbGVtZW50cyB0byByZXByZXNlbnQgY29sdW1uIGdyb3Vwcy4gTmVzdGVkIGNvbHVtbnMgY2FuIGJlIHN0YXRpY2FsbHkgZGVmaW5lZCBhc1xuICogY2hpbGRyZW4sIG9yIGR5bmFtaWNhbGx5IGdlbmVyYXRlZCB1c2luZyBhIGZ1bmN0aW9uIGJhc2VkIG9uIHRoZSBgY2hpbGRDb2x1bW5zYCBwcm9wLlxuICovIC8vIFdlIGRvbid0IHdhbnQgZ2V0Q29sbGVjdGlvbk5vZGUgdG8gc2hvdyB1cCBpbiB0aGUgdHlwZSBkZWZpbml0aW9uXG5sZXQgJDFjZDI0NDU1N2MyZjk3ZDUkZXhwb3J0JDgxNmI1ZDgxMTI5NWU2YmMgPSAkMWNkMjQ0NTU3YzJmOTdkNSR2YXIkQ29sdW1uO1xuXG5cbi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyBcbmZ1bmN0aW9uICQ3MGQ3MGViMTZlYTQ4NDI4JHZhciRSb3cocHJvcHMpIHtcbiAgICByZXR1cm4gbnVsbDtcbn1cbiQ3MGQ3MGViMTZlYTQ4NDI4JHZhciRSb3cuZ2V0Q29sbGVjdGlvbk5vZGUgPSBmdW5jdGlvbiogZ2V0Q29sbGVjdGlvbk5vZGUocHJvcHMsIGNvbnRleHQpIHtcbiAgICBsZXQgeyBjaGlsZHJlbjogY2hpbGRyZW4sIHRleHRWYWx1ZTogdGV4dFZhbHVlLCBVTlNUQUJMRV9jaGlsZEl0ZW1zOiBVTlNUQUJMRV9jaGlsZEl0ZW1zIH0gPSBwcm9wcztcbiAgICB5aWVsZCB7XG4gICAgICAgIHR5cGU6IFwiaXRlbVwiLFxuICAgICAgICBwcm9wczogcHJvcHMsXG4gICAgICAgIHRleHRWYWx1ZTogdGV4dFZhbHVlLFxuICAgICAgICBcImFyaWEtbGFiZWxcIjogcHJvcHNbXCJhcmlhLWxhYmVsXCJdLFxuICAgICAgICBoYXNDaGlsZE5vZGVzOiB0cnVlLFxuICAgICAgICAqY2hpbGROb2RlcyAoKSB7XG4gICAgICAgICAgICAvLyBQcm9jZXNzIGNlbGxzIGZpcnN0XG4gICAgICAgICAgICBpZiAoY29udGV4dC5zaG93RHJhZ0J1dHRvbnMpIHlpZWxkIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImNlbGxcIixcbiAgICAgICAgICAgICAgICBrZXk6IFwiaGVhZGVyLWRyYWdcIixcbiAgICAgICAgICAgICAgICBwcm9wczoge1xuICAgICAgICAgICAgICAgICAgICBpc0RyYWdCdXR0b25DZWxsOiB0cnVlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChjb250ZXh0LnNob3dTZWxlY3Rpb25DaGVja2JveGVzICYmIGNvbnRleHQuc2VsZWN0aW9uTW9kZSAhPT0gXCJub25lXCIpIHlpZWxkIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImNlbGxcIixcbiAgICAgICAgICAgICAgICBrZXk6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICAgICAgICAgICAgaXNTZWxlY3Rpb25DZWxsOiB0cnVlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY2hpbGRyZW4gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGNvbHVtbiBvZiBjb250ZXh0LmNvbHVtbnMpeWllbGQge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImNlbGxcIixcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudDogY2hpbGRyZW4oY29sdW1uLmtleSksXG4gICAgICAgICAgICAgICAgICAgIGtleTogY29sdW1uLmtleSAvLyB0aGlzIGlzIGNvbWJpbmVkIHdpdGggdGhlIHJvdyBrZXkgYnkgQ29sbGVjdGlvbkJ1aWxkZXJcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGlmIChVTlNUQUJMRV9jaGlsZEl0ZW1zKSBmb3IgKGxldCBjaGlsZCBvZiBVTlNUQUJMRV9jaGlsZEl0ZW1zKS8vIE5vdGU6IGluIG9yZGVyIHRvIHJldXNlIHRoZSByZW5kZXIgZnVuY3Rpb24gb2YgVGFibGVCb2R5IGZvciBvdXIgY2hpbGQgcm93cywgd2UganVzdCBuZWVkIHRvIHlpZWxkIGEgdHlwZSBhbmQgYSB2YWx1ZSBoZXJlLiBDb2xsZWN0aW9uQnVpbGRlciB3aWxsIHRoZW4gbG9vayB1cFxuICAgICAgICAgICAgICAgIC8vIHRoZSBwYXJlbnQgcmVuZGVyZXIgYW5kIHVzZSB0aGF0IHRvIGJ1aWxkIHRoZSBmdWxsIG5vZGUgb2YgdGhpcyBjaGlsZCByb3csIHVzaW5nIHRoZSB2YWx1ZSBwcm92aWRlZCBoZXJlIHRvIGdlbmVyYXRlIHRoZSBjZWxsc1xuICAgICAgICAgICAgICAgIHlpZWxkIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJpdGVtXCIsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBjaGlsZFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBjZWxscyA9IFtdO1xuICAgICAgICAgICAgICAgIGxldCBjaGlsZFJvd3MgPSBbXTtcbiAgICAgICAgICAgICAgICAoMCwgJDFCZmpXJHJlYWN0KS5DaGlsZHJlbi5mb3JFYWNoKGNoaWxkcmVuLCAobm9kZSk9PntcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUudHlwZSA9PT0gJDcwZDcwZWIxNmVhNDg0MjgkdmFyJFJvdykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNlbGxzLmxlbmd0aCA8IGNvbnRleHQuY29sdW1ucy5sZW5ndGgpIHRocm93IG5ldyBFcnJvcihcIkFsbCBvZiBhIFJvdydzIGNoaWxkIENlbGxzIG11c3QgYmUgcG9zaXRpb25lZCBiZWZvcmUgYW55IGNoaWxkIFJvd3MuXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRSb3dzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiaXRlbVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQ6IG5vZGVcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgY2VsbHMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImNlbGxcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQ6IG5vZGVcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKGNlbGxzLmxlbmd0aCAhPT0gY29udGV4dC5jb2x1bW5zLmxlbmd0aCkgdGhyb3cgbmV3IEVycm9yKGBDZWxsIGNvdW50IG11c3QgbWF0Y2ggY29sdW1uIGNvdW50LiBGb3VuZCAke2NlbGxzLmxlbmd0aH0gY2VsbHMgYW5kICR7Y29udGV4dC5jb2x1bW5zLmxlbmd0aH0gY29sdW1ucy5gKTtcbiAgICAgICAgICAgICAgICB5aWVsZCogY2VsbHM7XG4gICAgICAgICAgICAgICAgeWllbGQqIGNoaWxkUm93cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgc2hvdWxkSW52YWxpZGF0ZSAobmV3Q29udGV4dCkge1xuICAgICAgICAgICAgLy8gSW52YWxpZGF0ZSBhbGwgcm93cyBpZiB0aGUgY29sdW1ucyBjaGFuZ2VkLlxuICAgICAgICAgICAgcmV0dXJuIG5ld0NvbnRleHQuY29sdW1ucy5sZW5ndGggIT09IGNvbnRleHQuY29sdW1ucy5sZW5ndGggfHwgbmV3Q29udGV4dC5jb2x1bW5zLnNvbWUoKGMsIGkpPT5jLmtleSAhPT0gY29udGV4dC5jb2x1bW5zW2ldLmtleSkgfHwgbmV3Q29udGV4dC5zaG93U2VsZWN0aW9uQ2hlY2tib3hlcyAhPT0gY29udGV4dC5zaG93U2VsZWN0aW9uQ2hlY2tib3hlcyB8fCBuZXdDb250ZXh0LnNob3dEcmFnQnV0dG9ucyAhPT0gY29udGV4dC5zaG93RHJhZ0J1dHRvbnMgfHwgbmV3Q29udGV4dC5zZWxlY3Rpb25Nb2RlICE9PSBjb250ZXh0LnNlbGVjdGlvbk1vZGU7XG4gICAgICAgIH1cbiAgICB9O1xufTtcbi8qKlxuICogQSBSb3cgcmVwcmVzZW50cyBhIHNpbmdsZSBpdGVtIGluIGEgVGFibGUgYW5kIGNvbnRhaW5zIENlbGwgZWxlbWVudHMgZm9yIGVhY2ggY29sdW1uLlxuICogQ2VsbHMgY2FuIGJlIHN0YXRpY2FsbHkgZGVmaW5lZCBhcyBjaGlsZHJlbiwgb3IgZ2VuZXJhdGVkIGR5bmFtaWNhbGx5IHVzaW5nIGEgZnVuY3Rpb25cbiAqIGJhc2VkIG9uIHRoZSBjb2x1bW5zIGRlZmluZWQgaW4gdGhlIFRhYmxlSGVhZGVyLlxuICovIC8vIFdlIGRvbid0IHdhbnQgZ2V0Q29sbGVjdGlvbk5vZGUgdG8gc2hvdyB1cCBpbiB0aGUgdHlwZSBkZWZpbml0aW9uXG5sZXQgJDcwZDcwZWIxNmVhNDg0MjgkZXhwb3J0JGI1OWJkYmVmOWNlNzBkZTIgPSAkNzBkNzBlYjE2ZWE0ODQyOCR2YXIkUm93O1xuXG5cbi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyBmdW5jdGlvbiAkOTQxZDFkOWE2YTI4OTgyYSR2YXIkQ2VsbChwcm9wcykge1xuICAgIHJldHVybiBudWxsO1xufVxuJDk0MWQxZDlhNmEyODk4MmEkdmFyJENlbGwuZ2V0Q29sbGVjdGlvbk5vZGUgPSBmdW5jdGlvbiogZ2V0Q29sbGVjdGlvbk5vZGUocHJvcHMpIHtcbiAgICBsZXQgeyBjaGlsZHJlbjogY2hpbGRyZW4gfSA9IHByb3BzO1xuICAgIGxldCB0ZXh0VmFsdWUgPSBwcm9wcy50ZXh0VmFsdWUgfHwgKHR5cGVvZiBjaGlsZHJlbiA9PT0gXCJzdHJpbmdcIiA/IGNoaWxkcmVuIDogXCJcIikgfHwgcHJvcHNbXCJhcmlhLWxhYmVsXCJdIHx8IFwiXCI7XG4gICAgeWllbGQge1xuICAgICAgICB0eXBlOiBcImNlbGxcIixcbiAgICAgICAgcHJvcHM6IHByb3BzLFxuICAgICAgICByZW5kZXJlZDogY2hpbGRyZW4sXG4gICAgICAgIHRleHRWYWx1ZTogdGV4dFZhbHVlLFxuICAgICAgICBcImFyaWEtbGFiZWxcIjogcHJvcHNbXCJhcmlhLWxhYmVsXCJdLFxuICAgICAgICBoYXNDaGlsZE5vZGVzOiBmYWxzZVxuICAgIH07XG59O1xuLyoqXG4gKiBBIENlbGwgcmVwcmVzZW50cyB0aGUgdmFsdWUgb2YgYSBzaW5nbGUgQ29sdW1uIHdpdGhpbiBhIFRhYmxlIFJvdy5cbiAqLyAvLyBXZSBkb24ndCB3YW50IGdldENvbGxlY3Rpb25Ob2RlIHRvIHNob3cgdXAgaW4gdGhlIHR5cGUgZGVmaW5pdGlvblxubGV0ICQ5NDFkMWQ5YTZhMjg5ODJhJGV4cG9ydCRmNmYwYzNmZTRlYzMwNmVhID0gJDk0MWQxZDlhNmEyODk4MmEkdmFyJENlbGw7XG5cblxuXG5cblxuLypcbiAqIENvcHlyaWdodCAyMDIzIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIFxuXG5cblxuXG5cbmZ1bmN0aW9uICRlZTY1YTAwNTdmZDk5NTMxJGV4cG9ydCQzNGRmYThhMTYyMjE4NWE0KHByb3BzKSB7XG4gICAgbGV0IHsgc2VsZWN0aW9uTW9kZTogc2VsZWN0aW9uTW9kZSA9IFwibm9uZVwiLCBzaG93U2VsZWN0aW9uQ2hlY2tib3hlczogc2hvd1NlbGVjdGlvbkNoZWNrYm94ZXMsIHNob3dEcmFnQnV0dG9uczogc2hvd0RyYWdCdXR0b25zLCBVTlNUQUJMRV9leHBhbmRlZEtleXM6IHByb3BFeHBhbmRlZEtleXMsIFVOU1RBQkxFX2RlZmF1bHRFeHBhbmRlZEtleXM6IHByb3BEZWZhdWx0RXhwYW5kZWRLZXlzLCBVTlNUQUJMRV9vbkV4cGFuZGVkQ2hhbmdlOiBVTlNUQUJMRV9vbkV4cGFuZGVkQ2hhbmdlLCBjaGlsZHJlbjogY2hpbGRyZW4gfSA9IHByb3BzO1xuICAgIGlmICghKDAsICQxQmZqVyR0YWJsZU5lc3RlZFJvd3MpKCkpIHRocm93IG5ldyBFcnJvcihcIkZlYXR1cmUgZmxhZyBmb3IgdGFibGUgbmVzdGVkIHJvd3MgbXVzdCBiZSBlbmFibGVkIHRvIHVzZSB1c2VUcmVlR3JpZFN0YXRlLlwiKTtcbiAgICBsZXQgW2V4cGFuZGVkS2V5cywgc2V0RXhwYW5kZWRLZXlzXSA9ICgwLCAkMUJmalckdXNlQ29udHJvbGxlZFN0YXRlKShwcm9wRXhwYW5kZWRLZXlzID8gJGVlNjVhMDA1N2ZkOTk1MzEkdmFyJGNvbnZlcnRFeHBhbmRlZChwcm9wRXhwYW5kZWRLZXlzKSA6IHVuZGVmaW5lZCwgcHJvcERlZmF1bHRFeHBhbmRlZEtleXMgPyAkZWU2NWEwMDU3ZmQ5OTUzMSR2YXIkY29udmVydEV4cGFuZGVkKHByb3BEZWZhdWx0RXhwYW5kZWRLZXlzKSA6IG5ldyBTZXQoKSwgVU5TVEFCTEVfb25FeHBhbmRlZENoYW5nZSk7XG4gICAgbGV0IGNvbnRleHQgPSAoMCwgJDFCZmpXJHVzZU1lbW8pKCgpPT4oe1xuICAgICAgICAgICAgc2hvd1NlbGVjdGlvbkNoZWNrYm94ZXM6IHNob3dTZWxlY3Rpb25DaGVja2JveGVzICYmIHNlbGVjdGlvbk1vZGUgIT09IFwibm9uZVwiLFxuICAgICAgICAgICAgc2hvd0RyYWdCdXR0b25zOiBzaG93RHJhZ0J1dHRvbnMsXG4gICAgICAgICAgICBzZWxlY3Rpb25Nb2RlOiBzZWxlY3Rpb25Nb2RlLFxuICAgICAgICAgICAgY29sdW1uczogW11cbiAgICAgICAgfSksIFtcbiAgICAgICAgY2hpbGRyZW4sXG4gICAgICAgIHNob3dTZWxlY3Rpb25DaGVja2JveGVzLFxuICAgICAgICBzZWxlY3Rpb25Nb2RlLFxuICAgICAgICBzaG93RHJhZ0J1dHRvbnNcbiAgICBdKTtcbiAgICBsZXQgYnVpbGRlciA9ICgwLCAkMUJmalckdXNlTWVtbykoKCk9Pm5ldyAoMCwgJDFCZmpXJENvbGxlY3Rpb25CdWlsZGVyKSgpLCBbXSk7XG4gICAgbGV0IG5vZGVzID0gKDAsICQxQmZqVyR1c2VNZW1vKSgoKT0+YnVpbGRlci5idWlsZCh7XG4gICAgICAgICAgICBjaGlsZHJlbjogY2hpbGRyZW5cbiAgICAgICAgfSwgY29udGV4dCksIFtcbiAgICAgICAgYnVpbGRlcixcbiAgICAgICAgY2hpbGRyZW4sXG4gICAgICAgIGNvbnRleHRcbiAgICBdKTtcbiAgICBsZXQgdHJlZUdyaWRDb2xsZWN0aW9uID0gKDAsICQxQmZqVyR1c2VNZW1vKSgoKT0+e1xuICAgICAgICByZXR1cm4gJGVlNjVhMDA1N2ZkOTk1MzEkdmFyJGdlbmVyYXRlVHJlZUdyaWRDb2xsZWN0aW9uKG5vZGVzLCB7XG4gICAgICAgICAgICBzaG93U2VsZWN0aW9uQ2hlY2tib3hlczogc2hvd1NlbGVjdGlvbkNoZWNrYm94ZXMsXG4gICAgICAgICAgICBzaG93RHJhZ0J1dHRvbnM6IHNob3dEcmFnQnV0dG9ucyxcbiAgICAgICAgICAgIGV4cGFuZGVkS2V5czogZXhwYW5kZWRLZXlzXG4gICAgICAgIH0pO1xuICAgIH0sIFtcbiAgICAgICAgbm9kZXMsXG4gICAgICAgIHNob3dTZWxlY3Rpb25DaGVja2JveGVzLFxuICAgICAgICBzaG93RHJhZ0J1dHRvbnMsXG4gICAgICAgIGV4cGFuZGVkS2V5c1xuICAgIF0pO1xuICAgIGxldCBvblRvZ2dsZSA9IChrZXkpPT57XG4gICAgICAgIHNldEV4cGFuZGVkS2V5cygkZWU2NWEwMDU3ZmQ5OTUzMSR2YXIkdG9nZ2xlS2V5KGV4cGFuZGVkS2V5cywga2V5LCB0cmVlR3JpZENvbGxlY3Rpb24pKTtcbiAgICB9O1xuICAgIGxldCBjb2xsZWN0aW9uID0gKDAsICQxQmZqVyR1c2VNZW1vKSgoKT0+e1xuICAgICAgICByZXR1cm4gbmV3ICgwLCAkNzg4NzgxYmFhMzAxMTdmYSRleHBvcnQkNTk2ZTFiMmUyY2Y5MzY5MCkodHJlZUdyaWRDb2xsZWN0aW9uLnRhYmxlTm9kZXMsIG51bGwsIGNvbnRleHQpO1xuICAgIH0sIFtcbiAgICAgICAgY29udGV4dCxcbiAgICAgICAgdHJlZUdyaWRDb2xsZWN0aW9uLnRhYmxlTm9kZXNcbiAgICBdKTtcbiAgICBsZXQgdGFibGVTdGF0ZSA9ICgwLCAkNGEwZGQwMzZkNDkyY2VlNCRleHBvcnQkOTA3YmNjNmM0ODMyNWZkNikoe1xuICAgICAgICAuLi5wcm9wcyxcbiAgICAgICAgY29sbGVjdGlvbjogY29sbGVjdGlvblxuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICAgIC4uLnRhYmxlU3RhdGUsXG4gICAgICAgIGtleU1hcDogdHJlZUdyaWRDb2xsZWN0aW9uLmtleU1hcCxcbiAgICAgICAgdXNlckNvbHVtbkNvdW50OiB0cmVlR3JpZENvbGxlY3Rpb24udXNlckNvbHVtbkNvdW50LFxuICAgICAgICBleHBhbmRlZEtleXM6IGV4cGFuZGVkS2V5cyxcbiAgICAgICAgdG9nZ2xlS2V5OiBvblRvZ2dsZVxuICAgIH07XG59XG5mdW5jdGlvbiAkZWU2NWEwMDU3ZmQ5OTUzMSR2YXIkdG9nZ2xlS2V5KGN1cnJlbnRFeHBhbmRlZEtleXMsIGtleSwgY29sbGVjdGlvbikge1xuICAgIGxldCB1cGRhdGVkRXhwYW5kZWRLZXlzO1xuICAgIGlmIChjdXJyZW50RXhwYW5kZWRLZXlzID09PSBcImFsbFwiKSB7XG4gICAgICAgIHVwZGF0ZWRFeHBhbmRlZEtleXMgPSBuZXcgU2V0KGNvbGxlY3Rpb24uZmxhdHRlbmVkUm93cy5maWx0ZXIoKHJvdyk9PnJvdy5wcm9wcy5VTlNUQUJMRV9jaGlsZEl0ZW1zIHx8IHJvdy5wcm9wcy5jaGlsZHJlbi5sZW5ndGggPiBjb2xsZWN0aW9uLnVzZXJDb2x1bW5Db3VudCkubWFwKChyb3cpPT5yb3cua2V5KSk7XG4gICAgICAgIHVwZGF0ZWRFeHBhbmRlZEtleXMuZGVsZXRlKGtleSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdXBkYXRlZEV4cGFuZGVkS2V5cyA9IG5ldyBTZXQoY3VycmVudEV4cGFuZGVkS2V5cyk7XG4gICAgICAgIGlmICh1cGRhdGVkRXhwYW5kZWRLZXlzLmhhcyhrZXkpKSB1cGRhdGVkRXhwYW5kZWRLZXlzLmRlbGV0ZShrZXkpO1xuICAgICAgICBlbHNlIHVwZGF0ZWRFeHBhbmRlZEtleXMuYWRkKGtleSk7XG4gICAgfVxuICAgIHJldHVybiB1cGRhdGVkRXhwYW5kZWRLZXlzO1xufVxuZnVuY3Rpb24gJGVlNjVhMDA1N2ZkOTk1MzEkdmFyJGNvbnZlcnRFeHBhbmRlZChleHBhbmRlZCkge1xuICAgIGlmICghZXhwYW5kZWQpIHJldHVybiBuZXcgU2V0KCk7XG4gICAgcmV0dXJuIGV4cGFuZGVkID09PSBcImFsbFwiID8gXCJhbGxcIiA6IG5ldyBTZXQoZXhwYW5kZWQpO1xufVxuZnVuY3Rpb24gJGVlNjVhMDA1N2ZkOTk1MzEkdmFyJGdlbmVyYXRlVHJlZUdyaWRDb2xsZWN0aW9uKG5vZGVzLCBvcHRzKSB7XG4gICAgbGV0IHsgZXhwYW5kZWRLZXlzOiBleHBhbmRlZEtleXMgPSBuZXcgU2V0KCkgfSA9IG9wdHM7XG4gICAgbGV0IGJvZHk7XG4gICAgbGV0IGZsYXR0ZW5lZFJvd3MgPSBbXTtcbiAgICBsZXQgY29sdW1uQ291bnQgPSAwO1xuICAgIGxldCB1c2VyQ29sdW1uQ291bnQgPSAwO1xuICAgIGxldCBvcmlnaW5hbENvbHVtbnMgPSBbXTtcbiAgICBsZXQga2V5TWFwID0gbmV3IE1hcCgpO1xuICAgIGlmIChvcHRzID09PSBudWxsIHx8IG9wdHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdHMuc2hvd1NlbGVjdGlvbkNoZWNrYm94ZXMpIGNvbHVtbkNvdW50Kys7XG4gICAgaWYgKG9wdHMgPT09IG51bGwgfHwgb3B0cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0cy5zaG93RHJhZ0J1dHRvbnMpIGNvbHVtbkNvdW50Kys7XG4gICAgbGV0IHRvcExldmVsUm93cyA9IFtdO1xuICAgIGxldCB2aXNpdCA9IChub2RlKT0+e1xuICAgICAgICBzd2l0Y2gobm9kZS50eXBlKXtcbiAgICAgICAgICAgIGNhc2UgXCJib2R5XCI6XG4gICAgICAgICAgICAgICAgYm9keSA9IG5vZGU7XG4gICAgICAgICAgICAgICAga2V5TWFwLnNldChib2R5LmtleSwgYm9keSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiY29sdW1uXCI6XG4gICAgICAgICAgICAgICAgaWYgKCFub2RlLmhhc0NoaWxkTm9kZXMpIHVzZXJDb2x1bW5Db3VudCsrO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIml0ZW1cIjpcbiAgICAgICAgICAgICAgICB0b3BMZXZlbFJvd3MucHVzaChub2RlKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgY2hpbGQgb2Ygbm9kZS5jaGlsZE5vZGVzKXZpc2l0KGNoaWxkKTtcbiAgICB9O1xuICAgIGZvciAobGV0IG5vZGUgb2Ygbm9kZXMpe1xuICAgICAgICBpZiAobm9kZS50eXBlID09PSBcImNvbHVtblwiKSBvcmlnaW5hbENvbHVtbnMucHVzaChub2RlKTtcbiAgICAgICAgdmlzaXQobm9kZSk7XG4gICAgfVxuICAgIGNvbHVtbkNvdW50ICs9IHVzZXJDb2x1bW5Db3VudDtcbiAgICAvLyBVcGRhdGUgZWFjaCBncmlkIG5vZGUgaW4gdGhlIHRyZWVncmlkIHRhYmxlIHdpdGggdmFsdWVzIHNwZWNpZmljIHRvIGEgdHJlZWdyaWQgc3RydWN0dXJlLiBBbHNvIHN0b3JlIGEgc2V0IG9mIGZsYXR0ZW5lZCByb3cgbm9kZXMgZm9yIFRhYmxlQ29sbGVjdGlvbiB0byBjb25zdW1lXG4gICAgbGV0IGdsb2JhbFJvd0NvdW50ID0gMDtcbiAgICBsZXQgdmlzaXROb2RlID0gKG5vZGUsIGkpPT57XG4gICAgICAgIC8vIENsb25lIHJvdyBub2RlIGFuZCBpdHMgY2hpbGRyZW4gc28gbW9kaWZpY2F0aW9ucyB0byB0aGUgbm9kZSBmb3IgdHJlZWdyaWQgc3BlY2lmaWMgdmFsdWVzIGFyZW4ndCBhcHBsaWVkIG9uIHRoZSBub2RlcyBwcm92aWRlZFxuICAgICAgICAvLyB0byBUYWJsZUNvbGxlY3Rpb24uIEluZGV4LCBsZXZlbCwgYW5kIHBhcmVudCBrZXlzIGFyZSBhbGwgY2hhbmdlZCB0byByZWZsZWN0IGEgZmxhdHRlbmVkIHJvdyBzdHJ1Y3R1cmUgcmF0aGVyIHRoYW4gdGhlIHRyZWVncmlkIHN0cnVjdHVyZVxuICAgICAgICAvLyB2YWx1ZXMgYXV0b21hdGljYWxseSBjYWxjdWxhdGVkIHZpYSBDb2xsZWN0aW9uQnVpbGRlclxuICAgICAgICBpZiAobm9kZS50eXBlID09PSBcIml0ZW1cIikge1xuICAgICAgICAgICAgbGV0IGNoaWxkTm9kZXMgPSBbXTtcbiAgICAgICAgICAgIGZvciAobGV0IGNoaWxkIG9mIG5vZGUuY2hpbGROb2RlcylpZiAoY2hpbGQudHlwZSA9PT0gXCJjZWxsXCIpIHtcbiAgICAgICAgICAgICAgICBsZXQgY2VsbENsb25lID0ge1xuICAgICAgICAgICAgICAgICAgICAuLi5jaGlsZFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgaWYgKGNlbGxDbG9uZS5pbmRleCArIDEgPT09IGNvbHVtbkNvdW50KSBjZWxsQ2xvbmUubmV4dEtleSA9IG51bGw7XG4gICAgICAgICAgICAgICAgY2hpbGROb2Rlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgLi4uY2VsbENsb25lXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgY2xvbmUgPSB7XG4gICAgICAgICAgICAgICAgLi4ubm9kZSxcbiAgICAgICAgICAgICAgICBjaGlsZE5vZGVzOiBjaGlsZE5vZGVzLFxuICAgICAgICAgICAgICAgIHBhcmVudEtleTogYm9keS5rZXksXG4gICAgICAgICAgICAgICAgbGV2ZWw6IDEsXG4gICAgICAgICAgICAgICAgaW5kZXg6IGdsb2JhbFJvd0NvdW50KytcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBmbGF0dGVuZWRSb3dzLnB1c2goY2xvbmUpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBuZXdQcm9wcyA9IHt9O1xuICAgICAgICAvLyBBc3NpZ24gaW5kZXhPZlR5cGUgdG8gY2VsbHMgYW5kIHJvd3MgZm9yIGFyaWEtcG9zaW5zZXRcbiAgICAgICAgaWYgKG5vZGUudHlwZSAhPT0gXCJwbGFjZWhvbGRlclwiICYmIG5vZGUudHlwZSAhPT0gXCJjb2x1bW5cIikgbmV3UHJvcHNbXCJpbmRleE9mVHlwZVwiXSA9IGk7XG4gICAgICAgIC8vIFVzZSBPYmplY3QuYXNzaWduIGluc3RlYWQgb2Ygc3ByZWFkIHRvIHByZXNlcnZlIG9iamVjdCByZWZlcmVuY2UgZm9yIGtleU1hcC4gQWxzbyBlbnN1cmVzIHJldHJpZXZpbmcgbm9kZXNcbiAgICAgICAgLy8gdmlhIC5jaGlsZE5vZGVzIHJldHVybnMgdGhlIHNhbWUgb2JqZWN0IGFzIHRoZSBvbmUgZm91bmQgdmlhIGtleU1hcCBsb29rIHVwXG4gICAgICAgIE9iamVjdC5hc3NpZ24obm9kZSwgbmV3UHJvcHMpO1xuICAgICAgICBrZXlNYXAuc2V0KG5vZGUua2V5LCBub2RlKTtcbiAgICAgICAgbGV0IGxhc3ROb2RlO1xuICAgICAgICBsZXQgcm93SW5kZXggPSAwO1xuICAgICAgICBmb3IgKGxldCBjaGlsZCBvZiBub2RlLmNoaWxkTm9kZXMpaWYgKCEoY2hpbGQudHlwZSA9PT0gXCJpdGVtXCIgJiYgZXhwYW5kZWRLZXlzICE9PSBcImFsbFwiICYmICFleHBhbmRlZEtleXMuaGFzKG5vZGUua2V5KSkpIHtcbiAgICAgICAgICAgIGlmIChjaGlsZC5wYXJlbnRLZXkgPT0gbnVsbCkgLy8gaWYgY2hpbGQgaXMgYSBjZWxsL2V4cGFuZGVkIHJvdy9jb2x1bW4gYW5kIHRoZSBwYXJlbnQga2V5IGlzbid0IGFscmVhZHkgZXN0YWJsaXNoZWQgYnkgdGhlIGNvbGxlY3Rpb24sIG1hdGNoIGNoaWxkIG5vZGUgdG8gcGFyZW50IHJvd1xuICAgICAgICAgICAgY2hpbGQucGFyZW50S2V5ID0gbm9kZS5rZXk7XG4gICAgICAgICAgICBpZiAobGFzdE5vZGUpIHtcbiAgICAgICAgICAgICAgICBsYXN0Tm9kZS5uZXh0S2V5ID0gY2hpbGQua2V5O1xuICAgICAgICAgICAgICAgIGNoaWxkLnByZXZLZXkgPSBsYXN0Tm9kZS5rZXk7XG4gICAgICAgICAgICB9IGVsc2UgY2hpbGQucHJldktleSA9IG51bGw7XG4gICAgICAgICAgICBpZiAoY2hpbGQudHlwZSA9PT0gXCJpdGVtXCIpIHZpc2l0Tm9kZShjaGlsZCwgcm93SW5kZXgrKyk7XG4gICAgICAgICAgICBlbHNlIC8vIFdlIGVuZm9yY2UgdGhhdCB0aGUgY2VsbHMgY29tZSBiZWZvcmUgcm93cyBzbyBjYW4ganVzdCByZXVzZSBjZWxsIGluZGV4XG4gICAgICAgICAgICB2aXNpdE5vZGUoY2hpbGQsIGNoaWxkLmluZGV4KTtcbiAgICAgICAgICAgIGxhc3ROb2RlID0gY2hpbGQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxhc3ROb2RlKSBsYXN0Tm9kZS5uZXh0S2V5ID0gbnVsbDtcbiAgICB9O1xuICAgIGxldCBsYXN0O1xuICAgIHRvcExldmVsUm93cy5mb3JFYWNoKChub2RlLCBpKT0+e1xuICAgICAgICB2aXNpdE5vZGUobm9kZSwgaSk7XG4gICAgICAgIGlmIChsYXN0KSB7XG4gICAgICAgICAgICBsYXN0Lm5leHRLZXkgPSBub2RlLmtleTtcbiAgICAgICAgICAgIG5vZGUucHJldktleSA9IGxhc3Qua2V5O1xuICAgICAgICB9IGVsc2Ugbm9kZS5wcmV2S2V5ID0gbnVsbDtcbiAgICAgICAgbGFzdCA9IG5vZGU7XG4gICAgfSk7XG4gICAgaWYgKGxhc3QpIGxhc3QubmV4dEtleSA9IG51bGw7XG4gICAgcmV0dXJuIHtcbiAgICAgICAga2V5TWFwOiBrZXlNYXAsXG4gICAgICAgIHVzZXJDb2x1bW5Db3VudDogdXNlckNvbHVtbkNvdW50LFxuICAgICAgICBmbGF0dGVuZWRSb3dzOiBmbGF0dGVuZWRSb3dzLFxuICAgICAgICB0YWJsZU5vZGVzOiBbXG4gICAgICAgICAgICAuLi5vcmlnaW5hbENvbHVtbnMsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgLi4uYm9keSxcbiAgICAgICAgICAgICAgICBjaGlsZE5vZGVzOiBmbGF0dGVuZWRSb3dzXG4gICAgICAgICAgICB9XG4gICAgICAgIF1cbiAgICB9O1xufVxuXG5cblxuXG5leHBvcnQgeyQyOTJiYzRlMDljZDBlYjYyJGV4cG9ydCRjYjg5NWRjZjg1ZGIxMzE5IGFzIHVzZVRhYmxlQ29sdW1uUmVzaXplU3RhdGUsICQ0YTBkZDAzNmQ0OTJjZWU0JGV4cG9ydCQ5MDdiY2M2YzQ4MzI1ZmQ2IGFzIHVzZVRhYmxlU3RhdGUsICQzMTJhZTNiNTZhOTRhODZlJGV4cG9ydCRmODUwODk1YjI4N2VmMjhlIGFzIFRhYmxlSGVhZGVyLCAkNGFlNTMxNGJmNTBkYjFhMyRleHBvcnQkNzZjY2QyMTBiOTAyOTkxNyBhcyBUYWJsZUJvZHksICQxY2QyNDQ1NTdjMmY5N2Q1JGV4cG9ydCQ4MTZiNWQ4MTEyOTVlNmJjIGFzIENvbHVtbiwgJDcwZDcwZWIxNmVhNDg0MjgkZXhwb3J0JGI1OWJkYmVmOWNlNzBkZTIgYXMgUm93LCAkOTQxZDFkOWE2YTI4OTgyYSRleHBvcnQkZjZmMGMzZmU0ZWMzMDZlYSBhcyBDZWxsLCAkNjU1NTEwNGZmMDg1YmVmNCRyZV9leHBvcnQkU2VjdGlvbiBhcyBTZWN0aW9uLCAkNzg4NzgxYmFhMzAxMTdmYSRleHBvcnQkNTk2ZTFiMmUyY2Y5MzY5MCBhcyBUYWJsZUNvbGxlY3Rpb24sICQ3ODg3ODFiYWEzMDExN2ZhJGV4cG9ydCQ3YzEyN2RiODUwZDRlODFlIGFzIGJ1aWxkSGVhZGVyUm93cywgJGE5ZTdhZTU0NGE0ZTQxZGQkZXhwb3J0JDdmZjc3YTE2Mjk3MGIzMGUgYXMgVGFibGVDb2x1bW5MYXlvdXQsICRlZTY1YTAwNTdmZDk5NTMxJGV4cG9ydCQzNGRmYThhMTYyMjE4NWE0IGFzIFVOU1RBQkxFX3VzZVRyZWVHcmlkU3RhdGV9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bW9kdWxlLmpzLm1hcFxuIl0sIm5hbWVzIjpbIlNlY3Rpb24iLCIkNjU1NTEwNGZmMDg1YmVmNCRyZV9leHBvcnQkU2VjdGlvbiIsInVzZUNvbGxlY3Rpb24iLCIkMUJmalckdXNlQ29sbGVjdGlvbiIsImdldEZpcnN0SXRlbSIsIiQxQmZqVyRnZXRGaXJzdEl0ZW0iLCJnZXRMYXN0SXRlbSIsIiQxQmZqVyRnZXRMYXN0SXRlbSIsIkNvbGxlY3Rpb25CdWlsZGVyIiwiJDFCZmpXJENvbGxlY3Rpb25CdWlsZGVyIiwiJDFCZmpXJHJlYWN0IiwidXNlU3RhdGUiLCIkMUJmalckdXNlU3RhdGUiLCJ1c2VNZW1vIiwiJDFCZmpXJHVzZU1lbW8iLCJ1c2VDYWxsYmFjayIsIiQxQmZqVyR1c2VDYWxsYmFjayIsInVzZUdyaWRTdGF0ZSIsIiQxQmZqVyR1c2VHcmlkU3RhdGUiLCJHcmlkQ29sbGVjdGlvbiIsIiQxQmZqVyRHcmlkQ29sbGVjdGlvbiIsInRhYmxlTmVzdGVkUm93cyIsIiQxQmZqVyR0YWJsZU5lc3RlZFJvd3MiLCJ1c2VDb250cm9sbGVkU3RhdGUiLCIkMUJmalckdXNlQ29udHJvbGxlZFN0YXRlIiwiJDY4MThiMWM0ZmM2NzAyOGQkZXhwb3J0JDE5OTRhMDc3Yjk4ZWUwZDUiLCJ3aWR0aCIsImlzTmFOIiwiU3RyaW5nIiwibWF0Y2giLCIkNjgxOGIxYzRmYzY3MDI4ZCRleHBvcnQkOTA3OGJhZDRjMzkzNDYwNCIsImNvbnNvbGUiLCJ3YXJuIiwicGFyc2VGbG9hdCIsIiQ2ODE4YjFjNGZjNjcwMjhkJGV4cG9ydCQ3YmJhZDI3ODk2ZjdhZTlmIiwidGFibGVXaWR0aCIsIkVycm9yIiwiJDY4MThiMWM0ZmM2NzAyOGQkZXhwb3J0JDU5MTg1YzYyYTc1NDRhYTAiLCJtYXhXaWR0aCIsIk51bWJlciIsIk1BWF9TQUZFX0lOVEVHRVIiLCIkNjgxOGIxYzRmYzY3MDI4ZCRleHBvcnQkZjU1NjA1NGNlNDM1ODcwMSIsIm1pbldpZHRoIiwiJDY4MThiMWM0ZmM2NzAyOGQkZXhwb3J0JDU1ZDUwZGM2ODczODU0OTEiLCJhdmFpbGFibGVXaWR0aCIsImNvbHVtbnMiLCJjaGFuZ2VkQ29sdW1ucyIsImdldERlZmF1bHRXaWR0aCIsImdldERlZmF1bHRNaW5XaWR0aCIsImhhc05vbkZyb3plbkl0ZW1zIiwiZmxleEl0ZW1zIiwibWFwIiwiY29sdW1uIiwiaW5kZXgiLCJfY29sdW1uX3dpZHRoIiwiX3JlZiIsIl9yZWYxIiwiZ2V0Iiwia2V5IiwiZGVmYXVsdFdpZHRoIiwiZnJvemVuIiwiYmFzZVNpemUiLCJmbGV4IiwidGFyZ2V0TWFpblNpemUiLCJfY29sdW1uX21pbldpZHRoIiwiX3JlZjIiLCJtaW4iLCJtYXgiLCJoeXBvdGhldGljYWxNYWluU2l6ZSIsIk1hdGgiLCJ2aW9sYXRpb24iLCJ1c2VkV2lkdGgiLCJmbGV4RmFjdG9ycyIsImZvckVhY2giLCJpdGVtIiwicmVtYWluaW5nRnJlZVNwYWNlIiwicmF0aW8iLCJ0b3RhbFZpb2xhdGlvbiIsInNpZ24iLCIkNjgxOGIxYzRmYzY3MDI4ZCR2YXIkY2FzY2FkZVJvdW5kaW5nIiwiZnBUb3RhbCIsImludFRvdGFsIiwicm91bmRlZEFycmF5IiwiZmxvYXQiLCJpbnRlZ2VyIiwicm91bmQiLCJwdXNoIiwiJGE5ZTdhZTU0NGE0ZTQxZGQkZXhwb3J0JDdmZjc3YTE2Mjk3MGIzMGUiLCJzcGxpdENvbHVtbnNJbnRvQ29udHJvbGxlZEFuZFVuY29udHJvbGxlZCIsInJlZHVjZSIsImFjYyIsImNvbCIsInByb3BzIiwic2V0IiwiTWFwIiwicmVjb21iaW5lQ29sdW1ucyIsInVuY29udHJvbGxlZFdpZHRocyIsInVuY29udHJvbGxlZENvbHVtbnMiLCJjb250cm9sbGVkQ29sdW1ucyIsImhhcyIsImdldEluaXRpYWxVbmNvbnRyb2xsZWRXaWR0aHMiLCJBcnJheSIsImZyb20iLCJfdGhpc19nZXREZWZhdWx0V2lkdGgiLCJfdGhpcyIsIl9jb2xfcHJvcHNfZGVmYXVsdFdpZHRoIiwiY2FsbCIsImdldENvbHVtbldpZHRoIiwiX3RoaXNfY29sdW1uV2lkdGhzX2dldCIsImNvbHVtbldpZHRocyIsImdldENvbHVtbk1pbldpZHRoIiwiX3RoaXNfY29sdW1uTWluV2lkdGhzX2dldCIsImNvbHVtbk1pbldpZHRocyIsImdldENvbHVtbk1heFdpZHRoIiwiX3RoaXNfY29sdW1uTWF4V2lkdGhzX2dldCIsImNvbHVtbk1heFdpZHRocyIsInJlc2l6ZUNvbHVtbldpZHRoIiwiY29sbGVjdGlvbiIsImNvbnRyb2xsZWRXaWR0aHMiLCJwcmV2Q29sdW1uV2lkdGhzIiwicmVzaXplSW5kZXgiLCJJbmZpbml0eSIsInJlc2l6aW5nQ2hhbmdlZCIsInBlcmNlbnRLZXlzIiwiZnJLZXlzVG9UaGVSaWdodCIsIm1pbldpZHRocyIsImkiLCJfY29sdW1uX3Byb3BzX3dpZHRoX2VuZHNXaXRoIiwiX2NvbHVtbl9wcm9wc193aWR0aCIsImZyS2V5IiwiZnJWYWx1ZSIsImVuZHNXaXRoIiwiZmxvb3IiLCJuZXdXaWR0aHMiLCJidWlsZENvbHVtbldpZHRocyIsIndpZHRocyIsIl9jb2x1bW5fcHJvcHNfbWluV2lkdGgiLCJjb25zdHJ1Y3RvciIsIm9wdGlvbnMiLCJfb3B0aW9uc19nZXREZWZhdWx0V2lkdGgiLCJfb3B0aW9uc19nZXREZWZhdWx0TWluV2lkdGgiLCIkMjkyYmM0ZTA5Y2QwZWI2MiRleHBvcnQkY2I4OTVkY2Y4NWRiMTMxOSIsInN0YXRlIiwicmVzaXppbmdDb2x1bW4iLCJzZXRSZXNpemluZ0NvbHVtbiIsImNvbHVtbkxheW91dCIsInNldFVuY29udHJvbGxlZFdpZHRocyIsImxhc3RDb2x1bW5zIiwic2V0TGFzdENvbHVtbnMiLCJsZW5ndGgiLCJzb21lIiwiYyIsIm5ld1VuY29udHJvbGxlZFdpZHRocyIsImNvbFdpZHRocyIsInN0YXJ0UmVzaXplIiwidXBkYXRlUmVzaXplZENvbHVtbnMiLCJuZXdDb250cm9sbGVkIiwiZW50cnkiLCJuZXdTaXplcyIsImVuZFJlc2l6ZSIsInRhYmxlU3RhdGUiLCIkNzg4NzgxYmFhMzAxMTdmYSR2YXIkUk9XX0hFQURFUl9DT0xVTU5fS0VZIiwicmFuZG9tIiwidG9TdHJpbmciLCJzbGljZSIsIiQ3ODg3ODFiYWEzMDExN2ZhJHZhciRST1dfSEVBREVSX0NPTFVNTl9LRVlfRFJBRyIsIiQ3ODg3ODFiYWEzMDExN2ZhJGV4cG9ydCQ3YzEyN2RiODUwZDRlODFlIiwia2V5TWFwIiwiY29sdW1uTm9kZXMiLCJzZWVuIiwicGFyZW50S2V5IiwicGFyZW50IiwiY29sc3BhbiIsInNwbGljZSIsIm1heExlbmd0aCIsImhlYWRlclJvd3MiLCJmaWxsIiwiY29sSW5kZXgiLCJyb3ciLCJyb3dMZW5ndGgiLCJwIiwicGxhY2Vob2xkZXIiLCJ0eXBlIiwidmFsdWUiLCJyZW5kZXJlZCIsImxldmVsIiwiaGFzQ2hpbGROb2RlcyIsImNoaWxkTm9kZXMiLCJ0ZXh0VmFsdWUiLCJuZXh0S2V5IiwicHJldktleSIsIiQ3ODg3ODFiYWEzMDExN2ZhJGV4cG9ydCQ1OTZlMWIyZTJjZjkzNjkwIiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJib2R5Iiwic2l6ZSIsIl9zaXplIiwiZ2V0S2V5cyIsImtleXMiLCJnZXRLZXlCZWZvcmUiLCJub2RlIiwiZ2V0S2V5QWZ0ZXIiLCJnZXRGaXJzdEtleSIsIl9nZXRGaXJzdEl0ZW0iLCJnZXRMYXN0S2V5IiwiX2dldExhc3RJdGVtIiwiZ2V0SXRlbSIsImF0IiwiaWR4IiwiZ2V0VGV4dFZhbHVlIiwicm93SGVhZGVyQ29sdW1uS2V5cyIsInRleHQiLCJjZWxsIiwiam9pbiIsIm5vZGVzIiwicHJldiIsIm9wdHMiLCJTZXQiLCJzaG93U2VsZWN0aW9uQ2hlY2tib3hlcyIsInJvd0hlYWRlckNvbHVtbiIsInNob3dEcmFnQnV0dG9ucyIsImlzU2VsZWN0aW9uQ2VsbCIsInVuc2hpZnQiLCJpc0RyYWdCdXR0b25DZWxsIiwicm93cyIsImNvbHVtbktleU1hcCIsInZpc2l0IiwiaXNSb3dIZWFkZXIiLCJhZGQiLCJjaGlsZCIsImNvbHVtbkNvdW50IiwiaXRlbXMiLCJ2aXNpdE5vZGUiLCIkNGEwZGQwMzZkNDkyY2VlNCR2YXIkT1BQT1NJVEVfU09SVF9ESVJFQ1RJT04iLCJhc2NlbmRpbmciLCJkZXNjZW5kaW5nIiwiJDRhMGRkMDM2ZDQ5MmNlZTQkZXhwb3J0JDkwN2JjYzZjNDgzMjVmZDYiLCJpc0tleWJvYXJkTmF2aWdhdGlvbkRpc2FibGVkIiwic2V0S2V5Ym9hcmROYXZpZ2F0aW9uRGlzYWJsZWQiLCJzZWxlY3Rpb25Nb2RlIiwiY29udGV4dCIsImNoaWxkcmVuIiwiZGlzYWJsZWRLZXlzIiwic2VsZWN0aW9uTWFuYWdlciIsImRpc2FibGVkQmVoYXZpb3IiLCJzb3J0RGVzY3JpcHRvciIsInNvcnQiLCJjb2x1bW5LZXkiLCJkaXJlY3Rpb24iLCJfcHJvcHNfc29ydERlc2NyaXB0b3IiLCJvblNvcnRDaGFuZ2UiLCIkMzEyYWUzYjU2YTk0YTg2ZSR2YXIkVGFibGVIZWFkZXIiLCJnZXRDb2xsZWN0aW9uTm9kZSIsInJlbmRlcmVyIiwiQ2hpbGRyZW4iLCJlbGVtZW50IiwiJDMxMmFlM2I1NmE5NGE4NmUkZXhwb3J0JGY4NTA4OTViMjg3ZWYyOGUiLCIkNGFlNTMxNGJmNTBkYjFhMyR2YXIkVGFibGVCb2R5IiwiJDRhZTUzMTRiZjUwZGIxYTMkZXhwb3J0JDc2Y2NkMjEwYjkwMjk5MTciLCIkMWNkMjQ0NTU3YzJmOTdkNSR2YXIkQ29sdW1uIiwidGl0bGUiLCJjaGlsZENvbHVtbnMiLCJmdWxsTm9kZXMiLCJjb3VudCIsInNob3VsZEludmFsaWRhdGUiLCJuZXdDb250ZXh0IiwidXBkYXRlQ29udGV4dCIsIiQxY2QyNDQ1NTdjMmY5N2Q1JGV4cG9ydCQ4MTZiNWQ4MTEyOTVlNmJjIiwiJDcwZDcwZWIxNmVhNDg0MjgkdmFyJFJvdyIsIlVOU1RBQkxFX2NoaWxkSXRlbXMiLCJjZWxscyIsImNoaWxkUm93cyIsIiQ3MGQ3MGViMTZlYTQ4NDI4JGV4cG9ydCRiNTliZGJlZjljZTcwZGUyIiwiJDk0MWQxZDlhNmEyODk4MmEkdmFyJENlbGwiLCIkOTQxZDFkOWE2YTI4OTgyYSRleHBvcnQkZjZmMGMzZmU0ZWMzMDZlYSIsIiRlZTY1YTAwNTdmZDk5NTMxJGV4cG9ydCQzNGRmYThhMTYyMjE4NWE0IiwiVU5TVEFCTEVfZXhwYW5kZWRLZXlzIiwicHJvcEV4cGFuZGVkS2V5cyIsIlVOU1RBQkxFX2RlZmF1bHRFeHBhbmRlZEtleXMiLCJwcm9wRGVmYXVsdEV4cGFuZGVkS2V5cyIsIlVOU1RBQkxFX29uRXhwYW5kZWRDaGFuZ2UiLCJleHBhbmRlZEtleXMiLCJzZXRFeHBhbmRlZEtleXMiLCIkZWU2NWEwMDU3ZmQ5OTUzMSR2YXIkY29udmVydEV4cGFuZGVkIiwidW5kZWZpbmVkIiwiYnVpbGRlciIsImJ1aWxkIiwidHJlZUdyaWRDb2xsZWN0aW9uIiwiJGVlNjVhMDA1N2ZkOTk1MzEkdmFyJGdlbmVyYXRlVHJlZUdyaWRDb2xsZWN0aW9uIiwib25Ub2dnbGUiLCIkZWU2NWEwMDU3ZmQ5OTUzMSR2YXIkdG9nZ2xlS2V5IiwidGFibGVOb2RlcyIsInVzZXJDb2x1bW5Db3VudCIsInRvZ2dsZUtleSIsImN1cnJlbnRFeHBhbmRlZEtleXMiLCJ1cGRhdGVkRXhwYW5kZWRLZXlzIiwiZmxhdHRlbmVkUm93cyIsImZpbHRlciIsImRlbGV0ZSIsImV4cGFuZGVkIiwib3JpZ2luYWxDb2x1bW5zIiwidG9wTGV2ZWxSb3dzIiwiZ2xvYmFsUm93Q291bnQiLCJjZWxsQ2xvbmUiLCJjbG9uZSIsIm5ld1Byb3BzIiwiT2JqZWN0IiwiYXNzaWduIiwibGFzdE5vZGUiLCJyb3dJbmRleCIsImxhc3QiLCJ1c2VUYWJsZUNvbHVtblJlc2l6ZVN0YXRlIiwidXNlVGFibGVTdGF0ZSIsIlRhYmxlSGVhZGVyIiwiVGFibGVCb2R5IiwiQ29sdW1uIiwiUm93IiwiQ2VsbCIsIlRhYmxlQ29sbGVjdGlvbiIsImJ1aWxkSGVhZGVyUm93cyIsIlRhYmxlQ29sdW1uTGF5b3V0IiwiVU5TVEFCTEVfdXNlVHJlZUdyaWRTdGF0ZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-stately/table/dist/import.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-stately/tabs/dist/import.mjs":
/*!**********************************************************!*\
  !*** ./node_modules/@react-stately/tabs/dist/import.mjs ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useTabListState: () => (/* binding */ $76f919a04c5a7d14$export$4ba071daf4e486)\n/* harmony export */ });\n/* harmony import */ var _react_stately_list__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @react-stately/list */ \"(ssr)/./node_modules/@react-stately/list/dist/import.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ function $76f919a04c5a7d14$export$4ba071daf4e486(props) {\n    var _props_defaultSelectedKey;\n    let state = (0, _react_stately_list__WEBPACK_IMPORTED_MODULE_1__.useSingleSelectListState)({\n        ...props,\n        suppressTextValueWarning: true,\n        defaultSelectedKey: (_props_defaultSelectedKey = props.defaultSelectedKey) !== null && _props_defaultSelectedKey !== void 0 ? _props_defaultSelectedKey : $76f919a04c5a7d14$var$findDefaultSelectedKey(props.collection, props.disabledKeys ? new Set(props.disabledKeys) : new Set())\n    });\n    let { selectionManager: selectionManager, collection: collection, selectedKey: currentSelectedKey } = state;\n    let lastSelectedKey = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)(currentSelectedKey);\n    (0, react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        // Ensure a tab is always selected (in case no selected key was specified or if selected item was deleted from collection)\n        let selectedKey = currentSelectedKey;\n        if (selectionManager.isEmpty || !collection.getItem(selectedKey)) {\n            selectedKey = $76f919a04c5a7d14$var$findDefaultSelectedKey(collection, state.disabledKeys);\n            if (selectedKey != null) selectionManager.setSelectedKeys([\n                selectedKey\n            ]);\n        }\n        // If the tablist doesn't have focus and the selected key changes or if there isn't a focused key yet, change focused key to the selected key if it exists.\n        if (selectedKey != null && selectionManager.focusedKey == null || !selectionManager.isFocused && selectedKey !== lastSelectedKey.current) selectionManager.setFocusedKey(selectedKey);\n        lastSelectedKey.current = selectedKey;\n    });\n    return {\n        ...state,\n        isDisabled: props.isDisabled || false\n    };\n}\nfunction $76f919a04c5a7d14$var$findDefaultSelectedKey(collection, disabledKeys) {\n    let selectedKey = null;\n    if (collection) {\n        selectedKey = collection.getFirstKey();\n        // loop over tabs until we find one that isn't disabled and select that\n        while(disabledKeys.has(selectedKey) && selectedKey !== collection.getLastKey())selectedKey = collection.getKeyAfter(selectedKey);\n        // if this check is true, then every item is disabled, it makes more sense to default to the first key than the last\n        if (disabledKeys.has(selectedKey) && selectedKey === collection.getLastKey()) selectedKey = collection.getFirstKey();\n    }\n    return selectedKey;\n}\n //# sourceMappingURL=module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXN0YXRlbHkvdGFicy9kaXN0L2ltcG9ydC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQWdHO0FBQ25CO0FBRTdFOzs7Ozs7Ozs7O0NBVUMsR0FBRzs7Ozs7Ozs7OztDQVVILEdBRUQsU0FBU00sd0NBQXdDQyxLQUFLO0lBQ2xELElBQUlDO0lBQ0osSUFBSUMsUUFBUSxDQUFDLEdBQUdSLHlFQUE4QixFQUFHO1FBQzdDLEdBQUdNLEtBQUs7UUFDUkcsMEJBQTBCO1FBQzFCQyxvQkFBb0IsQ0FBQ0gsNEJBQTRCRCxNQUFNSSxrQkFBa0IsTUFBTSxRQUFRSCw4QkFBOEIsS0FBSyxJQUFJQSw0QkFBNEJJLDZDQUE2Q0wsTUFBTU0sVUFBVSxFQUFFTixNQUFNTyxZQUFZLEdBQUcsSUFBSUMsSUFBSVIsTUFBTU8sWUFBWSxJQUFJLElBQUlDO0lBQ3BSO0lBQ0EsSUFBSSxFQUFFQyxrQkFBa0JBLGdCQUFnQixFQUFFSCxZQUFZQSxVQUFVLEVBQUVJLGFBQWFDLGtCQUFrQixFQUFFLEdBQUdUO0lBQ3RHLElBQUlVLGtCQUFrQixDQUFDLEdBQUdoQix5Q0FBWSxFQUFHZTtJQUN4QyxJQUFHYiw0Q0FBZSxFQUFHO1FBQ2xCLDBIQUEwSDtRQUMxSCxJQUFJWSxjQUFjQztRQUNsQixJQUFJRixpQkFBaUJJLE9BQU8sSUFBSSxDQUFDUCxXQUFXUSxPQUFPLENBQUNKLGNBQWM7WUFDOURBLGNBQWNMLDZDQUE2Q0MsWUFBWUosTUFBTUssWUFBWTtZQUN6RixJQUFJRyxlQUFlLE1BQ25CRCxpQkFBaUJNLGVBQWUsQ0FBQztnQkFDN0JMO2FBQ0g7UUFDTDtRQUNBLDJKQUEySjtRQUMzSixJQUFJQSxlQUFlLFFBQVFELGlCQUFpQk8sVUFBVSxJQUFJLFFBQVEsQ0FBQ1AsaUJBQWlCUSxTQUFTLElBQUlQLGdCQUFnQkUsZ0JBQWdCTSxPQUFPLEVBQUVULGlCQUFpQlUsYUFBYSxDQUFDVDtRQUN6S0UsZ0JBQWdCTSxPQUFPLEdBQUdSO0lBQzlCO0lBQ0EsT0FBTztRQUNILEdBQUdSLEtBQUs7UUFDUmtCLFlBQVlwQixNQUFNb0IsVUFBVSxJQUFJO0lBQ3BDO0FBQ0o7QUFDQSxTQUFTZiw2Q0FBNkNDLFVBQVUsRUFBRUMsWUFBWTtJQUMxRSxJQUFJRyxjQUFjO0lBQ2xCLElBQUlKLFlBQVk7UUFDWkksY0FBY0osV0FBV2UsV0FBVztRQUNwQyx1RUFBdUU7UUFDdkUsTUFBTWQsYUFBYWUsR0FBRyxDQUFDWixnQkFBZ0JBLGdCQUFnQkosV0FBV2lCLFVBQVUsR0FBR2IsY0FBY0osV0FBV2tCLFdBQVcsQ0FBQ2Q7UUFDcEgsb0hBQW9IO1FBQ3BILElBQUlILGFBQWFlLEdBQUcsQ0FBQ1osZ0JBQWdCQSxnQkFBZ0JKLFdBQVdpQixVQUFVLElBQUliLGNBQWNKLFdBQVdlLFdBQVc7SUFDdEg7SUFDQSxPQUFPWDtBQUNYO0FBS29FLENBQ3BFLGtDQUFrQyIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtZmxhc2svLi9ub2RlX21vZHVsZXMvQHJlYWN0LXN0YXRlbHkvdGFicy9kaXN0L2ltcG9ydC5tanM/OWM4ZCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge3VzZVNpbmdsZVNlbGVjdExpc3RTdGF0ZSBhcyAkaWpIS1okdXNlU2luZ2xlU2VsZWN0TGlzdFN0YXRlfSBmcm9tIFwiQHJlYWN0LXN0YXRlbHkvbGlzdFwiO1xuaW1wb3J0IHt1c2VSZWYgYXMgJGlqSEtaJHVzZVJlZiwgdXNlRWZmZWN0IGFzICRpakhLWiR1c2VFZmZlY3R9IGZyb20gXCJyZWFjdFwiO1xuXG4vKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIFxuXG5mdW5jdGlvbiAkNzZmOTE5YTA0YzVhN2QxNCRleHBvcnQkNGJhMDcxZGFmNGU0ODYocHJvcHMpIHtcbiAgICB2YXIgX3Byb3BzX2RlZmF1bHRTZWxlY3RlZEtleTtcbiAgICBsZXQgc3RhdGUgPSAoMCwgJGlqSEtaJHVzZVNpbmdsZVNlbGVjdExpc3RTdGF0ZSkoe1xuICAgICAgICAuLi5wcm9wcyxcbiAgICAgICAgc3VwcHJlc3NUZXh0VmFsdWVXYXJuaW5nOiB0cnVlLFxuICAgICAgICBkZWZhdWx0U2VsZWN0ZWRLZXk6IChfcHJvcHNfZGVmYXVsdFNlbGVjdGVkS2V5ID0gcHJvcHMuZGVmYXVsdFNlbGVjdGVkS2V5KSAhPT0gbnVsbCAmJiBfcHJvcHNfZGVmYXVsdFNlbGVjdGVkS2V5ICE9PSB2b2lkIDAgPyBfcHJvcHNfZGVmYXVsdFNlbGVjdGVkS2V5IDogJDc2ZjkxOWEwNGM1YTdkMTQkdmFyJGZpbmREZWZhdWx0U2VsZWN0ZWRLZXkocHJvcHMuY29sbGVjdGlvbiwgcHJvcHMuZGlzYWJsZWRLZXlzID8gbmV3IFNldChwcm9wcy5kaXNhYmxlZEtleXMpIDogbmV3IFNldCgpKVxuICAgIH0pO1xuICAgIGxldCB7IHNlbGVjdGlvbk1hbmFnZXI6IHNlbGVjdGlvbk1hbmFnZXIsIGNvbGxlY3Rpb246IGNvbGxlY3Rpb24sIHNlbGVjdGVkS2V5OiBjdXJyZW50U2VsZWN0ZWRLZXkgfSA9IHN0YXRlO1xuICAgIGxldCBsYXN0U2VsZWN0ZWRLZXkgPSAoMCwgJGlqSEtaJHVzZVJlZikoY3VycmVudFNlbGVjdGVkS2V5KTtcbiAgICAoMCwgJGlqSEtaJHVzZUVmZmVjdCkoKCk9PntcbiAgICAgICAgLy8gRW5zdXJlIGEgdGFiIGlzIGFsd2F5cyBzZWxlY3RlZCAoaW4gY2FzZSBubyBzZWxlY3RlZCBrZXkgd2FzIHNwZWNpZmllZCBvciBpZiBzZWxlY3RlZCBpdGVtIHdhcyBkZWxldGVkIGZyb20gY29sbGVjdGlvbilcbiAgICAgICAgbGV0IHNlbGVjdGVkS2V5ID0gY3VycmVudFNlbGVjdGVkS2V5O1xuICAgICAgICBpZiAoc2VsZWN0aW9uTWFuYWdlci5pc0VtcHR5IHx8ICFjb2xsZWN0aW9uLmdldEl0ZW0oc2VsZWN0ZWRLZXkpKSB7XG4gICAgICAgICAgICBzZWxlY3RlZEtleSA9ICQ3NmY5MTlhMDRjNWE3ZDE0JHZhciRmaW5kRGVmYXVsdFNlbGVjdGVkS2V5KGNvbGxlY3Rpb24sIHN0YXRlLmRpc2FibGVkS2V5cyk7XG4gICAgICAgICAgICBpZiAoc2VsZWN0ZWRLZXkgIT0gbnVsbCkgLy8gZGlyZWN0bHkgc2V0IHNlbGVjdGlvbiBiZWNhdXNlIHJlcGxhY2UvdG9nZ2xlIHNlbGVjdGlvbiB3b24ndCBjb25zaWRlciBkaXNhYmxlZCBrZXlzXG4gICAgICAgICAgICBzZWxlY3Rpb25NYW5hZ2VyLnNldFNlbGVjdGVkS2V5cyhbXG4gICAgICAgICAgICAgICAgc2VsZWN0ZWRLZXlcbiAgICAgICAgICAgIF0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHRoZSB0YWJsaXN0IGRvZXNuJ3QgaGF2ZSBmb2N1cyBhbmQgdGhlIHNlbGVjdGVkIGtleSBjaGFuZ2VzIG9yIGlmIHRoZXJlIGlzbid0IGEgZm9jdXNlZCBrZXkgeWV0LCBjaGFuZ2UgZm9jdXNlZCBrZXkgdG8gdGhlIHNlbGVjdGVkIGtleSBpZiBpdCBleGlzdHMuXG4gICAgICAgIGlmIChzZWxlY3RlZEtleSAhPSBudWxsICYmIHNlbGVjdGlvbk1hbmFnZXIuZm9jdXNlZEtleSA9PSBudWxsIHx8ICFzZWxlY3Rpb25NYW5hZ2VyLmlzRm9jdXNlZCAmJiBzZWxlY3RlZEtleSAhPT0gbGFzdFNlbGVjdGVkS2V5LmN1cnJlbnQpIHNlbGVjdGlvbk1hbmFnZXIuc2V0Rm9jdXNlZEtleShzZWxlY3RlZEtleSk7XG4gICAgICAgIGxhc3RTZWxlY3RlZEtleS5jdXJyZW50ID0gc2VsZWN0ZWRLZXk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgIGlzRGlzYWJsZWQ6IHByb3BzLmlzRGlzYWJsZWQgfHwgZmFsc2VcbiAgICB9O1xufVxuZnVuY3Rpb24gJDc2ZjkxOWEwNGM1YTdkMTQkdmFyJGZpbmREZWZhdWx0U2VsZWN0ZWRLZXkoY29sbGVjdGlvbiwgZGlzYWJsZWRLZXlzKSB7XG4gICAgbGV0IHNlbGVjdGVkS2V5ID0gbnVsbDtcbiAgICBpZiAoY29sbGVjdGlvbikge1xuICAgICAgICBzZWxlY3RlZEtleSA9IGNvbGxlY3Rpb24uZ2V0Rmlyc3RLZXkoKTtcbiAgICAgICAgLy8gbG9vcCBvdmVyIHRhYnMgdW50aWwgd2UgZmluZCBvbmUgdGhhdCBpc24ndCBkaXNhYmxlZCBhbmQgc2VsZWN0IHRoYXRcbiAgICAgICAgd2hpbGUoZGlzYWJsZWRLZXlzLmhhcyhzZWxlY3RlZEtleSkgJiYgc2VsZWN0ZWRLZXkgIT09IGNvbGxlY3Rpb24uZ2V0TGFzdEtleSgpKXNlbGVjdGVkS2V5ID0gY29sbGVjdGlvbi5nZXRLZXlBZnRlcihzZWxlY3RlZEtleSk7XG4gICAgICAgIC8vIGlmIHRoaXMgY2hlY2sgaXMgdHJ1ZSwgdGhlbiBldmVyeSBpdGVtIGlzIGRpc2FibGVkLCBpdCBtYWtlcyBtb3JlIHNlbnNlIHRvIGRlZmF1bHQgdG8gdGhlIGZpcnN0IGtleSB0aGFuIHRoZSBsYXN0XG4gICAgICAgIGlmIChkaXNhYmxlZEtleXMuaGFzKHNlbGVjdGVkS2V5KSAmJiBzZWxlY3RlZEtleSA9PT0gY29sbGVjdGlvbi5nZXRMYXN0S2V5KCkpIHNlbGVjdGVkS2V5ID0gY29sbGVjdGlvbi5nZXRGaXJzdEtleSgpO1xuICAgIH1cbiAgICByZXR1cm4gc2VsZWN0ZWRLZXk7XG59XG5cblxuXG5cbmV4cG9ydCB7JDc2ZjkxOWEwNGM1YTdkMTQkZXhwb3J0JDRiYTA3MWRhZjRlNDg2IGFzIHVzZVRhYkxpc3RTdGF0ZX07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tb2R1bGUuanMubWFwXG4iXSwibmFtZXMiOlsidXNlU2luZ2xlU2VsZWN0TGlzdFN0YXRlIiwiJGlqSEtaJHVzZVNpbmdsZVNlbGVjdExpc3RTdGF0ZSIsInVzZVJlZiIsIiRpakhLWiR1c2VSZWYiLCJ1c2VFZmZlY3QiLCIkaWpIS1okdXNlRWZmZWN0IiwiJDc2ZjkxOWEwNGM1YTdkMTQkZXhwb3J0JDRiYTA3MWRhZjRlNDg2IiwicHJvcHMiLCJfcHJvcHNfZGVmYXVsdFNlbGVjdGVkS2V5Iiwic3RhdGUiLCJzdXBwcmVzc1RleHRWYWx1ZVdhcm5pbmciLCJkZWZhdWx0U2VsZWN0ZWRLZXkiLCIkNzZmOTE5YTA0YzVhN2QxNCR2YXIkZmluZERlZmF1bHRTZWxlY3RlZEtleSIsImNvbGxlY3Rpb24iLCJkaXNhYmxlZEtleXMiLCJTZXQiLCJzZWxlY3Rpb25NYW5hZ2VyIiwic2VsZWN0ZWRLZXkiLCJjdXJyZW50U2VsZWN0ZWRLZXkiLCJsYXN0U2VsZWN0ZWRLZXkiLCJpc0VtcHR5IiwiZ2V0SXRlbSIsInNldFNlbGVjdGVkS2V5cyIsImZvY3VzZWRLZXkiLCJpc0ZvY3VzZWQiLCJjdXJyZW50Iiwic2V0Rm9jdXNlZEtleSIsImlzRGlzYWJsZWQiLCJnZXRGaXJzdEtleSIsImhhcyIsImdldExhc3RLZXkiLCJnZXRLZXlBZnRlciIsInVzZVRhYkxpc3RTdGF0ZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-stately/tabs/dist/import.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-stately/toggle/dist/import.mjs":
/*!************************************************************!*\
  !*** ./node_modules/@react-stately/toggle/dist/import.mjs ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useToggleState: () => (/* binding */ $3017fa7ffdddec74$export$8042c6c013fd5226)\n/* harmony export */ });\n/* harmony import */ var _react_stately_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @react-stately/utils */ \"(ssr)/./node_modules/@react-stately/utils/dist/import.mjs\");\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ function $3017fa7ffdddec74$export$8042c6c013fd5226(props = {}) {\n    let { isReadOnly: isReadOnly } = props;\n    // have to provide an empty function so useControlledState doesn't throw a fit\n    // can't use useControlledState's prop calling because we need the event object from the change\n    let [isSelected, setSelected] = (0, _react_stately_utils__WEBPACK_IMPORTED_MODULE_0__.useControlledState)(props.isSelected, props.defaultSelected || false, props.onChange);\n    function updateSelected(value) {\n        if (!isReadOnly) setSelected(value);\n    }\n    function toggleState() {\n        if (!isReadOnly) setSelected(!isSelected);\n    }\n    return {\n        isSelected: isSelected,\n        setSelected: updateSelected,\n        toggle: toggleState\n    };\n}\n //# sourceMappingURL=module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXN0YXRlbHkvdG9nZ2xlL2Rpc3QvaW1wb3J0Lm1qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFxRjtBQUVyRjs7Ozs7Ozs7OztDQVVDLEdBQUc7Ozs7Ozs7Ozs7Q0FVSCxHQUNELFNBQVNFLDBDQUEwQ0MsUUFBUSxDQUFDLENBQUM7SUFDekQsSUFBSSxFQUFFQyxZQUFZQSxVQUFVLEVBQUUsR0FBR0Q7SUFDakMsOEVBQThFO0lBQzlFLCtGQUErRjtJQUMvRixJQUFJLENBQUNFLFlBQVlDLFlBQVksR0FBRyxDQUFDLEdBQUdMLG9FQUF3QixFQUFHRSxNQUFNRSxVQUFVLEVBQUVGLE1BQU1JLGVBQWUsSUFBSSxPQUFPSixNQUFNSyxRQUFRO0lBQy9ILFNBQVNDLGVBQWVDLEtBQUs7UUFDekIsSUFBSSxDQUFDTixZQUFZRSxZQUFZSTtJQUNqQztJQUNBLFNBQVNDO1FBQ0wsSUFBSSxDQUFDUCxZQUFZRSxZQUFZLENBQUNEO0lBQ2xDO0lBQ0EsT0FBTztRQUNIQSxZQUFZQTtRQUNaQyxhQUFhRztRQUNiRyxRQUFRRDtJQUNaO0FBQ0o7QUFLcUUsQ0FDckUsa0NBQWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1mbGFzay8uL25vZGVfbW9kdWxlcy9AcmVhY3Qtc3RhdGVseS90b2dnbGUvZGlzdC9pbXBvcnQubWpzP2Y4NTciXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHt1c2VDb250cm9sbGVkU3RhdGUgYXMgJGJPa2FlJHVzZUNvbnRyb2xsZWRTdGF0ZX0gZnJvbSBcIkByZWFjdC1zdGF0ZWx5L3V0aWxzXCI7XG5cbi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyAvKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gXG5mdW5jdGlvbiAkMzAxN2ZhN2ZmZGRkZWM3NCRleHBvcnQkODA0MmM2YzAxM2ZkNTIyNihwcm9wcyA9IHt9KSB7XG4gICAgbGV0IHsgaXNSZWFkT25seTogaXNSZWFkT25seSB9ID0gcHJvcHM7XG4gICAgLy8gaGF2ZSB0byBwcm92aWRlIGFuIGVtcHR5IGZ1bmN0aW9uIHNvIHVzZUNvbnRyb2xsZWRTdGF0ZSBkb2Vzbid0IHRocm93IGEgZml0XG4gICAgLy8gY2FuJ3QgdXNlIHVzZUNvbnRyb2xsZWRTdGF0ZSdzIHByb3AgY2FsbGluZyBiZWNhdXNlIHdlIG5lZWQgdGhlIGV2ZW50IG9iamVjdCBmcm9tIHRoZSBjaGFuZ2VcbiAgICBsZXQgW2lzU2VsZWN0ZWQsIHNldFNlbGVjdGVkXSA9ICgwLCAkYk9rYWUkdXNlQ29udHJvbGxlZFN0YXRlKShwcm9wcy5pc1NlbGVjdGVkLCBwcm9wcy5kZWZhdWx0U2VsZWN0ZWQgfHwgZmFsc2UsIHByb3BzLm9uQ2hhbmdlKTtcbiAgICBmdW5jdGlvbiB1cGRhdGVTZWxlY3RlZCh2YWx1ZSkge1xuICAgICAgICBpZiAoIWlzUmVhZE9ubHkpIHNldFNlbGVjdGVkKHZhbHVlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdG9nZ2xlU3RhdGUoKSB7XG4gICAgICAgIGlmICghaXNSZWFkT25seSkgc2V0U2VsZWN0ZWQoIWlzU2VsZWN0ZWQpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBpc1NlbGVjdGVkOiBpc1NlbGVjdGVkLFxuICAgICAgICBzZXRTZWxlY3RlZDogdXBkYXRlU2VsZWN0ZWQsXG4gICAgICAgIHRvZ2dsZTogdG9nZ2xlU3RhdGVcbiAgICB9O1xufVxuXG5cblxuXG5leHBvcnQgeyQzMDE3ZmE3ZmZkZGRlYzc0JGV4cG9ydCQ4MDQyYzZjMDEzZmQ1MjI2IGFzIHVzZVRvZ2dsZVN0YXRlfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1vZHVsZS5qcy5tYXBcbiJdLCJuYW1lcyI6WyJ1c2VDb250cm9sbGVkU3RhdGUiLCIkYk9rYWUkdXNlQ29udHJvbGxlZFN0YXRlIiwiJDMwMTdmYTdmZmRkZGVjNzQkZXhwb3J0JDgwNDJjNmMwMTNmZDUyMjYiLCJwcm9wcyIsImlzUmVhZE9ubHkiLCJpc1NlbGVjdGVkIiwic2V0U2VsZWN0ZWQiLCJkZWZhdWx0U2VsZWN0ZWQiLCJvbkNoYW5nZSIsInVwZGF0ZVNlbGVjdGVkIiwidmFsdWUiLCJ0b2dnbGVTdGF0ZSIsInRvZ2dsZSIsInVzZVRvZ2dsZVN0YXRlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-stately/toggle/dist/import.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-stately/tooltip/dist/import.mjs":
/*!*************************************************************!*\
  !*** ./node_modules/@react-stately/tooltip/dist/import.mjs ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useTooltipTriggerState: () => (/* binding */ $8796f90736e175cb$export$4d40659c25ecb50b)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _react_stately_overlays__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @react-stately/overlays */ \"(ssr)/./node_modules/@react-stately/overlays/dist/import.mjs\");\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ const $8796f90736e175cb$var$TOOLTIP_DELAY = 1500; // this seems to be a 1.5 second delay, check with design\nconst $8796f90736e175cb$var$TOOLTIP_COOLDOWN = 500;\nlet $8796f90736e175cb$var$tooltips = {};\nlet $8796f90736e175cb$var$tooltipId = 0;\nlet $8796f90736e175cb$var$globalWarmedUp = false;\nlet $8796f90736e175cb$var$globalWarmUpTimeout = null;\nlet $8796f90736e175cb$var$globalCooldownTimeout = null;\nfunction $8796f90736e175cb$export$4d40659c25ecb50b(props = {}) {\n    let { delay: delay = $8796f90736e175cb$var$TOOLTIP_DELAY, closeDelay: closeDelay = $8796f90736e175cb$var$TOOLTIP_COOLDOWN } = props;\n    let { isOpen: isOpen, open: open, close: close } = (0, _react_stately_overlays__WEBPACK_IMPORTED_MODULE_1__.useOverlayTriggerState)(props);\n    let id = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>`${++$8796f90736e175cb$var$tooltipId}`, []);\n    let closeTimeout = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)();\n    let ensureTooltipEntry = ()=>{\n        $8796f90736e175cb$var$tooltips[id] = hideTooltip;\n    };\n    let closeOpenTooltips = ()=>{\n        for(let hideTooltipId in $8796f90736e175cb$var$tooltips)if (hideTooltipId !== id) {\n            $8796f90736e175cb$var$tooltips[hideTooltipId](true);\n            delete $8796f90736e175cb$var$tooltips[hideTooltipId];\n        }\n    };\n    let showTooltip = ()=>{\n        clearTimeout(closeTimeout.current);\n        closeTimeout.current = null;\n        closeOpenTooltips();\n        ensureTooltipEntry();\n        $8796f90736e175cb$var$globalWarmedUp = true;\n        open();\n        if ($8796f90736e175cb$var$globalWarmUpTimeout) {\n            clearTimeout($8796f90736e175cb$var$globalWarmUpTimeout);\n            $8796f90736e175cb$var$globalWarmUpTimeout = null;\n        }\n        if ($8796f90736e175cb$var$globalCooldownTimeout) {\n            clearTimeout($8796f90736e175cb$var$globalCooldownTimeout);\n            $8796f90736e175cb$var$globalCooldownTimeout = null;\n        }\n    };\n    let hideTooltip = (immediate)=>{\n        if (immediate || closeDelay <= 0) {\n            clearTimeout(closeTimeout.current);\n            closeTimeout.current = null;\n            close();\n        } else if (!closeTimeout.current) closeTimeout.current = setTimeout(()=>{\n            closeTimeout.current = null;\n            close();\n        }, closeDelay);\n        if ($8796f90736e175cb$var$globalWarmUpTimeout) {\n            clearTimeout($8796f90736e175cb$var$globalWarmUpTimeout);\n            $8796f90736e175cb$var$globalWarmUpTimeout = null;\n        }\n        if ($8796f90736e175cb$var$globalWarmedUp) {\n            if ($8796f90736e175cb$var$globalCooldownTimeout) clearTimeout($8796f90736e175cb$var$globalCooldownTimeout);\n            $8796f90736e175cb$var$globalCooldownTimeout = setTimeout(()=>{\n                delete $8796f90736e175cb$var$tooltips[id];\n                $8796f90736e175cb$var$globalCooldownTimeout = null;\n                $8796f90736e175cb$var$globalWarmedUp = false;\n            }, Math.max($8796f90736e175cb$var$TOOLTIP_COOLDOWN, closeDelay));\n        }\n    };\n    let warmupTooltip = ()=>{\n        closeOpenTooltips();\n        ensureTooltipEntry();\n        if (!isOpen && !$8796f90736e175cb$var$globalWarmUpTimeout && !$8796f90736e175cb$var$globalWarmedUp) $8796f90736e175cb$var$globalWarmUpTimeout = setTimeout(()=>{\n            $8796f90736e175cb$var$globalWarmUpTimeout = null;\n            $8796f90736e175cb$var$globalWarmedUp = true;\n            showTooltip();\n        }, delay);\n        else if (!isOpen) showTooltip();\n    };\n    // eslint-disable-next-line arrow-body-style\n    (0, react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        return ()=>{\n            clearTimeout(closeTimeout.current);\n            let tooltip = $8796f90736e175cb$var$tooltips[id];\n            if (tooltip) delete $8796f90736e175cb$var$tooltips[id];\n        };\n    }, [\n        id\n    ]);\n    return {\n        isOpen: isOpen,\n        open: (immediate)=>{\n            if (!immediate && delay > 0 && !closeTimeout.current) warmupTooltip();\n            else showTooltip();\n        },\n        close: hideTooltip\n    };\n}\n //# sourceMappingURL=module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXN0YXRlbHkvdG9vbHRpcC9kaXN0L2ltcG9ydC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQXdHO0FBQ1I7QUFFaEc7Ozs7Ozs7Ozs7Q0FVQyxHQUFHOzs7Ozs7Ozs7O0NBVUgsR0FFRCxNQUFNUSxzQ0FBc0MsTUFBTSx5REFBeUQ7QUFDM0csTUFBTUMseUNBQXlDO0FBQy9DLElBQUlDLGlDQUFpQyxDQUFDO0FBQ3RDLElBQUlDLGtDQUFrQztBQUN0QyxJQUFJQyx1Q0FBdUM7QUFDM0MsSUFBSUMsNENBQTRDO0FBQ2hELElBQUlDLDhDQUE4QztBQUNsRCxTQUFTQywwQ0FBMENDLFFBQVEsQ0FBQyxDQUFDO0lBQ3pELElBQUksRUFBRUMsT0FBT0EsUUFBUVQsbUNBQW1DLEVBQUVVLFlBQVlBLGFBQWFULHNDQUFzQyxFQUFFLEdBQUdPO0lBQzlILElBQUksRUFBRUcsUUFBUUEsTUFBTSxFQUFFQyxNQUFNQSxJQUFJLEVBQUVDLE9BQU9BLEtBQUssRUFBRSxHQUFHLENBQUMsR0FBR2QsMkVBQTRCLEVBQUdTO0lBQ3RGLElBQUlNLEtBQUssQ0FBQyxHQUFHckIsMENBQWEsRUFBRyxJQUFJLENBQUMsRUFBRSxFQUFFVSxnQ0FBZ0MsQ0FBQyxFQUFFLEVBQUU7SUFDM0UsSUFBSVksZUFBZSxDQUFDLEdBQUdwQix5Q0FBWTtJQUNuQyxJQUFJcUIscUJBQXFCO1FBQ3JCZCw4QkFBOEIsQ0FBQ1ksR0FBRyxHQUFHRztJQUN6QztJQUNBLElBQUlDLG9CQUFvQjtRQUNwQixJQUFJLElBQUlDLGlCQUFpQmpCLCtCQUErQixJQUFJaUIsa0JBQWtCTCxJQUFJO1lBQzlFWiw4QkFBOEIsQ0FBQ2lCLGNBQWMsQ0FBQztZQUM5QyxPQUFPakIsOEJBQThCLENBQUNpQixjQUFjO1FBQ3hEO0lBQ0o7SUFDQSxJQUFJQyxjQUFjO1FBQ2RDLGFBQWFOLGFBQWFPLE9BQU87UUFDakNQLGFBQWFPLE9BQU8sR0FBRztRQUN2Qko7UUFDQUY7UUFDQVosdUNBQXVDO1FBQ3ZDUTtRQUNBLElBQUlQLDJDQUEyQztZQUMzQ2dCLGFBQWFoQjtZQUNiQSw0Q0FBNEM7UUFDaEQ7UUFDQSxJQUFJQyw2Q0FBNkM7WUFDN0NlLGFBQWFmO1lBQ2JBLDhDQUE4QztRQUNsRDtJQUNKO0lBQ0EsSUFBSVcsY0FBYyxDQUFDTTtRQUNmLElBQUlBLGFBQWFiLGNBQWMsR0FBRztZQUM5QlcsYUFBYU4sYUFBYU8sT0FBTztZQUNqQ1AsYUFBYU8sT0FBTyxHQUFHO1lBQ3ZCVDtRQUNKLE9BQU8sSUFBSSxDQUFDRSxhQUFhTyxPQUFPLEVBQUVQLGFBQWFPLE9BQU8sR0FBR0UsV0FBVztZQUNoRVQsYUFBYU8sT0FBTyxHQUFHO1lBQ3ZCVDtRQUNKLEdBQUdIO1FBQ0gsSUFBSUwsMkNBQTJDO1lBQzNDZ0IsYUFBYWhCO1lBQ2JBLDRDQUE0QztRQUNoRDtRQUNBLElBQUlELHNDQUFzQztZQUN0QyxJQUFJRSw2Q0FBNkNlLGFBQWFmO1lBQzlEQSw4Q0FBOENrQixXQUFXO2dCQUNyRCxPQUFPdEIsOEJBQThCLENBQUNZLEdBQUc7Z0JBQ3pDUiw4Q0FBOEM7Z0JBQzlDRix1Q0FBdUM7WUFDM0MsR0FBR3FCLEtBQUtDLEdBQUcsQ0FBQ3pCLHdDQUF3Q1M7UUFDeEQ7SUFDSjtJQUNBLElBQUlpQixnQkFBZ0I7UUFDaEJUO1FBQ0FGO1FBQ0EsSUFBSSxDQUFDTCxVQUFVLENBQUNOLDZDQUE2QyxDQUFDRCxzQ0FBc0NDLDRDQUE0Q21CLFdBQVc7WUFDdkpuQiw0Q0FBNEM7WUFDNUNELHVDQUF1QztZQUN2Q2dCO1FBQ0osR0FBR1g7YUFDRSxJQUFJLENBQUNFLFFBQVFTO0lBQ3RCO0lBQ0EsNENBQTRDO0lBQzNDLElBQUd2Qiw0Q0FBZSxFQUFHO1FBQ2xCLE9BQU87WUFDSHdCLGFBQWFOLGFBQWFPLE9BQU87WUFDakMsSUFBSU0sVUFBVTFCLDhCQUE4QixDQUFDWSxHQUFHO1lBQ2hELElBQUljLFNBQVMsT0FBTzFCLDhCQUE4QixDQUFDWSxHQUFHO1FBQzFEO0lBQ0osR0FBRztRQUNDQTtLQUNIO0lBQ0QsT0FBTztRQUNISCxRQUFRQTtRQUNSQyxNQUFNLENBQUNXO1lBQ0gsSUFBSSxDQUFDQSxhQUFhZCxRQUFRLEtBQUssQ0FBQ00sYUFBYU8sT0FBTyxFQUFFSztpQkFDakRQO1FBQ1Q7UUFDQVAsT0FBT0k7SUFDWDtBQUNKO0FBSzZFLENBQzdFLGtDQUFrQyIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtZmxhc2svLi9ub2RlX21vZHVsZXMvQHJlYWN0LXN0YXRlbHkvdG9vbHRpcC9kaXN0L2ltcG9ydC5tanM/MTU4YSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge3VzZU1lbW8gYXMgJDFPaERxJHVzZU1lbW8sIHVzZVJlZiBhcyAkMU9oRHEkdXNlUmVmLCB1c2VFZmZlY3QgYXMgJDFPaERxJHVzZUVmZmVjdH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQge3VzZU92ZXJsYXlUcmlnZ2VyU3RhdGUgYXMgJDFPaERxJHVzZU92ZXJsYXlUcmlnZ2VyU3RhdGV9IGZyb20gXCJAcmVhY3Qtc3RhdGVseS9vdmVybGF5c1wiO1xuXG4vKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIFxuXG5jb25zdCAkODc5NmY5MDczNmUxNzVjYiR2YXIkVE9PTFRJUF9ERUxBWSA9IDE1MDA7IC8vIHRoaXMgc2VlbXMgdG8gYmUgYSAxLjUgc2Vjb25kIGRlbGF5LCBjaGVjayB3aXRoIGRlc2lnblxuY29uc3QgJDg3OTZmOTA3MzZlMTc1Y2IkdmFyJFRPT0xUSVBfQ09PTERPV04gPSA1MDA7XG5sZXQgJDg3OTZmOTA3MzZlMTc1Y2IkdmFyJHRvb2x0aXBzID0ge307XG5sZXQgJDg3OTZmOTA3MzZlMTc1Y2IkdmFyJHRvb2x0aXBJZCA9IDA7XG5sZXQgJDg3OTZmOTA3MzZlMTc1Y2IkdmFyJGdsb2JhbFdhcm1lZFVwID0gZmFsc2U7XG5sZXQgJDg3OTZmOTA3MzZlMTc1Y2IkdmFyJGdsb2JhbFdhcm1VcFRpbWVvdXQgPSBudWxsO1xubGV0ICQ4Nzk2ZjkwNzM2ZTE3NWNiJHZhciRnbG9iYWxDb29sZG93blRpbWVvdXQgPSBudWxsO1xuZnVuY3Rpb24gJDg3OTZmOTA3MzZlMTc1Y2IkZXhwb3J0JDRkNDA2NTljMjVlY2I1MGIocHJvcHMgPSB7fSkge1xuICAgIGxldCB7IGRlbGF5OiBkZWxheSA9ICQ4Nzk2ZjkwNzM2ZTE3NWNiJHZhciRUT09MVElQX0RFTEFZLCBjbG9zZURlbGF5OiBjbG9zZURlbGF5ID0gJDg3OTZmOTA3MzZlMTc1Y2IkdmFyJFRPT0xUSVBfQ09PTERPV04gfSA9IHByb3BzO1xuICAgIGxldCB7IGlzT3BlbjogaXNPcGVuLCBvcGVuOiBvcGVuLCBjbG9zZTogY2xvc2UgfSA9ICgwLCAkMU9oRHEkdXNlT3ZlcmxheVRyaWdnZXJTdGF0ZSkocHJvcHMpO1xuICAgIGxldCBpZCA9ICgwLCAkMU9oRHEkdXNlTWVtbykoKCk9PmAkeysrJDg3OTZmOTA3MzZlMTc1Y2IkdmFyJHRvb2x0aXBJZH1gLCBbXSk7XG4gICAgbGV0IGNsb3NlVGltZW91dCA9ICgwLCAkMU9oRHEkdXNlUmVmKSgpO1xuICAgIGxldCBlbnN1cmVUb29sdGlwRW50cnkgPSAoKT0+e1xuICAgICAgICAkODc5NmY5MDczNmUxNzVjYiR2YXIkdG9vbHRpcHNbaWRdID0gaGlkZVRvb2x0aXA7XG4gICAgfTtcbiAgICBsZXQgY2xvc2VPcGVuVG9vbHRpcHMgPSAoKT0+e1xuICAgICAgICBmb3IobGV0IGhpZGVUb29sdGlwSWQgaW4gJDg3OTZmOTA3MzZlMTc1Y2IkdmFyJHRvb2x0aXBzKWlmIChoaWRlVG9vbHRpcElkICE9PSBpZCkge1xuICAgICAgICAgICAgJDg3OTZmOTA3MzZlMTc1Y2IkdmFyJHRvb2x0aXBzW2hpZGVUb29sdGlwSWRdKHRydWUpO1xuICAgICAgICAgICAgZGVsZXRlICQ4Nzk2ZjkwNzM2ZTE3NWNiJHZhciR0b29sdGlwc1toaWRlVG9vbHRpcElkXTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgbGV0IHNob3dUb29sdGlwID0gKCk9PntcbiAgICAgICAgY2xlYXJUaW1lb3V0KGNsb3NlVGltZW91dC5jdXJyZW50KTtcbiAgICAgICAgY2xvc2VUaW1lb3V0LmN1cnJlbnQgPSBudWxsO1xuICAgICAgICBjbG9zZU9wZW5Ub29sdGlwcygpO1xuICAgICAgICBlbnN1cmVUb29sdGlwRW50cnkoKTtcbiAgICAgICAgJDg3OTZmOTA3MzZlMTc1Y2IkdmFyJGdsb2JhbFdhcm1lZFVwID0gdHJ1ZTtcbiAgICAgICAgb3BlbigpO1xuICAgICAgICBpZiAoJDg3OTZmOTA3MzZlMTc1Y2IkdmFyJGdsb2JhbFdhcm1VcFRpbWVvdXQpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCgkODc5NmY5MDczNmUxNzVjYiR2YXIkZ2xvYmFsV2FybVVwVGltZW91dCk7XG4gICAgICAgICAgICAkODc5NmY5MDczNmUxNzVjYiR2YXIkZ2xvYmFsV2FybVVwVGltZW91dCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCQ4Nzk2ZjkwNzM2ZTE3NWNiJHZhciRnbG9iYWxDb29sZG93blRpbWVvdXQpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCgkODc5NmY5MDczNmUxNzVjYiR2YXIkZ2xvYmFsQ29vbGRvd25UaW1lb3V0KTtcbiAgICAgICAgICAgICQ4Nzk2ZjkwNzM2ZTE3NWNiJHZhciRnbG9iYWxDb29sZG93blRpbWVvdXQgPSBudWxsO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBsZXQgaGlkZVRvb2x0aXAgPSAoaW1tZWRpYXRlKT0+e1xuICAgICAgICBpZiAoaW1tZWRpYXRlIHx8IGNsb3NlRGVsYXkgPD0gMCkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KGNsb3NlVGltZW91dC5jdXJyZW50KTtcbiAgICAgICAgICAgIGNsb3NlVGltZW91dC5jdXJyZW50ID0gbnVsbDtcbiAgICAgICAgICAgIGNsb3NlKCk7XG4gICAgICAgIH0gZWxzZSBpZiAoIWNsb3NlVGltZW91dC5jdXJyZW50KSBjbG9zZVRpbWVvdXQuY3VycmVudCA9IHNldFRpbWVvdXQoKCk9PntcbiAgICAgICAgICAgIGNsb3NlVGltZW91dC5jdXJyZW50ID0gbnVsbDtcbiAgICAgICAgICAgIGNsb3NlKCk7XG4gICAgICAgIH0sIGNsb3NlRGVsYXkpO1xuICAgICAgICBpZiAoJDg3OTZmOTA3MzZlMTc1Y2IkdmFyJGdsb2JhbFdhcm1VcFRpbWVvdXQpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCgkODc5NmY5MDczNmUxNzVjYiR2YXIkZ2xvYmFsV2FybVVwVGltZW91dCk7XG4gICAgICAgICAgICAkODc5NmY5MDczNmUxNzVjYiR2YXIkZ2xvYmFsV2FybVVwVGltZW91dCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCQ4Nzk2ZjkwNzM2ZTE3NWNiJHZhciRnbG9iYWxXYXJtZWRVcCkge1xuICAgICAgICAgICAgaWYgKCQ4Nzk2ZjkwNzM2ZTE3NWNiJHZhciRnbG9iYWxDb29sZG93blRpbWVvdXQpIGNsZWFyVGltZW91dCgkODc5NmY5MDczNmUxNzVjYiR2YXIkZ2xvYmFsQ29vbGRvd25UaW1lb3V0KTtcbiAgICAgICAgICAgICQ4Nzk2ZjkwNzM2ZTE3NWNiJHZhciRnbG9iYWxDb29sZG93blRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpPT57XG4gICAgICAgICAgICAgICAgZGVsZXRlICQ4Nzk2ZjkwNzM2ZTE3NWNiJHZhciR0b29sdGlwc1tpZF07XG4gICAgICAgICAgICAgICAgJDg3OTZmOTA3MzZlMTc1Y2IkdmFyJGdsb2JhbENvb2xkb3duVGltZW91dCA9IG51bGw7XG4gICAgICAgICAgICAgICAgJDg3OTZmOTA3MzZlMTc1Y2IkdmFyJGdsb2JhbFdhcm1lZFVwID0gZmFsc2U7XG4gICAgICAgICAgICB9LCBNYXRoLm1heCgkODc5NmY5MDczNmUxNzVjYiR2YXIkVE9PTFRJUF9DT09MRE9XTiwgY2xvc2VEZWxheSkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBsZXQgd2FybXVwVG9vbHRpcCA9ICgpPT57XG4gICAgICAgIGNsb3NlT3BlblRvb2x0aXBzKCk7XG4gICAgICAgIGVuc3VyZVRvb2x0aXBFbnRyeSgpO1xuICAgICAgICBpZiAoIWlzT3BlbiAmJiAhJDg3OTZmOTA3MzZlMTc1Y2IkdmFyJGdsb2JhbFdhcm1VcFRpbWVvdXQgJiYgISQ4Nzk2ZjkwNzM2ZTE3NWNiJHZhciRnbG9iYWxXYXJtZWRVcCkgJDg3OTZmOTA3MzZlMTc1Y2IkdmFyJGdsb2JhbFdhcm1VcFRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpPT57XG4gICAgICAgICAgICAkODc5NmY5MDczNmUxNzVjYiR2YXIkZ2xvYmFsV2FybVVwVGltZW91dCA9IG51bGw7XG4gICAgICAgICAgICAkODc5NmY5MDczNmUxNzVjYiR2YXIkZ2xvYmFsV2FybWVkVXAgPSB0cnVlO1xuICAgICAgICAgICAgc2hvd1Rvb2x0aXAoKTtcbiAgICAgICAgfSwgZGVsYXkpO1xuICAgICAgICBlbHNlIGlmICghaXNPcGVuKSBzaG93VG9vbHRpcCgpO1xuICAgIH07XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGFycm93LWJvZHktc3R5bGVcbiAgICAoMCwgJDFPaERxJHVzZUVmZmVjdCkoKCk9PntcbiAgICAgICAgcmV0dXJuICgpPT57XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQoY2xvc2VUaW1lb3V0LmN1cnJlbnQpO1xuICAgICAgICAgICAgbGV0IHRvb2x0aXAgPSAkODc5NmY5MDczNmUxNzVjYiR2YXIkdG9vbHRpcHNbaWRdO1xuICAgICAgICAgICAgaWYgKHRvb2x0aXApIGRlbGV0ZSAkODc5NmY5MDczNmUxNzVjYiR2YXIkdG9vbHRpcHNbaWRdO1xuICAgICAgICB9O1xuICAgIH0sIFtcbiAgICAgICAgaWRcbiAgICBdKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBpc09wZW46IGlzT3BlbixcbiAgICAgICAgb3BlbjogKGltbWVkaWF0ZSk9PntcbiAgICAgICAgICAgIGlmICghaW1tZWRpYXRlICYmIGRlbGF5ID4gMCAmJiAhY2xvc2VUaW1lb3V0LmN1cnJlbnQpIHdhcm11cFRvb2x0aXAoKTtcbiAgICAgICAgICAgIGVsc2Ugc2hvd1Rvb2x0aXAoKTtcbiAgICAgICAgfSxcbiAgICAgICAgY2xvc2U6IGhpZGVUb29sdGlwXG4gICAgfTtcbn1cblxuXG5cblxuZXhwb3J0IHskODc5NmY5MDczNmUxNzVjYiRleHBvcnQkNGQ0MDY1OWMyNWVjYjUwYiBhcyB1c2VUb29sdGlwVHJpZ2dlclN0YXRlfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1vZHVsZS5qcy5tYXBcbiJdLCJuYW1lcyI6WyJ1c2VNZW1vIiwiJDFPaERxJHVzZU1lbW8iLCJ1c2VSZWYiLCIkMU9oRHEkdXNlUmVmIiwidXNlRWZmZWN0IiwiJDFPaERxJHVzZUVmZmVjdCIsInVzZU92ZXJsYXlUcmlnZ2VyU3RhdGUiLCIkMU9oRHEkdXNlT3ZlcmxheVRyaWdnZXJTdGF0ZSIsIiQ4Nzk2ZjkwNzM2ZTE3NWNiJHZhciRUT09MVElQX0RFTEFZIiwiJDg3OTZmOTA3MzZlMTc1Y2IkdmFyJFRPT0xUSVBfQ09PTERPV04iLCIkODc5NmY5MDczNmUxNzVjYiR2YXIkdG9vbHRpcHMiLCIkODc5NmY5MDczNmUxNzVjYiR2YXIkdG9vbHRpcElkIiwiJDg3OTZmOTA3MzZlMTc1Y2IkdmFyJGdsb2JhbFdhcm1lZFVwIiwiJDg3OTZmOTA3MzZlMTc1Y2IkdmFyJGdsb2JhbFdhcm1VcFRpbWVvdXQiLCIkODc5NmY5MDczNmUxNzVjYiR2YXIkZ2xvYmFsQ29vbGRvd25UaW1lb3V0IiwiJDg3OTZmOTA3MzZlMTc1Y2IkZXhwb3J0JDRkNDA2NTljMjVlY2I1MGIiLCJwcm9wcyIsImRlbGF5IiwiY2xvc2VEZWxheSIsImlzT3BlbiIsIm9wZW4iLCJjbG9zZSIsImlkIiwiY2xvc2VUaW1lb3V0IiwiZW5zdXJlVG9vbHRpcEVudHJ5IiwiaGlkZVRvb2x0aXAiLCJjbG9zZU9wZW5Ub29sdGlwcyIsImhpZGVUb29sdGlwSWQiLCJzaG93VG9vbHRpcCIsImNsZWFyVGltZW91dCIsImN1cnJlbnQiLCJpbW1lZGlhdGUiLCJzZXRUaW1lb3V0IiwiTWF0aCIsIm1heCIsIndhcm11cFRvb2x0aXAiLCJ0b29sdGlwIiwidXNlVG9vbHRpcFRyaWdnZXJTdGF0ZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-stately/tooltip/dist/import.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-stately/tree/dist/import.mjs":
/*!**********************************************************!*\
  !*** ./node_modules/@react-stately/tree/dist/import.mjs ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TreeCollection: () => (/* binding */ $05ca4cd7c4a5a999$export$863faf230ee2118a),\n/* harmony export */   useTreeState: () => (/* binding */ $875d6693e12af071$export$728d6ba534403756)\n/* harmony export */ });\n/* harmony import */ var _react_stately_selection__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @react-stately/selection */ \"(ssr)/./node_modules/@react-stately/selection/dist/import.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _react_stately_collections__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @react-stately/collections */ \"(ssr)/./node_modules/@react-stately/collections/dist/import.mjs\");\n/* harmony import */ var _react_stately_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @react-stately/utils */ \"(ssr)/./node_modules/@react-stately/utils/dist/import.mjs\");\n\n\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ class $05ca4cd7c4a5a999$export$863faf230ee2118a {\n    *[Symbol.iterator]() {\n        yield* this.iterable;\n    }\n    get size() {\n        return this.keyMap.size;\n    }\n    getKeys() {\n        return this.keyMap.keys();\n    }\n    getKeyBefore(key) {\n        let node = this.keyMap.get(key);\n        return node ? node.prevKey : null;\n    }\n    getKeyAfter(key) {\n        let node = this.keyMap.get(key);\n        return node ? node.nextKey : null;\n    }\n    getFirstKey() {\n        return this.firstKey;\n    }\n    getLastKey() {\n        return this.lastKey;\n    }\n    getItem(key) {\n        return this.keyMap.get(key);\n    }\n    at(idx) {\n        const keys = [\n            ...this.getKeys()\n        ];\n        return this.getItem(keys[idx]);\n    }\n    constructor(nodes, { expandedKeys: expandedKeys } = {}){\n        this.keyMap = new Map();\n        this.iterable = nodes;\n        expandedKeys = expandedKeys || new Set();\n        let visit = (node)=>{\n            this.keyMap.set(node.key, node);\n            if (node.childNodes && (node.type === \"section\" || expandedKeys.has(node.key))) for (let child of node.childNodes)visit(child);\n        };\n        for (let node of nodes)visit(node);\n        let last;\n        let index = 0;\n        for (let [key, node] of this.keyMap){\n            if (last) {\n                last.nextKey = key;\n                node.prevKey = last.key;\n            } else {\n                this.firstKey = key;\n                node.prevKey = undefined;\n            }\n            if (node.type === \"item\") node.index = index++;\n            last = node;\n            // Set nextKey as undefined since this might be the last node\n            // If it isn't the last node, last.nextKey will properly set at start of new loop\n            last.nextKey = undefined;\n        }\n        this.lastKey = last === null || last === void 0 ? void 0 : last.key;\n    }\n}\nfunction $875d6693e12af071$export$728d6ba534403756(props) {\n    let [expandedKeys, setExpandedKeys] = (0, _react_stately_utils__WEBPACK_IMPORTED_MODULE_1__.useControlledState)(props.expandedKeys ? new Set(props.expandedKeys) : undefined, props.defaultExpandedKeys ? new Set(props.defaultExpandedKeys) : new Set(), props.onExpandedChange);\n    let selectionState = (0, _react_stately_selection__WEBPACK_IMPORTED_MODULE_2__.useMultipleSelectionState)(props);\n    let disabledKeys = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>props.disabledKeys ? new Set(props.disabledKeys) : new Set(), [\n        props.disabledKeys\n    ]);\n    let tree = (0, _react_stately_collections__WEBPACK_IMPORTED_MODULE_3__.useCollection)(props, (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((nodes)=>new (0, $05ca4cd7c4a5a999$export$863faf230ee2118a)(nodes, {\n            expandedKeys: expandedKeys\n        }), [\n        expandedKeys\n    ]), null);\n    // Reset focused key if that item is deleted from the collection.\n    (0, react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (selectionState.focusedKey != null && !tree.getItem(selectionState.focusedKey)) selectionState.setFocusedKey(null);\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [\n        tree,\n        selectionState.focusedKey\n    ]);\n    let onToggle = (key)=>{\n        setExpandedKeys($875d6693e12af071$var$toggleKey(expandedKeys, key));\n    };\n    return {\n        collection: tree,\n        expandedKeys: expandedKeys,\n        disabledKeys: disabledKeys,\n        toggleKey: onToggle,\n        setExpandedKeys: setExpandedKeys,\n        selectionManager: new (0, _react_stately_selection__WEBPACK_IMPORTED_MODULE_2__.SelectionManager)(tree, selectionState)\n    };\n}\nfunction $875d6693e12af071$var$toggleKey(set, key) {\n    let res = new Set(set);\n    if (res.has(key)) res.delete(key);\n    else res.add(key);\n    return res;\n}\n //# sourceMappingURL=module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXN0YXRlbHkvdHJlZS9kaXN0L2ltcG9ydC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQW9KO0FBQ2xDO0FBQ2pDO0FBQ0k7QUFFckY7Ozs7Ozs7Ozs7Q0FVQyxHQUFHOzs7Ozs7Ozs7O0NBVUgsR0FDRDs7Ozs7Ozs7OztDQVVDLEdBQUcsTUFBTWM7SUFDTixDQUFDLENBQUNDLE9BQU9DLFFBQVEsQ0FBQyxHQUFHO1FBQ2pCLE9BQU8sSUFBSSxDQUFDQyxRQUFRO0lBQ3hCO0lBQ0EsSUFBSUMsT0FBTztRQUNQLE9BQU8sSUFBSSxDQUFDQyxNQUFNLENBQUNELElBQUk7SUFDM0I7SUFDQUUsVUFBVTtRQUNOLE9BQU8sSUFBSSxDQUFDRCxNQUFNLENBQUNFLElBQUk7SUFDM0I7SUFDQUMsYUFBYUMsR0FBRyxFQUFFO1FBQ2QsSUFBSUMsT0FBTyxJQUFJLENBQUNMLE1BQU0sQ0FBQ00sR0FBRyxDQUFDRjtRQUMzQixPQUFPQyxPQUFPQSxLQUFLRSxPQUFPLEdBQUc7SUFDakM7SUFDQUMsWUFBWUosR0FBRyxFQUFFO1FBQ2IsSUFBSUMsT0FBTyxJQUFJLENBQUNMLE1BQU0sQ0FBQ00sR0FBRyxDQUFDRjtRQUMzQixPQUFPQyxPQUFPQSxLQUFLSSxPQUFPLEdBQUc7SUFDakM7SUFDQUMsY0FBYztRQUNWLE9BQU8sSUFBSSxDQUFDQyxRQUFRO0lBQ3hCO0lBQ0FDLGFBQWE7UUFDVCxPQUFPLElBQUksQ0FBQ0MsT0FBTztJQUN2QjtJQUNBQyxRQUFRVixHQUFHLEVBQUU7UUFDVCxPQUFPLElBQUksQ0FBQ0osTUFBTSxDQUFDTSxHQUFHLENBQUNGO0lBQzNCO0lBQ0FXLEdBQUdDLEdBQUcsRUFBRTtRQUNKLE1BQU1kLE9BQU87ZUFDTixJQUFJLENBQUNELE9BQU87U0FDbEI7UUFDRCxPQUFPLElBQUksQ0FBQ2EsT0FBTyxDQUFDWixJQUFJLENBQUNjLElBQUk7SUFDakM7SUFDQUMsWUFBWUMsS0FBSyxFQUFFLEVBQUVD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TUFBTSxJQUFJekIsSUFBSUU7SUFDbEIsSUFBSXVCLElBQUlwQixHQUFHLENBQUN0QixNQUFNMEMsSUFBSUMsTUFBTSxDQUFDM0M7U0FDeEIwQyxJQUFJRSxHQUFHLENBQUM1QztJQUNiLE9BQU8wQztBQUNYO0FBTWdJLENBQ2hJLGtDQUFrQyIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtZmxhc2svLi9ub2RlX21vZHVsZXMvQHJlYWN0LXN0YXRlbHkvdHJlZS9kaXN0L2ltcG9ydC5tanM/YjA5ZiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge3VzZU11bHRpcGxlU2VsZWN0aW9uU3RhdGUgYXMgJDFPb1RqJHVzZU11bHRpcGxlU2VsZWN0aW9uU3RhdGUsIFNlbGVjdGlvbk1hbmFnZXIgYXMgJDFPb1RqJFNlbGVjdGlvbk1hbmFnZXJ9IGZyb20gXCJAcmVhY3Qtc3RhdGVseS9zZWxlY3Rpb25cIjtcbmltcG9ydCB7dXNlTWVtbyBhcyAkMU9vVGokdXNlTWVtbywgdXNlQ2FsbGJhY2sgYXMgJDFPb1RqJHVzZUNhbGxiYWNrLCB1c2VFZmZlY3QgYXMgJDFPb1RqJHVzZUVmZmVjdH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQge3VzZUNvbGxlY3Rpb24gYXMgJDFPb1RqJHVzZUNvbGxlY3Rpb259IGZyb20gXCJAcmVhY3Qtc3RhdGVseS9jb2xsZWN0aW9uc1wiO1xuaW1wb3J0IHt1c2VDb250cm9sbGVkU3RhdGUgYXMgJDFPb1RqJHVzZUNvbnRyb2xsZWRTdGF0ZX0gZnJvbSBcIkByZWFjdC1zdGF0ZWx5L3V0aWxzXCI7XG5cbi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyAvKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gXG4vKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gY2xhc3MgJDA1Y2E0Y2Q3YzRhNWE5OTkkZXhwb3J0JDg2M2ZhZjIzMGVlMjExOGEge1xuICAgICpbU3ltYm9sLml0ZXJhdG9yXSgpIHtcbiAgICAgICAgeWllbGQqIHRoaXMuaXRlcmFibGU7XG4gICAgfVxuICAgIGdldCBzaXplKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5rZXlNYXAuc2l6ZTtcbiAgICB9XG4gICAgZ2V0S2V5cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMua2V5TWFwLmtleXMoKTtcbiAgICB9XG4gICAgZ2V0S2V5QmVmb3JlKGtleSkge1xuICAgICAgICBsZXQgbm9kZSA9IHRoaXMua2V5TWFwLmdldChrZXkpO1xuICAgICAgICByZXR1cm4gbm9kZSA/IG5vZGUucHJldktleSA6IG51bGw7XG4gICAgfVxuICAgIGdldEtleUFmdGVyKGtleSkge1xuICAgICAgICBsZXQgbm9kZSA9IHRoaXMua2V5TWFwLmdldChrZXkpO1xuICAgICAgICByZXR1cm4gbm9kZSA/IG5vZGUubmV4dEtleSA6IG51bGw7XG4gICAgfVxuICAgIGdldEZpcnN0S2V5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5maXJzdEtleTtcbiAgICB9XG4gICAgZ2V0TGFzdEtleSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGFzdEtleTtcbiAgICB9XG4gICAgZ2V0SXRlbShrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMua2V5TWFwLmdldChrZXkpO1xuICAgIH1cbiAgICBhdChpZHgpIHtcbiAgICAgICAgY29uc3Qga2V5cyA9IFtcbiAgICAgICAgICAgIC4uLnRoaXMuZ2V0S2V5cygpXG4gICAgICAgIF07XG4gICAgICAgIHJldHVybiB0aGlzLmdldEl0ZW0oa2V5c1tpZHhdKTtcbiAgICB9XG4gICAgY29uc3RydWN0b3Iobm9kZXMsIHsgZXhwYW5kZWRLZXlzOiBleHBhbmRlZEtleXMgfSA9IHt9KXtcbiAgICAgICAgdGhpcy5rZXlNYXAgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuaXRlcmFibGUgPSBub2RlcztcbiAgICAgICAgZXhwYW5kZWRLZXlzID0gZXhwYW5kZWRLZXlzIHx8IG5ldyBTZXQoKTtcbiAgICAgICAgbGV0IHZpc2l0ID0gKG5vZGUpPT57XG4gICAgICAgICAgICB0aGlzLmtleU1hcC5zZXQobm9kZS5rZXksIG5vZGUpO1xuICAgICAgICAgICAgaWYgKG5vZGUuY2hpbGROb2RlcyAmJiAobm9kZS50eXBlID09PSBcInNlY3Rpb25cIiB8fCBleHBhbmRlZEtleXMuaGFzKG5vZGUua2V5KSkpIGZvciAobGV0IGNoaWxkIG9mIG5vZGUuY2hpbGROb2Rlcyl2aXNpdChjaGlsZCk7XG4gICAgICAgIH07XG4gICAgICAgIGZvciAobGV0IG5vZGUgb2Ygbm9kZXMpdmlzaXQobm9kZSk7XG4gICAgICAgIGxldCBsYXN0O1xuICAgICAgICBsZXQgaW5kZXggPSAwO1xuICAgICAgICBmb3IgKGxldCBba2V5LCBub2RlXSBvZiB0aGlzLmtleU1hcCl7XG4gICAgICAgICAgICBpZiAobGFzdCkge1xuICAgICAgICAgICAgICAgIGxhc3QubmV4dEtleSA9IGtleTtcbiAgICAgICAgICAgICAgICBub2RlLnByZXZLZXkgPSBsYXN0LmtleTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5maXJzdEtleSA9IGtleTtcbiAgICAgICAgICAgICAgICBub2RlLnByZXZLZXkgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobm9kZS50eXBlID09PSBcIml0ZW1cIikgbm9kZS5pbmRleCA9IGluZGV4Kys7XG4gICAgICAgICAgICBsYXN0ID0gbm9kZTtcbiAgICAgICAgICAgIC8vIFNldCBuZXh0S2V5IGFzIHVuZGVmaW5lZCBzaW5jZSB0aGlzIG1pZ2h0IGJlIHRoZSBsYXN0IG5vZGVcbiAgICAgICAgICAgIC8vIElmIGl0IGlzbid0IHRoZSBsYXN0IG5vZGUsIGxhc3QubmV4dEtleSB3aWxsIHByb3Blcmx5IHNldCBhdCBzdGFydCBvZiBuZXcgbG9vcFxuICAgICAgICAgICAgbGFzdC5uZXh0S2V5ID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubGFzdEtleSA9IGxhc3QgPT09IG51bGwgfHwgbGFzdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogbGFzdC5rZXk7XG4gICAgfVxufVxuXG5cblxuXG5cbmZ1bmN0aW9uICQ4NzVkNjY5M2UxMmFmMDcxJGV4cG9ydCQ3MjhkNmJhNTM0NDAzNzU2KHByb3BzKSB7XG4gICAgbGV0IFtleHBhbmRlZEtleXMsIHNldEV4cGFuZGVkS2V5c10gPSAoMCwgJDFPb1RqJHVzZUNvbnRyb2xsZWRTdGF0ZSkocHJvcHMuZXhwYW5kZWRLZXlzID8gbmV3IFNldChwcm9wcy5leHBhbmRlZEtleXMpIDogdW5kZWZpbmVkLCBwcm9wcy5kZWZhdWx0RXhwYW5kZWRLZXlzID8gbmV3IFNldChwcm9wcy5kZWZhdWx0RXhwYW5kZWRLZXlzKSA6IG5ldyBTZXQoKSwgcHJvcHMub25FeHBhbmRlZENoYW5nZSk7XG4gICAgbGV0IHNlbGVjdGlvblN0YXRlID0gKDAsICQxT29UaiR1c2VNdWx0aXBsZVNlbGVjdGlvblN0YXRlKShwcm9wcyk7XG4gICAgbGV0IGRpc2FibGVkS2V5cyA9ICgwLCAkMU9vVGokdXNlTWVtbykoKCk9PnByb3BzLmRpc2FibGVkS2V5cyA/IG5ldyBTZXQocHJvcHMuZGlzYWJsZWRLZXlzKSA6IG5ldyBTZXQoKSwgW1xuICAgICAgICBwcm9wcy5kaXNhYmxlZEtleXNcbiAgICBdKTtcbiAgICBsZXQgdHJlZSA9ICgwLCAkMU9vVGokdXNlQ29sbGVjdGlvbikocHJvcHMsICgwLCAkMU9vVGokdXNlQ2FsbGJhY2spKChub2Rlcyk9Pm5ldyAoMCwgJDA1Y2E0Y2Q3YzRhNWE5OTkkZXhwb3J0JDg2M2ZhZjIzMGVlMjExOGEpKG5vZGVzLCB7XG4gICAgICAgICAgICBleHBhbmRlZEtleXM6IGV4cGFuZGVkS2V5c1xuICAgICAgICB9KSwgW1xuICAgICAgICBleHBhbmRlZEtleXNcbiAgICBdKSwgbnVsbCk7XG4gICAgLy8gUmVzZXQgZm9jdXNlZCBrZXkgaWYgdGhhdCBpdGVtIGlzIGRlbGV0ZWQgZnJvbSB0aGUgY29sbGVjdGlvbi5cbiAgICAoMCwgJDFPb1RqJHVzZUVmZmVjdCkoKCk9PntcbiAgICAgICAgaWYgKHNlbGVjdGlvblN0YXRlLmZvY3VzZWRLZXkgIT0gbnVsbCAmJiAhdHJlZS5nZXRJdGVtKHNlbGVjdGlvblN0YXRlLmZvY3VzZWRLZXkpKSBzZWxlY3Rpb25TdGF0ZS5zZXRGb2N1c2VkS2V5KG51bGwpO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgICB9LCBbXG4gICAgICAgIHRyZWUsXG4gICAgICAgIHNlbGVjdGlvblN0YXRlLmZvY3VzZWRLZXlcbiAgICBdKTtcbiAgICBsZXQgb25Ub2dnbGUgPSAoa2V5KT0+e1xuICAgICAgICBzZXRFeHBhbmRlZEtleXMoJDg3NWQ2NjkzZTEyYWYwNzEkdmFyJHRvZ2dsZUtleShleHBhbmRlZEtleXMsIGtleSkpO1xuICAgIH07XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY29sbGVjdGlvbjogdHJlZSxcbiAgICAgICAgZXhwYW5kZWRLZXlzOiBleHBhbmRlZEtleXMsXG4gICAgICAgIGRpc2FibGVkS2V5czogZGlzYWJsZWRLZXlzLFxuICAgICAgICB0b2dnbGVLZXk6IG9uVG9nZ2xlLFxuICAgICAgICBzZXRFeHBhbmRlZEtleXM6IHNldEV4cGFuZGVkS2V5cyxcbiAgICAgICAgc2VsZWN0aW9uTWFuYWdlcjogbmV3ICgwLCAkMU9vVGokU2VsZWN0aW9uTWFuYWdlcikodHJlZSwgc2VsZWN0aW9uU3RhdGUpXG4gICAgfTtcbn1cbmZ1bmN0aW9uICQ4NzVkNjY5M2UxMmFmMDcxJHZhciR0b2dnbGVLZXkoc2V0LCBrZXkpIHtcbiAgICBsZXQgcmVzID0gbmV3IFNldChzZXQpO1xuICAgIGlmIChyZXMuaGFzKGtleSkpIHJlcy5kZWxldGUoa2V5KTtcbiAgICBlbHNlIHJlcy5hZGQoa2V5KTtcbiAgICByZXR1cm4gcmVzO1xufVxuXG5cblxuXG5cbmV4cG9ydCB7JDg3NWQ2NjkzZTEyYWYwNzEkZXhwb3J0JDcyOGQ2YmE1MzQ0MDM3NTYgYXMgdXNlVHJlZVN0YXRlLCAkMDVjYTRjZDdjNGE1YTk5OSRleHBvcnQkODYzZmFmMjMwZWUyMTE4YSBhcyBUcmVlQ29sbGVjdGlvbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tb2R1bGUuanMubWFwXG4iXSwibmFtZXMiOlsidXNlTXVsdGlwbGVTZWxlY3Rpb25TdGF0ZSIsIiQxT29UaiR1c2VNdWx0aXBsZVNlbGVjdGlvblN0YXRlIiwiU2VsZWN0aW9uTWFuYWdlciIsIiQxT29UaiRTZWxlY3Rpb25NYW5hZ2VyIiwidXNlTWVtbyIsIiQxT29UaiR1c2VNZW1vIiwidXNlQ2FsbGJhY2siLCIkMU9vVGokdXNlQ2FsbGJhY2siLCJ1c2VFZmZlY3QiLCIkMU9vVGokdXNlRWZmZWN0IiwidXNlQ29sbGVjdGlvbiIsIiQxT29UaiR1c2VDb2xsZWN0aW9uIiwidXNlQ29udHJvbGxlZFN0YXRlIiwiJDFPb1RqJHVzZUNvbnRyb2xsZWRTdGF0ZSIsIiQwNWNhNGNkN2M0YTVhOTk5JGV4cG9ydCQ4NjNmYWYyMzBlZTIxMThhIiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJpdGVyYWJsZSIsInNpemUiLCJrZXlNYXAiLCJnZXRLZXlzIiwia2V5cyIsImdldEtleUJlZm9yZSIsImtleSIsIm5vZGUiLCJnZXQiLCJwcmV2S2V5IiwiZ2V0S2V5QWZ0ZXIiLCJuZXh0S2V5IiwiZ2V0Rmlyc3RLZXkiLCJmaXJzdEtleSIsImdldExhc3RLZXkiLCJsYXN0S2V5IiwiZ2V0SXRlbSIsImF0IiwiaWR4IiwiY29uc3RydWN0b3IiLCJub2RlcyIsImV4cGFuZGVkS2V5cyIsIk1hcCIsIlNldCIsInZpc2l0Iiwic2V0IiwiY2hpbGROb2RlcyIsInR5cGUiLCJoYXMiLCJjaGlsZCIsImxhc3QiLCJpbmRleCIsInVuZGVmaW5lZCIsIiQ4NzVkNjY5M2UxMmFmMDcxJGV4cG9ydCQ3MjhkNmJhNTM0NDAzNzU2IiwicHJvcHMiLCJzZXRFeHBhbmRlZEtleXMiLCJkZWZhdWx0RXhwYW5kZWRLZXlzIiwib25FeHBhbmRlZENoYW5nZSIsInNlbGVjdGlvblN0YXRlIiwiZGlzYWJsZWRLZXlzIiwidHJlZSIsImZvY3VzZWRLZXkiLCJzZXRGb2N1c2VkS2V5Iiwib25Ub2dnbGUiLCIkODc1ZDY2OTNlMTJhZjA3MSR2YXIkdG9nZ2xlS2V5IiwiY29sbGVjdGlvbiIsInRvZ2dsZUtleSIsInNlbGVjdGlvbk1hbmFnZXIiLCJyZXMiLCJkZWxldGUiLCJhZGQiLCJ1c2VUcmVlU3RhdGUiLCJUcmVlQ29sbGVjdGlvbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-stately/tree/dist/import.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-stately/utils/dist/import.mjs":
/*!***********************************************************!*\
  !*** ./node_modules/@react-stately/utils/dist/import.mjs ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   clamp: () => (/* binding */ $9446cca9a3875146$export$7d15b64cf5a3a4c4),\n/* harmony export */   snapValueToStep: () => (/* binding */ $9446cca9a3875146$export$cb6e0bb50bc19463),\n/* harmony export */   toFixedNumber: () => (/* binding */ $9446cca9a3875146$export$b6268554fba451f),\n/* harmony export */   useControlledState: () => (/* binding */ $458b0a5536c1a7cf$export$40bfa8c7b0832715)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ function $458b0a5536c1a7cf$export$40bfa8c7b0832715(value, defaultValue, onChange) {\n    let [stateValue, setStateValue] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(value || defaultValue);\n    let isControlledRef = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)(value !== undefined);\n    let isControlled = value !== undefined;\n    (0, react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        let wasControlled = isControlledRef.current;\n        if (wasControlled !== isControlled) console.warn(`WARN: A component changed from ${wasControlled ? \"controlled\" : \"uncontrolled\"} to ${isControlled ? \"controlled\" : \"uncontrolled\"}.`);\n        isControlledRef.current = isControlled;\n    }, [\n        isControlled\n    ]);\n    let currentValue = isControlled ? value : stateValue;\n    let setValue = (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((value, ...args)=>{\n        let onChangeCaller = (value, ...onChangeArgs)=>{\n            if (onChange) {\n                if (!Object.is(currentValue, value)) onChange(value, ...onChangeArgs);\n            }\n            if (!isControlled) // calling setState multiple times with the same value only emits onChange once.\n            // We do not use a ref for this because we specifically _do_ want the value to\n            // reset every render, and assigning to a ref in render breaks aborted suspended renders.\n            // eslint-disable-next-line react-hooks/exhaustive-deps\n            currentValue = value;\n        };\n        if (typeof value === \"function\") {\n            console.warn(\"We can not support a function callback. See Github Issues for details https://github.com/adobe/react-spectrum/issues/2320\");\n            // this supports functional updates https://reactjs.org/docs/hooks-reference.html#functional-updates\n            // when someone using useControlledState calls setControlledState(myFunc)\n            // this will call our useState setState with a function as well which invokes myFunc and calls onChange with the value from myFunc\n            // if we're in an uncontrolled state, then we also return the value of myFunc which to setState looks as though it was just called with myFunc from the beginning\n            // otherwise we just return the controlled value, which won't cause a rerender because React knows to bail out when the value is the same\n            let updateFunction = (oldValue, ...functionArgs)=>{\n                let interceptedValue = value(isControlled ? currentValue : oldValue, ...functionArgs);\n                onChangeCaller(interceptedValue, ...args);\n                if (!isControlled) return interceptedValue;\n                return oldValue;\n            };\n            setStateValue(updateFunction);\n        } else {\n            if (!isControlled) setStateValue(value);\n            onChangeCaller(value, ...args);\n        }\n    }, [\n        isControlled,\n        currentValue,\n        onChange\n    ]);\n    return [\n        currentValue,\n        setValue\n    ];\n}\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /**\n * Takes a value and forces it to the closest min/max if it's outside. Also forces it to the closest valid step.\n */ function $9446cca9a3875146$export$7d15b64cf5a3a4c4(value, min = -Infinity, max = Infinity) {\n    let newValue = Math.min(Math.max(value, min), max);\n    return newValue;\n}\nfunction $9446cca9a3875146$export$cb6e0bb50bc19463(value, min, max, step) {\n    min = Number(min);\n    max = Number(max);\n    let remainder = (value - (isNaN(min) ? 0 : min)) % step;\n    let snappedValue = Math.abs(remainder) * 2 >= step ? value + Math.sign(remainder) * (step - Math.abs(remainder)) : value - remainder;\n    if (!isNaN(min)) {\n        if (snappedValue < min) snappedValue = min;\n        else if (!isNaN(max) && snappedValue > max) snappedValue = min + Math.floor((max - min) / step) * step;\n    } else if (!isNaN(max) && snappedValue > max) snappedValue = Math.floor(max / step) * step;\n    // correct floating point behavior by rounding to step precision\n    let string = step.toString();\n    let index = string.indexOf(\".\");\n    let precision = index >= 0 ? string.length - index : 0;\n    if (precision > 0) {\n        let pow = Math.pow(10, precision);\n        snappedValue = Math.round(snappedValue * pow) / pow;\n    }\n    return snappedValue;\n}\nfunction $9446cca9a3875146$export$b6268554fba451f(value, digits, base = 10) {\n    const pow = Math.pow(base, digits);\n    return Math.round(value * pow) / pow;\n}\n //# sourceMappingURL=module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXN0YXRlbHkvdXRpbHMvZGlzdC9pbXBvcnQubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQTZJO0FBRTdJOzs7Ozs7Ozs7O0NBVUMsR0FBRzs7Ozs7Ozs7OztDQVVILEdBQ0QsU0FBU1EsMENBQTBDQyxLQUFLLEVBQUVDLFlBQVksRUFBRUMsUUFBUTtJQUM1RSxJQUFJLENBQUNDLFlBQVlDLGNBQWMsR0FBRyxDQUFDLEdBQUdaLDJDQUFjLEVBQUdRLFNBQVNDO0lBQ2hFLElBQUlJLGtCQUFrQixDQUFDLEdBQUdYLHlDQUFZLEVBQUdNLFVBQVVNO0lBQ25ELElBQUlDLGVBQWVQLFVBQVVNO0lBQzVCLElBQUdWLDRDQUFlLEVBQUc7UUFDbEIsSUFBSVksZ0JBQWdCSCxnQkFBZ0JJLE9BQU87UUFDM0MsSUFBSUQsa0JBQWtCRCxjQUFjRyxRQUFRQyxJQUFJLENBQUMsQ0FBQywrQkFBK0IsRUFBRUgsZ0JBQWdCLGVBQWUsZUFBZSxJQUFJLEVBQUVELGVBQWUsZUFBZSxlQUFlLENBQUMsQ0FBQztRQUN0TEYsZ0JBQWdCSSxPQUFPLEdBQUdGO0lBQzlCLEdBQUc7UUFDQ0E7S0FDSDtJQUNELElBQUlLLGVBQWVMLGVBQWVQLFFBQVFHO0lBQzFDLElBQUlVLFdBQVcsQ0FBQyxHQUFHZiw4Q0FBaUIsRUFBRyxDQUFDRSxPQUFPLEdBQUdjO1FBQzlDLElBQUlDLGlCQUFpQixDQUFDZixPQUFPLEdBQUdnQjtZQUM1QixJQUFJZCxVQUFVO2dCQUNWLElBQUksQ0FBQ2UsT0FBT0MsRUFBRSxDQUFDTixjQUFjWixRQUFRRSxTQUFTRixVQUFVZ0I7WUFDNUQ7WUFDQSxJQUFJLENBQUNULGNBQ0wsZ0ZBQWdGO1lBQ2hGLDhFQUE4RTtZQUM5RSx5RkFBeUY7WUFDekYsdURBQXVEO1lBQ3ZESyxlQUFlWjtRQUNuQjtRQUNBLElBQUksT0FBT0EsVUFBVSxZQUFZO1lBQzdCVSxRQUFRQyxJQUFJLENBQUM7WUFDYixvR0FBb0c7WUFDcEcseUVBQXlFO1lBQ3pFLGtJQUFrSTtZQUNsSSxpS0FBaUs7WUFDaksseUlBQXlJO1lBQ3pJLElBQUlRLGlCQUFpQixDQUFDQyxVQUFVLEdBQUdDO2dCQUMvQixJQUFJQyxtQkFBbUJ0QixNQUFNTyxlQUFlSyxlQUFlUSxhQUFhQztnQkFDeEVOLGVBQWVPLHFCQUFxQlI7Z0JBQ3BDLElBQUksQ0FBQ1AsY0FBYyxPQUFPZTtnQkFDMUIsT0FBT0Y7WUFDWDtZQUNBaEIsY0FBY2U7UUFDbEIsT0FBTztZQUNILElBQUksQ0FBQ1osY0FBY0gsY0FBY0o7WUFDakNlLGVBQWVmLFVBQVVjO1FBQzdCO0lBQ0osR0FBRztRQUNDUDtRQUNBSztRQUNBVjtLQUNIO0lBQ0QsT0FBTztRQUNIVTtRQUNBQztLQUNIO0FBQ0w7QUFHQTs7Ozs7Ozs7OztDQVVDLEdBQUc7O0NBRUgsR0FBRyxTQUFTVSwwQ0FBMEN2QixLQUFLLEVBQUV3QixNQUFNLENBQUNDLFFBQVEsRUFBRUMsTUFBTUQsUUFBUTtJQUN6RixJQUFJRSxXQUFXQyxLQUFLSixHQUFHLENBQUNJLEtBQUtGLEdBQUcsQ0FBQzFCLE9BQU93QixNQUFNRTtJQUM5QyxPQUFPQztBQUNYO0FBQ0EsU0FBU0UsMENBQTBDN0IsS0FBSyxFQUFFd0IsR0FBRyxFQUFFRSxHQUFHLEVBQUVJLElBQUk7SUFDcEVOLE1BQU1PLE9BQU9QO0lBQ2JFLE1BQU1LLE9BQU9MO0lBQ2IsSUFBSU0sWUFBWSxDQUFDaEMsUUFBU2lDLENBQUFBLE1BQU1ULE9BQU8sSUFBSUEsR0FBRSxDQUFDLElBQUtNO0lBQ25ELElBQUlJLGVBQWVOLEtBQUtPLEdBQUcsQ0FBQ0gsYUFBYSxLQUFLRixPQUFPOUIsUUFBUTRCLEtBQUtRLElBQUksQ0FBQ0osYUFBY0YsQ0FBQUEsT0FBT0YsS0FBS08sR0FBRyxDQUFDSCxVQUFTLElBQUtoQyxRQUFRZ0M7SUFDM0gsSUFBSSxDQUFDQyxNQUFNVCxNQUFNO1FBQ2IsSUFBSVUsZUFBZVYsS0FBS1UsZUFBZVY7YUFDbEMsSUFBSSxDQUFDUyxNQUFNUCxRQUFRUSxlQUFlUixLQUFLUSxlQUFlVixNQUFNSSxLQUFLUyxLQUFLLENBQUMsQ0FBQ1gsTUFBTUYsR0FBRSxJQUFLTSxRQUFRQTtJQUN0RyxPQUFPLElBQUksQ0FBQ0csTUFBTVAsUUFBUVEsZUFBZVIsS0FBS1EsZUFBZU4sS0FBS1MsS0FBSyxDQUFDWCxNQUFNSSxRQUFRQTtJQUN0RixnRUFBZ0U7SUFDaEUsSUFBSVEsU0FBU1IsS0FBS1MsUUFBUTtJQUMxQixJQUFJQyxRQUFRRixPQUFPRyxPQUFPLENBQUM7SUFDM0IsSUFBSUMsWUFBWUYsU0FBUyxJQUFJRixPQUFPSyxNQUFNLEdBQUdILFFBQVE7SUFDckQsSUFBSUUsWUFBWSxHQUFHO1FBQ2YsSUFBSUUsTUFBTWhCLEtBQUtnQixHQUFHLENBQUMsSUFBSUY7UUFDdkJSLGVBQWVOLEtBQUtpQixLQUFLLENBQUNYLGVBQWVVLE9BQU9BO0lBQ3BEO0lBQ0EsT0FBT1Y7QUFDWDtBQUNBLFNBQVNZLHlDQUF5QzlDLEtBQUssRUFBRStDLE1BQU0sRUFBRUMsT0FBTyxFQUFFO0lBQ3RFLE1BQU1KLE1BQU1oQixLQUFLZ0IsR0FBRyxDQUFDSSxNQUFNRDtJQUMzQixPQUFPbkIsS0FBS2lCLEtBQUssQ0FBQzdDLFFBQVE0QyxPQUFPQTtBQUNyQztBQUtzUCxDQUN0UCxrQ0FBa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LWZsYXNrLy4vbm9kZV9tb2R1bGVzL0ByZWFjdC1zdGF0ZWx5L3V0aWxzL2Rpc3QvaW1wb3J0Lm1qcz9lM2Y1Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7dXNlU3RhdGUgYXMgJDZpbXVoJHVzZVN0YXRlLCB1c2VSZWYgYXMgJDZpbXVoJHVzZVJlZiwgdXNlRWZmZWN0IGFzICQ2aW11aCR1c2VFZmZlY3QsIHVzZUNhbGxiYWNrIGFzICQ2aW11aCR1c2VDYWxsYmFja30gZnJvbSBcInJlYWN0XCI7XG5cbi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyAvKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gXG5mdW5jdGlvbiAkNDU4YjBhNTUzNmMxYTdjZiRleHBvcnQkNDBiZmE4YzdiMDgzMjcxNSh2YWx1ZSwgZGVmYXVsdFZhbHVlLCBvbkNoYW5nZSkge1xuICAgIGxldCBbc3RhdGVWYWx1ZSwgc2V0U3RhdGVWYWx1ZV0gPSAoMCwgJDZpbXVoJHVzZVN0YXRlKSh2YWx1ZSB8fCBkZWZhdWx0VmFsdWUpO1xuICAgIGxldCBpc0NvbnRyb2xsZWRSZWYgPSAoMCwgJDZpbXVoJHVzZVJlZikodmFsdWUgIT09IHVuZGVmaW5lZCk7XG4gICAgbGV0IGlzQ29udHJvbGxlZCA9IHZhbHVlICE9PSB1bmRlZmluZWQ7XG4gICAgKDAsICQ2aW11aCR1c2VFZmZlY3QpKCgpPT57XG4gICAgICAgIGxldCB3YXNDb250cm9sbGVkID0gaXNDb250cm9sbGVkUmVmLmN1cnJlbnQ7XG4gICAgICAgIGlmICh3YXNDb250cm9sbGVkICE9PSBpc0NvbnRyb2xsZWQpIGNvbnNvbGUud2FybihgV0FSTjogQSBjb21wb25lbnQgY2hhbmdlZCBmcm9tICR7d2FzQ29udHJvbGxlZCA/IFwiY29udHJvbGxlZFwiIDogXCJ1bmNvbnRyb2xsZWRcIn0gdG8gJHtpc0NvbnRyb2xsZWQgPyBcImNvbnRyb2xsZWRcIiA6IFwidW5jb250cm9sbGVkXCJ9LmApO1xuICAgICAgICBpc0NvbnRyb2xsZWRSZWYuY3VycmVudCA9IGlzQ29udHJvbGxlZDtcbiAgICB9LCBbXG4gICAgICAgIGlzQ29udHJvbGxlZFxuICAgIF0pO1xuICAgIGxldCBjdXJyZW50VmFsdWUgPSBpc0NvbnRyb2xsZWQgPyB2YWx1ZSA6IHN0YXRlVmFsdWU7XG4gICAgbGV0IHNldFZhbHVlID0gKDAsICQ2aW11aCR1c2VDYWxsYmFjaykoKHZhbHVlLCAuLi5hcmdzKT0+e1xuICAgICAgICBsZXQgb25DaGFuZ2VDYWxsZXIgPSAodmFsdWUsIC4uLm9uQ2hhbmdlQXJncyk9PntcbiAgICAgICAgICAgIGlmIChvbkNoYW5nZSkge1xuICAgICAgICAgICAgICAgIGlmICghT2JqZWN0LmlzKGN1cnJlbnRWYWx1ZSwgdmFsdWUpKSBvbkNoYW5nZSh2YWx1ZSwgLi4ub25DaGFuZ2VBcmdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaXNDb250cm9sbGVkKSAvLyBJZiB1bmNvbnRyb2xsZWQsIG11dGF0ZSB0aGUgY3VycmVudFZhbHVlIGxvY2FsIHZhcmlhYmxlIHNvIHRoYXRcbiAgICAgICAgICAgIC8vIGNhbGxpbmcgc2V0U3RhdGUgbXVsdGlwbGUgdGltZXMgd2l0aCB0aGUgc2FtZSB2YWx1ZSBvbmx5IGVtaXRzIG9uQ2hhbmdlIG9uY2UuXG4gICAgICAgICAgICAvLyBXZSBkbyBub3QgdXNlIGEgcmVmIGZvciB0aGlzIGJlY2F1c2Ugd2Ugc3BlY2lmaWNhbGx5IF9kb18gd2FudCB0aGUgdmFsdWUgdG9cbiAgICAgICAgICAgIC8vIHJlc2V0IGV2ZXJ5IHJlbmRlciwgYW5kIGFzc2lnbmluZyB0byBhIHJlZiBpbiByZW5kZXIgYnJlYWtzIGFib3J0ZWQgc3VzcGVuZGVkIHJlbmRlcnMuXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gICAgICAgICAgICBjdXJyZW50VmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJXZSBjYW4gbm90IHN1cHBvcnQgYSBmdW5jdGlvbiBjYWxsYmFjay4gU2VlIEdpdGh1YiBJc3N1ZXMgZm9yIGRldGFpbHMgaHR0cHM6Ly9naXRodWIuY29tL2Fkb2JlL3JlYWN0LXNwZWN0cnVtL2lzc3Vlcy8yMzIwXCIpO1xuICAgICAgICAgICAgLy8gdGhpcyBzdXBwb3J0cyBmdW5jdGlvbmFsIHVwZGF0ZXMgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL2hvb2tzLXJlZmVyZW5jZS5odG1sI2Z1bmN0aW9uYWwtdXBkYXRlc1xuICAgICAgICAgICAgLy8gd2hlbiBzb21lb25lIHVzaW5nIHVzZUNvbnRyb2xsZWRTdGF0ZSBjYWxscyBzZXRDb250cm9sbGVkU3RhdGUobXlGdW5jKVxuICAgICAgICAgICAgLy8gdGhpcyB3aWxsIGNhbGwgb3VyIHVzZVN0YXRlIHNldFN0YXRlIHdpdGggYSBmdW5jdGlvbiBhcyB3ZWxsIHdoaWNoIGludm9rZXMgbXlGdW5jIGFuZCBjYWxscyBvbkNoYW5nZSB3aXRoIHRoZSB2YWx1ZSBmcm9tIG15RnVuY1xuICAgICAgICAgICAgLy8gaWYgd2UncmUgaW4gYW4gdW5jb250cm9sbGVkIHN0YXRlLCB0aGVuIHdlIGFsc28gcmV0dXJuIHRoZSB2YWx1ZSBvZiBteUZ1bmMgd2hpY2ggdG8gc2V0U3RhdGUgbG9va3MgYXMgdGhvdWdoIGl0IHdhcyBqdXN0IGNhbGxlZCB3aXRoIG15RnVuYyBmcm9tIHRoZSBiZWdpbm5pbmdcbiAgICAgICAgICAgIC8vIG90aGVyd2lzZSB3ZSBqdXN0IHJldHVybiB0aGUgY29udHJvbGxlZCB2YWx1ZSwgd2hpY2ggd29uJ3QgY2F1c2UgYSByZXJlbmRlciBiZWNhdXNlIFJlYWN0IGtub3dzIHRvIGJhaWwgb3V0IHdoZW4gdGhlIHZhbHVlIGlzIHRoZSBzYW1lXG4gICAgICAgICAgICBsZXQgdXBkYXRlRnVuY3Rpb24gPSAob2xkVmFsdWUsIC4uLmZ1bmN0aW9uQXJncyk9PntcbiAgICAgICAgICAgICAgICBsZXQgaW50ZXJjZXB0ZWRWYWx1ZSA9IHZhbHVlKGlzQ29udHJvbGxlZCA/IGN1cnJlbnRWYWx1ZSA6IG9sZFZhbHVlLCAuLi5mdW5jdGlvbkFyZ3MpO1xuICAgICAgICAgICAgICAgIG9uQ2hhbmdlQ2FsbGVyKGludGVyY2VwdGVkVmFsdWUsIC4uLmFyZ3MpO1xuICAgICAgICAgICAgICAgIGlmICghaXNDb250cm9sbGVkKSByZXR1cm4gaW50ZXJjZXB0ZWRWYWx1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gb2xkVmFsdWU7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgc2V0U3RhdGVWYWx1ZSh1cGRhdGVGdW5jdGlvbik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIWlzQ29udHJvbGxlZCkgc2V0U3RhdGVWYWx1ZSh2YWx1ZSk7XG4gICAgICAgICAgICBvbkNoYW5nZUNhbGxlcih2YWx1ZSwgLi4uYXJncyk7XG4gICAgICAgIH1cbiAgICB9LCBbXG4gICAgICAgIGlzQ29udHJvbGxlZCxcbiAgICAgICAgY3VycmVudFZhbHVlLFxuICAgICAgICBvbkNoYW5nZVxuICAgIF0pO1xuICAgIHJldHVybiBbXG4gICAgICAgIGN1cnJlbnRWYWx1ZSxcbiAgICAgICAgc2V0VmFsdWVcbiAgICBdO1xufVxuXG5cbi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyAvKipcbiAqIFRha2VzIGEgdmFsdWUgYW5kIGZvcmNlcyBpdCB0byB0aGUgY2xvc2VzdCBtaW4vbWF4IGlmIGl0J3Mgb3V0c2lkZS4gQWxzbyBmb3JjZXMgaXQgdG8gdGhlIGNsb3Nlc3QgdmFsaWQgc3RlcC5cbiAqLyBmdW5jdGlvbiAkOTQ0NmNjYTlhMzg3NTE0NiRleHBvcnQkN2QxNWI2NGNmNWEzYTRjNCh2YWx1ZSwgbWluID0gLUluZmluaXR5LCBtYXggPSBJbmZpbml0eSkge1xuICAgIGxldCBuZXdWYWx1ZSA9IE1hdGgubWluKE1hdGgubWF4KHZhbHVlLCBtaW4pLCBtYXgpO1xuICAgIHJldHVybiBuZXdWYWx1ZTtcbn1cbmZ1bmN0aW9uICQ5NDQ2Y2NhOWEzODc1MTQ2JGV4cG9ydCRjYjZlMGJiNTBiYzE5NDYzKHZhbHVlLCBtaW4sIG1heCwgc3RlcCkge1xuICAgIG1pbiA9IE51bWJlcihtaW4pO1xuICAgIG1heCA9IE51bWJlcihtYXgpO1xuICAgIGxldCByZW1haW5kZXIgPSAodmFsdWUgLSAoaXNOYU4obWluKSA/IDAgOiBtaW4pKSAlIHN0ZXA7XG4gICAgbGV0IHNuYXBwZWRWYWx1ZSA9IE1hdGguYWJzKHJlbWFpbmRlcikgKiAyID49IHN0ZXAgPyB2YWx1ZSArIE1hdGguc2lnbihyZW1haW5kZXIpICogKHN0ZXAgLSBNYXRoLmFicyhyZW1haW5kZXIpKSA6IHZhbHVlIC0gcmVtYWluZGVyO1xuICAgIGlmICghaXNOYU4obWluKSkge1xuICAgICAgICBpZiAoc25hcHBlZFZhbHVlIDwgbWluKSBzbmFwcGVkVmFsdWUgPSBtaW47XG4gICAgICAgIGVsc2UgaWYgKCFpc05hTihtYXgpICYmIHNuYXBwZWRWYWx1ZSA+IG1heCkgc25hcHBlZFZhbHVlID0gbWluICsgTWF0aC5mbG9vcigobWF4IC0gbWluKSAvIHN0ZXApICogc3RlcDtcbiAgICB9IGVsc2UgaWYgKCFpc05hTihtYXgpICYmIHNuYXBwZWRWYWx1ZSA+IG1heCkgc25hcHBlZFZhbHVlID0gTWF0aC5mbG9vcihtYXggLyBzdGVwKSAqIHN0ZXA7XG4gICAgLy8gY29ycmVjdCBmbG9hdGluZyBwb2ludCBiZWhhdmlvciBieSByb3VuZGluZyB0byBzdGVwIHByZWNpc2lvblxuICAgIGxldCBzdHJpbmcgPSBzdGVwLnRvU3RyaW5nKCk7XG4gICAgbGV0IGluZGV4ID0gc3RyaW5nLmluZGV4T2YoXCIuXCIpO1xuICAgIGxldCBwcmVjaXNpb24gPSBpbmRleCA+PSAwID8gc3RyaW5nLmxlbmd0aCAtIGluZGV4IDogMDtcbiAgICBpZiAocHJlY2lzaW9uID4gMCkge1xuICAgICAgICBsZXQgcG93ID0gTWF0aC5wb3coMTAsIHByZWNpc2lvbik7XG4gICAgICAgIHNuYXBwZWRWYWx1ZSA9IE1hdGgucm91bmQoc25hcHBlZFZhbHVlICogcG93KSAvIHBvdztcbiAgICB9XG4gICAgcmV0dXJuIHNuYXBwZWRWYWx1ZTtcbn1cbmZ1bmN0aW9uICQ5NDQ2Y2NhOWEzODc1MTQ2JGV4cG9ydCRiNjI2ODU1NGZiYTQ1MWYodmFsdWUsIGRpZ2l0cywgYmFzZSA9IDEwKSB7XG4gICAgY29uc3QgcG93ID0gTWF0aC5wb3coYmFzZSwgZGlnaXRzKTtcbiAgICByZXR1cm4gTWF0aC5yb3VuZCh2YWx1ZSAqIHBvdykgLyBwb3c7XG59XG5cblxuXG5cbmV4cG9ydCB7JDQ1OGIwYTU1MzZjMWE3Y2YkZXhwb3J0JDQwYmZhOGM3YjA4MzI3MTUgYXMgdXNlQ29udHJvbGxlZFN0YXRlLCAkOTQ0NmNjYTlhMzg3NTE0NiRleHBvcnQkN2QxNWI2NGNmNWEzYTRjNCBhcyBjbGFtcCwgJDk0NDZjY2E5YTM4NzUxNDYkZXhwb3J0JGNiNmUwYmI1MGJjMTk0NjMgYXMgc25hcFZhbHVlVG9TdGVwLCAkOTQ0NmNjYTlhMzg3NTE0NiRleHBvcnQkYjYyNjg1NTRmYmE0NTFmIGFzIHRvRml4ZWROdW1iZXJ9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bW9kdWxlLmpzLm1hcFxuIl0sIm5hbWVzIjpbInVzZVN0YXRlIiwiJDZpbXVoJHVzZVN0YXRlIiwidXNlUmVmIiwiJDZpbXVoJHVzZVJlZiIsInVzZUVmZmVjdCIsIiQ2aW11aCR1c2VFZmZlY3QiLCJ1c2VDYWxsYmFjayIsIiQ2aW11aCR1c2VDYWxsYmFjayIsIiQ0NThiMGE1NTM2YzFhN2NmJGV4cG9ydCQ0MGJmYThjN2IwODMyNzE1IiwidmFsdWUiLCJkZWZhdWx0VmFsdWUiLCJvbkNoYW5nZSIsInN0YXRlVmFsdWUiLCJzZXRTdGF0ZVZhbHVlIiwiaXNDb250cm9sbGVkUmVmIiwidW5kZWZpbmVkIiwiaXNDb250cm9sbGVkIiwid2FzQ29udHJvbGxlZCIsImN1cnJlbnQiLCJjb25zb2xlIiwid2FybiIsImN1cnJlbnRWYWx1ZSIsInNldFZhbHVlIiwiYXJncyIsIm9uQ2hhbmdlQ2FsbGVyIiwib25DaGFuZ2VBcmdzIiwiT2JqZWN0IiwiaXMiLCJ1cGRhdGVGdW5jdGlvbiIsIm9sZFZhbHVlIiwiZnVuY3Rpb25BcmdzIiwiaW50ZXJjZXB0ZWRWYWx1ZSIsIiQ5NDQ2Y2NhOWEzODc1MTQ2JGV4cG9ydCQ3ZDE1YjY0Y2Y1YTNhNGM0IiwibWluIiwiSW5maW5pdHkiLCJtYXgiLCJuZXdWYWx1ZSIsIk1hdGgiLCIkOTQ0NmNjYTlhMzg3NTE0NiRleHBvcnQkY2I2ZTBiYjUwYmMxOTQ2MyIsInN0ZXAiLCJOdW1iZXIiLCJyZW1haW5kZXIiLCJpc05hTiIsInNuYXBwZWRWYWx1ZSIsImFicyIsInNpZ24iLCJmbG9vciIsInN0cmluZyIsInRvU3RyaW5nIiwiaW5kZXgiLCJpbmRleE9mIiwicHJlY2lzaW9uIiwibGVuZ3RoIiwicG93Iiwicm91bmQiLCIkOTQ0NmNjYTlhMzg3NTE0NiRleHBvcnQkYjYyNjg1NTRmYmE0NTFmIiwiZGlnaXRzIiwiYmFzZSIsInVzZUNvbnRyb2xsZWRTdGF0ZSIsImNsYW1wIiwic25hcFZhbHVlVG9TdGVwIiwidG9GaXhlZE51bWJlciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-stately/utils/dist/import.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-stately/virtualizer/dist/import.mjs":
/*!*****************************************************************!*\
  !*** ./node_modules/@react-stately/virtualizer/dist/import.mjs ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Layout: () => (/* binding */ $c74cda7d31af1253$export$c84671f46d6a1ca),\n/* harmony export */   LayoutInfo: () => (/* binding */ $d7fd61009c21d0bb$export$7e0eeb9da702a085),\n/* harmony export */   Point: () => (/* binding */ $3041db3296945e6e$export$baf26146a414f24a),\n/* harmony export */   Rect: () => (/* binding */ $60423f92c7f9ad87$export$c79fc6492f3af13d),\n/* harmony export */   ReusableView: () => (/* binding */ $ad1d98aa8f0c31b4$export$1a5223887c560441),\n/* harmony export */   Size: () => (/* binding */ $ee1bfa90a957fb8a$export$cb6da89c6af1a8ec),\n/* harmony export */   useVirtualizerState: () => (/* binding */ $fc0b13b484ac1194$export$1505db82fe357e65)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @react-aria/utils */ \"(ssr)/./node_modules/@react-aria/utils/dist/import.mjs\");\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ class $c74cda7d31af1253$export$c84671f46d6a1ca {\n    /**\n   * Returns whether the layout should invalidate in response to\n   * visible rectangle changes. By default, it only invalidates\n   * when the collection view's size changes. Return true always\n   * to make the layout invalidate while scrolling (e.g. sticky headers).\n   */ shouldInvalidate(newRect, oldRect) {\n        // By default, invalidate when the size changes\n        return newRect.width !== oldRect.width || newRect.height !== oldRect.height;\n    }\n    /**\n   * This method allows the layout to perform any pre-computation\n   * it needs to in order to prepare {@link LayoutInfo}s for retrieval.\n   * Called by the collection view before {@link getVisibleLayoutInfos}\n   * or {@link getLayoutInfo} are called.\n   */ validate(invalidationContext) {}\n    /**\n   * Returns a {@link DragTarget} describing a view at the given point to be dragged.\n   * Return `null` to cancel the drag. The default implementation returns the view at the given point.\n   * @param point The point at which the drag occurred.\n   */ // getDragTarget(point: Point): DragTarget | null {\n    //   let target = this.virtualizer.keyAtPoint(point);\n    //   if (!target) {\n    //     return null;\n    //   }\n    //   return {\n    //     type: 'item',\n    //     key: target\n    //   };\n    // }\n    /**\n   * Returns a {@link DragTarget} object describing where a drop should occur. Return `null`\n   * to reject the drop. The dropped items will be inserted before the resulting target.\n   * @param point The point at which the drop occurred.\n   */ // getDropTarget(point: Point): DropTarget | null {\n    //   return null;\n    // }\n    /**\n   * Returns the starting attributes for an animated insertion.\n   * The view is animated from this {@link LayoutInfo} to the one returned by {@link getLayoutInfo}.\n   * The default implementation just returns its input.\n   *\n   * @param layoutInfo The proposed LayoutInfo for this view.\n   */ getInitialLayoutInfo(layoutInfo) {\n        return layoutInfo;\n    }\n    /**\n   * Returns the ending attributes for an animated removal.\n   * The view is animated from the {@link LayoutInfo} returned by {@link getLayoutInfo}\n   * to the one returned by this method. The default implementation returns its input.\n   *\n   * @param layoutInfo The original LayoutInfo for this view.\n   */ getFinalLayoutInfo(layoutInfo) {\n        return layoutInfo;\n    }\n}\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ class $d7fd61009c21d0bb$export$7e0eeb9da702a085 {\n    /**\n   * Returns a copy of the LayoutInfo.\n   */ copy() {\n        let res = new $d7fd61009c21d0bb$export$7e0eeb9da702a085(this.type, this.key, this.rect.copy());\n        res.estimatedSize = this.estimatedSize;\n        res.opacity = this.opacity;\n        res.transform = this.transform;\n        res.parentKey = this.parentKey;\n        res.isSticky = this.isSticky;\n        res.zIndex = this.zIndex;\n        res.allowOverflow = this.allowOverflow;\n        return res;\n    }\n    /**\n   * @param type A string representing the view type. Should be `'item'` for item views.\n                            Other types are used by supplementary views.\n   * @param key The unique key for this view.\n   * @param rect The rectangle describing the size and position of this view.\n   */ constructor(type, key, rect){\n        this.type = type;\n        this.key = key;\n        this.parentKey = null;\n        this.rect = rect;\n        this.estimatedSize = false;\n        this.isSticky = false;\n        this.opacity = 1;\n        this.transform = null;\n        this.zIndex = 0;\n        this.allowOverflow = false;\n    }\n}\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ class $3041db3296945e6e$export$baf26146a414f24a {\n    /**\n   * Returns a copy of this point.\n   */ copy() {\n        return new $3041db3296945e6e$export$baf26146a414f24a(this.x, this.y);\n    }\n    /**\n   * Checks if two points are equal.\n   */ equals(point) {\n        return this.x === point.x && this.y === point.y;\n    }\n    /**\n   * Returns true if this point is the origin.\n   */ isOrigin() {\n        return this.x === 0 && this.y === 0;\n    }\n    constructor(x = 0, y = 0){\n        this.x = x;\n        this.y = y;\n    }\n}\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ class $60423f92c7f9ad87$export$c79fc6492f3af13d {\n    /**\n   * The maximum x-coordinate in the rectangle.\n   */ get maxX() {\n        return this.x + this.width;\n    }\n    /**\n   * The maximum y-coordinate in the rectangle.\n   */ get maxY() {\n        return this.y + this.height;\n    }\n    /**\n   * The area of the rectangle.\n   */ get area() {\n        return this.width * this.height;\n    }\n    /**\n   * The top left corner of the rectangle.\n   */ get topLeft() {\n        return new (0, $3041db3296945e6e$export$baf26146a414f24a)(this.x, this.y);\n    }\n    /**\n   * The top right corner of the rectangle.\n   */ get topRight() {\n        return new (0, $3041db3296945e6e$export$baf26146a414f24a)(this.maxX, this.y);\n    }\n    /**\n   * The bottom left corner of the rectangle.\n   */ get bottomLeft() {\n        return new (0, $3041db3296945e6e$export$baf26146a414f24a)(this.x, this.maxY);\n    }\n    /**\n   * The bottom right corner of the rectangle.\n   */ get bottomRight() {\n        return new (0, $3041db3296945e6e$export$baf26146a414f24a)(this.maxX, this.maxY);\n    }\n    /**\n   * Returns whether this rectangle intersects another rectangle.\n   * @param rect - The rectangle to check.\n   */ intersects(rect) {\n        return this.x <= rect.x + rect.width && rect.x <= this.x + this.width && this.y <= rect.y + rect.height && rect.y <= this.y + this.height;\n    }\n    /**\n   * Returns whether this rectangle fully contains another rectangle.\n   * @param rect - The rectangle to check.\n   */ containsRect(rect) {\n        return this.x <= rect.x && this.y <= rect.y && this.maxX >= rect.maxX && this.maxY >= rect.maxY;\n    }\n    /**\n   * Returns whether the rectangle contains the given point.\n   * @param point - The point to check.\n   */ containsPoint(point) {\n        return this.x <= point.x && this.y <= point.y && this.maxX >= point.x && this.maxY >= point.y;\n    }\n    /**\n   * Returns the first corner of this rectangle (from top to bottom, left to right)\n   * that is contained in the given rectangle, or null of the rectangles do not intersect.\n   * @param rect - The rectangle to check.\n   */ getCornerInRect(rect) {\n        for (let key of [\n            \"topLeft\",\n            \"topRight\",\n            \"bottomLeft\",\n            \"bottomRight\"\n        ]){\n            if (rect.containsPoint(this[key])) return key;\n        }\n        return null;\n    }\n    equals(rect) {\n        return rect.x === this.x && rect.y === this.y && rect.width === this.width && rect.height === this.height;\n    }\n    pointEquals(point) {\n        return this.x === point.x && this.y === point.y;\n    }\n    sizeEquals(size) {\n        return this.width === size.width && this.height === size.height;\n    }\n    /**\n   * Returns the union of this Rect and another.\n   */ union(other) {\n        let x = Math.min(this.x, other.x);\n        let y = Math.min(this.y, other.y);\n        let width = Math.max(this.maxX, other.maxX) - x;\n        let height = Math.max(this.maxY, other.maxY) - y;\n        return new $60423f92c7f9ad87$export$c79fc6492f3af13d(x, y, width, height);\n    }\n    /**\n   * Returns the intersection of this Rect with another.\n   * If the rectangles do not intersect, an all zero Rect is returned.\n   */ intersection(other) {\n        if (!this.intersects(other)) return new $60423f92c7f9ad87$export$c79fc6492f3af13d(0, 0, 0, 0);\n        let x = Math.max(this.x, other.x);\n        let y = Math.max(this.y, other.y);\n        return new $60423f92c7f9ad87$export$c79fc6492f3af13d(x, y, Math.min(this.maxX, other.maxX) - x, Math.min(this.maxY, other.maxY) - y);\n    }\n    /**\n   * Returns a copy of this rectangle.\n   */ copy() {\n        return new $60423f92c7f9ad87$export$c79fc6492f3af13d(this.x, this.y, this.width, this.height);\n    }\n    constructor(x = 0, y = 0, width = 0, height = 0){\n        this.x = x;\n        this.y = y;\n        this.width = width;\n        this.height = height;\n    }\n}\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ class $ee1bfa90a957fb8a$export$cb6da89c6af1a8ec {\n    /**\n   * Returns a copy of this size.\n   */ copy() {\n        return new $ee1bfa90a957fb8a$export$cb6da89c6af1a8ec(this.width, this.height);\n    }\n    /**\n   * Returns whether this size is equal to another one.\n   */ equals(other) {\n        return this.width === other.width && this.height === other.height;\n    }\n    /**\n   * The total area of the Size.\n   */ get area() {\n        return this.width * this.height;\n    }\n    constructor(width = 0, height = 0){\n        this.width = width;\n        this.height = height;\n    }\n}\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ let $ad1d98aa8f0c31b4$var$KEY = 0;\nclass $ad1d98aa8f0c31b4$export$1a5223887c560441 {\n    /**\n   * Prepares the view for reuse. Called just before the view is removed from the DOM.\n   */ prepareForReuse() {\n        this.content = null;\n        this.rendered = null;\n        this.layoutInfo = null;\n    }\n    constructor(virtualizer){\n        this.virtualizer = virtualizer;\n        this.key = ++$ad1d98aa8f0c31b4$var$KEY;\n    }\n}\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ // use high res timer if available\nlet $3eb131dcf37ad5f8$var$perf =  false ? 0 : null;\n// @ts-ignore\nlet $3eb131dcf37ad5f8$var$perfNow = $3eb131dcf37ad5f8$var$perf && ($3eb131dcf37ad5f8$var$perf.now || $3eb131dcf37ad5f8$var$perf.webkitNow || $3eb131dcf37ad5f8$var$perf.msNow || $3eb131dcf37ad5f8$var$perf.mozNow);\nlet $3eb131dcf37ad5f8$var$getTime = $3eb131dcf37ad5f8$var$perfNow ? $3eb131dcf37ad5f8$var$perfNow.bind($3eb131dcf37ad5f8$var$perf) : function() {\n    return Date.now ? Date.now() : new Date().getTime();\n};\nlet $3eb131dcf37ad5f8$var$fixTs;\nfunction $3eb131dcf37ad5f8$export$dc0b63720788090c(begin, end, duration, ease, fn) {\n    let canceled = false;\n    let raf_id;\n    let promise = new Promise((resolve)=>{\n        let start = $3eb131dcf37ad5f8$var$getTime();\n        let diffX = end.x - begin.x;\n        let diffY = end.y - begin.y;\n        raf_id = requestAnimationFrame(function run(t) {\n            // if we're using a high res timer, make sure timestamp is not the old epoch-based value.\n            // http://updates.html5rocks.com/2012/05/requestAnimationFrame-API-now-with-sub-millisecond-precision\n            if ($3eb131dcf37ad5f8$var$fixTs == null) $3eb131dcf37ad5f8$var$fixTs = t > 1e12 !== $3eb131dcf37ad5f8$var$getTime() > 1e12;\n            if ($3eb131dcf37ad5f8$var$fixTs) t = $3eb131dcf37ad5f8$var$getTime();\n            // check if we're done\n            let delta = t - start;\n            if (delta > duration) {\n                fn(end);\n                resolve();\n            } else {\n                // call frame callback after computing eased time and get the next frame\n                let proceed = fn(new (0, $3041db3296945e6e$export$baf26146a414f24a)(begin.x + diffX * ease(delta / duration), begin.y + diffY * ease(delta / duration)));\n                if (proceed !== false && !canceled) raf_id = requestAnimationFrame(run);\n            }\n        });\n    });\n    promise.cancel = function() {\n        canceled = true;\n        cancelAnimationFrame(raf_id);\n    };\n    return promise;\n}\nfunction $3eb131dcf37ad5f8$export$77860c106b4a6a2e(t) {\n    return t;\n}\nfunction $3eb131dcf37ad5f8$export$57636bb43b1ccbb0(t) {\n    return Math.sin(t * Math.PI / 2);\n}\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ function $fc36f9a046a9ce79$export$37a26b283fd7740e(a, b) {\n    let res = new Set();\n    for (let key of a.keys())if (!b.has(key)) res.add(key);\n    return res;\n}\nfunction $fc36f9a046a9ce79$export$acaf96a27438246b(a, b) {\n    let toRemove = $fc36f9a046a9ce79$export$37a26b283fd7740e(a, b);\n    let toAdd = $fc36f9a046a9ce79$export$37a26b283fd7740e(b, a);\n    let toUpdate = new Set;\n    for (let key of a.keys())if (b.has(key)) toUpdate.add(key);\n    return {\n        toRemove: toRemove,\n        toAdd: toAdd,\n        toUpdate: toUpdate\n    };\n}\nfunction* $fc36f9a046a9ce79$export$cfc14088dfefce5f(...iterators) {\n    for (let iterator of iterators)yield* iterator;\n}\nfunction $fc36f9a046a9ce79$export$6897c284b6f9f4dc(object) {\n    let res = {};\n    for(let key in object)res[object[key]] = key;\n    return res;\n}\nfunction $fc36f9a046a9ce79$export$a8d0d0c8d1c5df64(a, b) {\n    if (a === b) return true;\n    if (a.size !== b.size) return false;\n    for (let key of a){\n        if (!b.has(key)) return false;\n    }\n    return true;\n}\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ class $364191b3decf3697$var$RollingAverage {\n    addSample(sample) {\n        this.count++;\n        this.value += (sample - this.value) / this.count;\n    }\n    constructor(){\n        this.count = 0;\n        this.value = 0;\n    }\n}\nclass $364191b3decf3697$export$4455ee6afb38dcbb {\n    setVisibleRect(rect) {\n        let time = performance.now() - this.startTime;\n        if (time < 500) {\n            this.averageTime.addSample(time);\n            if (rect.x !== this.visibleRect.x && time > 0) this.velocity.x = (rect.x - this.visibleRect.x) / time;\n            if (rect.y !== this.visibleRect.y && time > 0) this.velocity.y = (rect.y - this.visibleRect.y) / time;\n        }\n        this.startTime = performance.now();\n        this.visibleRect = rect;\n    }\n    collectMetrics() {\n        let time = performance.now() - this.startTime;\n        if (time < 500) this.averagePerf.addSample(time);\n        if (this.visibleRect.height > 0) {\n            let o = Math.abs(this.velocity.y * (this.averageTime.value + this.averagePerf.value));\n            this.overscanY.addSample(o);\n        }\n        if (this.visibleRect.width > 0) {\n            let o = Math.abs(this.velocity.x * (this.averageTime.value + this.averagePerf.value));\n            this.overscanX.addSample(o);\n        }\n    }\n    getOverscannedRect() {\n        let overscanned = this.visibleRect.copy();\n        let overscanY = Math.round(Math.min(this.visibleRect.height * 2, this.overscanY.value) / 100) * 100;\n        if (this.velocity.y > 0) {\n            overscanned.y -= overscanY * 0.2;\n            overscanned.height += overscanY + overscanY * 0.2;\n        } else {\n            overscanned.y -= overscanY;\n            overscanned.height += overscanY + overscanY * 0.2;\n        }\n        let overscanX = Math.round(Math.min(this.visibleRect.width * 2, this.overscanX.value) / 100) * 100;\n        if (this.velocity.x > 0) {\n            overscanned.x -= overscanX * 0.2;\n            overscanned.width += overscanX + overscanX * 0.2;\n        } else {\n            overscanned.x -= overscanX;\n            overscanned.width += overscanX + overscanX * 0.2;\n        }\n        return overscanned;\n    }\n    constructor(){\n        this.startTime = 0;\n        this.averagePerf = new $364191b3decf3697$var$RollingAverage();\n        this.averageTime = new $364191b3decf3697$var$RollingAverage();\n        this.velocity = new (0, $3041db3296945e6e$export$baf26146a414f24a)(5, 5);\n        this.overscanX = new $364191b3decf3697$var$RollingAverage();\n        this.overscanY = new $364191b3decf3697$var$RollingAverage();\n        this.visibleRect = new (0, $60423f92c7f9ad87$export$c79fc6492f3af13d)();\n    }\n}\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ class $8e135e531d8dcb66$export$febc5573c75cefb0 {\n    constructor(){\n        this.level = 0;\n        this.actions = [];\n        this.animated = true;\n        this.initialMap = new Map();\n        this.finalMap = new Map();\n        this.initialLayoutInfo = new Map();\n        this.finalLayoutInfo = new Map();\n        this.removed = new Map();\n        this.toRemove = new Map();\n    }\n}\nclass $38b9490c1cca8fc4$export$89be5a243e59c4b2 {\n    _setContentSize(size) {\n        this._contentSize = size;\n        this.delegate.setContentSize(size);\n    }\n    _setContentOffset(offset) {\n        let rect = new (0, $60423f92c7f9ad87$export$c79fc6492f3af13d)(offset.x, offset.y, this._visibleRect.width, this._visibleRect.height);\n        this.delegate.setVisibleRect(rect);\n    }\n    /**\n   * Get the size of the scrollable content.\n   */ get contentSize() {\n        return this._contentSize;\n    }\n    /**\n   * Get the collection view's currently visible rectangle.\n   */ get visibleRect() {\n        return this._visibleRect;\n    }\n    /**\n   * Set the collection view's currently visible rectangle.\n   */ set visibleRect(rect) {\n        this._setVisibleRect(rect);\n    }\n    _setVisibleRect(rect, forceUpdate = false) {\n        let current = this._visibleRect;\n        // Ignore if the rects are equal\n        if (rect.equals(current)) return;\n        if (this.shouldOverscan) this._overscanManager.setVisibleRect(rect);\n        let shouldInvalidate = this.layout && this.layout.shouldInvalidate(rect, this._visibleRect);\n        this._resetAnimatedContentOffset();\n        this._visibleRect = rect;\n        if (shouldInvalidate) this.relayoutNow({\n            offsetChanged: !rect.pointEquals(current),\n            sizeChanged: !rect.sizeEquals(current)\n        });\n        else this.updateSubviews(forceUpdate);\n    }\n    get collection() {\n        return this._collection;\n    }\n    set collection(data) {\n        this._setData(data);\n    }\n    _setData(data) {\n        if (data === this._collection) return;\n        if (this._collection) this._runTransaction(()=>{\n            this._collection = data;\n        }, this.transitionDuration > 0);\n        else {\n            this._collection = data;\n            this.reloadData();\n        }\n    }\n    /**\n   * Reloads the data from the data source and relayouts the collection view.\n   * Does not animate any changes. Equivalent to re-assigning the same data source\n   * to the collection view.\n   */ reloadData() {\n        this.relayout({\n            contentChanged: true\n        });\n    }\n    /**\n   * Returns the item with the given key.\n   */ getItem(key) {\n        return this._collection ? this._collection.getItem(key) : null;\n    }\n    /** The set of persisted keys are always present in the DOM, even if not currently in view. */ get persistedKeys() {\n        return this._persistedKeys;\n    }\n    /** The set of persisted keys are always present in the DOM, even if not currently in view. */ set persistedKeys(persistedKeys) {\n        if (!(0, $fc36f9a046a9ce79$export$a8d0d0c8d1c5df64)(persistedKeys, this._persistedKeys)) {\n            this._persistedKeys = persistedKeys;\n            this.updateSubviews();\n        }\n    }\n    /** Returns whether the given key, or an ancestor, is persisted. */ isPersistedKey(key) {\n        // Quick check if the key is directly in the set of persisted keys.\n        if (this._persistedKeys.has(key)) return true;\n        // If not, check if the key is an ancestor of any of the persisted keys.\n        for (let k of this._persistedKeys)while(k != null){\n            let layoutInfo = this.layout.getLayoutInfo(k);\n            if (!layoutInfo) break;\n            k = layoutInfo.parentKey;\n            if (k === key) return true;\n        }\n        return false;\n    }\n    /**\n   * Get the collection view's layout.\n   */ get layout() {\n        return this._layout;\n    }\n    /**\n   * Set the collection view's layout.\n   */ set layout(layout) {\n        this.setLayout(layout);\n    }\n    /**\n   * Sets the collection view's layout, optionally with an animated transition\n   * from the current layout to the new layout.\n   * @param layout The layout to switch to.\n   * @param animated Whether to animate the layout change.\n   */ setLayout(layout, animated = false) {\n        if (layout === this._layout) return;\n        let applyLayout = ()=>{\n            if (this._layout) this._layout.virtualizer = null;\n            layout.virtualizer = this;\n            this._layout = layout;\n        };\n        if (animated) // We just set the layout inside a transaction action, which runs after the initial\n        // layout infos for the animation are retrieved from the previous layout. Then, the\n        // final layout infos are retrieved from the new layout, and animations occur.\n        this._runTransaction(applyLayout);\n        else {\n            applyLayout();\n            this.relayout();\n        }\n    }\n    _getReuseType(layoutInfo, content) {\n        if (layoutInfo.type === \"item\" && content) {\n            let type = this.delegate.getType ? this.delegate.getType(content) : \"item\";\n            let reuseType = type === \"item\" ? \"item\" : layoutInfo.type + \"_\" + type;\n            return {\n                type: type,\n                reuseType: reuseType\n            };\n        }\n        return {\n            type: layoutInfo.type,\n            reuseType: layoutInfo.type\n        };\n    }\n    getReusableView(layoutInfo) {\n        let content = this.getItem(layoutInfo.key);\n        let { reuseType: reuseType } = this._getReuseType(layoutInfo, content);\n        if (!this._reusableViews[reuseType]) this._reusableViews[reuseType] = [];\n        let reusable = this._reusableViews[reuseType];\n        let view = reusable.length > 0 ? reusable.pop() : new (0, $ad1d98aa8f0c31b4$export$1a5223887c560441)(this);\n        view.viewType = reuseType;\n        if (!this._animatedContentOffset.isOrigin()) {\n            layoutInfo = layoutInfo.copy();\n            layoutInfo.rect.x += this._animatedContentOffset.x;\n            layoutInfo.rect.y += this._animatedContentOffset.y;\n        }\n        view.layoutInfo = layoutInfo;\n        this._renderView(view);\n        return view;\n    }\n    _renderView(reusableView) {\n        let { type: type, key: key } = reusableView.layoutInfo;\n        reusableView.content = this.getItem(key);\n        reusableView.rendered = this._renderContent(type, reusableView.content);\n    }\n    _renderContent(type, content) {\n        let cached = this._renderedContent.get(content);\n        if (cached != null) return cached;\n        let rendered = this.delegate.renderView(type, content);\n        if (content) this._renderedContent.set(content, rendered);\n        return rendered;\n    }\n    /**\n   * Returns an array of all currently visible views, including both\n   * item views and supplementary views.\n   */ get visibleViews() {\n        return Array.from(this._visibleViews.values());\n    }\n    /**\n   * Gets the visible view for the given type and key. Returns null if\n   * the view is not currently visible.\n   *\n   * @param key The key of the view to retrieve.\n   */ getView(key) {\n        return this._visibleViews.get(key) || null;\n    }\n    /**\n   * Returns an array of visible views matching the given type.\n   * @param type The view type to find.\n   */ getViewsOfType(type) {\n        return this.visibleViews.filter((v)=>v.layoutInfo && v.layoutInfo.type === type);\n    }\n    /**\n   * Returns the key for the given view. Returns null\n   * if the view is not currently visible.\n   */ keyForView(view) {\n        if (view && view.layoutInfo) return view.layoutInfo.key;\n        return null;\n    }\n    /**\n   * Returns the key for the item view currently at the given point.\n   */ keyAtPoint(point) {\n        let rect = new (0, $60423f92c7f9ad87$export$c79fc6492f3af13d)(point.x, point.y, 1, 1);\n        let layoutInfos = this.layout.getVisibleLayoutInfos(rect);\n        // Layout may return multiple layout infos in the case of\n        // persisted keys, so find the first one that actually intersects.\n        for (let layoutInfo of layoutInfos){\n            if (layoutInfo.rect.intersects(rect)) return layoutInfo.key;\n        }\n        return null;\n    }\n    /**\n   * Cleanup for when the Virtualizer will be unmounted.\n   */ willUnmount() {\n        cancelAnimationFrame(this._relayoutRaf);\n    }\n    /**\n   * Triggers a layout invalidation, and updates the visible subviews.\n   */ relayout(context = {}) {\n        // Ignore relayouts while animating the scroll position\n        if (this._scrollAnimation || typeof requestAnimationFrame === \"undefined\") return;\n        // If we already scheduled a relayout, extend the invalidation\n        // context so we coalesce multiple relayouts in the same frame.\n        if (this._invalidationContext) {\n            Object.assign(this._invalidationContext, context);\n            return;\n        }\n        this._invalidationContext = context;\n    }\n    /**\n   * Performs a relayout immediately. Prefer {@link relayout} over this method\n   * where possible, since it coalesces multiple layout passes in the same tick.\n   */ relayoutNow(context = this._invalidationContext || {}) {\n        // Cancel the scheduled relayout, since we're doing it now.\n        if (this._relayoutRaf) {\n            cancelAnimationFrame(this._relayoutRaf);\n            this._relayoutRaf = null;\n            // Update the provided context with the current invalidationContext since we are cancelling\n            // a scheduled relayoutNow call that has this._invalidationContext set as its default context arg (relayoutNow() in relayout)\n            context = {\n                ...this._invalidationContext,\n                ...context\n            };\n        }\n        // Reset the invalidation context\n        this._invalidationContext = null;\n        // Do nothing if we don't have a layout or content, or we are\n        // in the middle of an animated scroll transition.\n        if (!this.layout || !this._collection || this._scrollAnimation) return;\n        let scrollAnchor = this._getScrollAnchor();\n        // Trigger the beforeLayout hook, if provided\n        if (typeof context.beforeLayout === \"function\") context.beforeLayout();\n        // Validate the layout\n        this.layout.validate(context);\n        this._setContentSize(this.layout.getContentSize());\n        // Trigger the afterLayout hook, if provided\n        if (typeof context.afterLayout === \"function\") context.afterLayout();\n        // Adjust scroll position based on scroll anchor, and constrain.\n        // If the content changed, scroll to the top.\n        let visibleRect = this.getVisibleRect();\n        let restoredScrollAnchor = this._restoreScrollAnchor(scrollAnchor, context);\n        let contentOffsetX = context.contentChanged ? 0 : restoredScrollAnchor.x;\n        let contentOffsetY = context.contentChanged ? 0 : restoredScrollAnchor.y;\n        contentOffsetX = Math.max(0, Math.min(this.contentSize.width - visibleRect.width, contentOffsetX));\n        contentOffsetY = Math.max(0, Math.min(this.contentSize.height - visibleRect.height, contentOffsetY));\n        let hasLayoutUpdates = false;\n        if (contentOffsetX !== visibleRect.x || contentOffsetY !== visibleRect.y) {\n            // If this is an animated relayout, we do not immediately scroll because it would be jittery.\n            // Save the difference between the current and new content offsets, and apply it to the\n            // individual content items instead. At the end of the animation, we'll reset and set the\n            // scroll offset for real. This ensures jitter-free animation since we don't need to sync\n            // the scroll animation and the content animation.\n            if (context.animated || !this._animatedContentOffset.isOrigin()) {\n                this._animatedContentOffset.x += visibleRect.x - contentOffsetX;\n                this._animatedContentOffset.y += visibleRect.y - contentOffsetY;\n                hasLayoutUpdates = this.updateSubviews(context.contentChanged);\n            } else this._setContentOffset(new (0, $3041db3296945e6e$export$baf26146a414f24a)(contentOffsetX, contentOffsetY));\n        } else hasLayoutUpdates = this.updateSubviews(context.contentChanged);\n        // Apply layout infos, unless this is coming from an animated transaction\n        if (!(context.transaction && context.animated)) this._applyLayoutInfos();\n        // Wait for animations, and apply the afterAnimation hook, if provided\n        if (context.animated && hasLayoutUpdates) {\n            this._enableTransitions();\n            let done = ()=>{\n                this._disableTransitions();\n                // Reset scroll position after animations (see above comment).\n                if (!this._animatedContentOffset.isOrigin()) {\n                    // Get the content offset to scroll to, taking _animatedContentOffset into account.\n                    let { x: x, y: y } = this.getVisibleRect();\n                    this._resetAnimatedContentOffset();\n                    this._setContentOffset(new (0, $3041db3296945e6e$export$baf26146a414f24a)(x, y));\n                }\n                if (typeof context.afterAnimation === \"function\") context.afterAnimation();\n            };\n            // Sometimes the animation takes slightly longer than expected.\n            setTimeout(done, this.transitionDuration + 100);\n            return;\n        } else if (typeof context.afterAnimation === \"function\") context.afterAnimation();\n    }\n    /**\n   * Corrects DOM order of visible views to match item order of collection.\n   */ _correctItemOrder() {\n        // Defer until after scrolling and animated transactions are complete\n        if (this._isScrolling || this._transaction) return;\n        for (let key of this._visibleLayoutInfos.keys()){\n            let view = this._visibleViews.get(key);\n            this._children.delete(view);\n            this._children.add(view);\n        }\n    }\n    _enableTransitions() {\n        this.delegate.beginAnimations();\n    }\n    _disableTransitions() {\n        this.delegate.endAnimations();\n    }\n    _getScrollAnchor() {\n        if (!this.anchorScrollPosition) return null;\n        let visibleRect = this.getVisibleRect();\n        // Ask the delegate to provide a scroll anchor, if possible\n        if (this.delegate.getScrollAnchor) {\n            let key = this.delegate.getScrollAnchor(visibleRect);\n            if (key != null) {\n                let layoutInfo = this.layout.getLayoutInfo(key);\n                let corner = layoutInfo.rect.getCornerInRect(visibleRect);\n                if (corner) {\n                    let key = layoutInfo.key;\n                    let offset = layoutInfo.rect[corner].y - visibleRect.y;\n                    return {\n                        key: key,\n                        layoutInfo: layoutInfo,\n                        corner: corner,\n                        offset: offset\n                    };\n                }\n            }\n        }\n        // No need to anchor the scroll position if it is at the top\n        if (visibleRect.y === 0 && !this.anchorScrollPositionAtTop) return null;\n        // Find a view with a visible corner that has the smallest distance to the top of the collection view\n        let cornerAnchor = null;\n        for (let [key, view] of this._visibleViews){\n            let layoutInfo = view.layoutInfo;\n            if (layoutInfo && layoutInfo.rect.area > 0) {\n                let corner = layoutInfo.rect.getCornerInRect(visibleRect);\n                if (corner) {\n                    let offset = layoutInfo.rect[corner].y - visibleRect.y;\n                    if (!cornerAnchor || offset < cornerAnchor.offset) cornerAnchor = {\n                        key: key,\n                        layoutInfo: layoutInfo,\n                        corner: corner,\n                        offset: offset\n                    };\n                }\n            }\n        }\n        return cornerAnchor;\n    }\n    _restoreScrollAnchor(scrollAnchor, context) {\n        let contentOffset = this.getVisibleRect();\n        if (scrollAnchor) {\n            var _context_transaction;\n            let finalAnchor = ((_context_transaction = context.transaction) === null || _context_transaction === void 0 ? void 0 : _context_transaction.animated) ? context.transaction.finalMap.get(scrollAnchor.key) : this.layout.getLayoutInfo(scrollAnchor.layoutInfo.key);\n            if (finalAnchor) {\n                let adjustment = finalAnchor.rect[scrollAnchor.corner].y - contentOffset.y - scrollAnchor.offset;\n                contentOffset.y += adjustment;\n            }\n        }\n        return contentOffset;\n    }\n    getVisibleRect() {\n        let v = this.visibleRect;\n        let x = v.x - this._animatedContentOffset.x;\n        let y = v.y - this._animatedContentOffset.y;\n        return new (0, $60423f92c7f9ad87$export$c79fc6492f3af13d)(x, y, v.width, v.height);\n    }\n    getVisibleLayoutInfos() {\n        let rect = this.shouldOverscan ? this._overscanManager.getOverscannedRect() : this.getVisibleRect();\n        this._visibleLayoutInfos = this._getLayoutInfoMap(rect);\n        return this._visibleLayoutInfos;\n    }\n    _getLayoutInfoMap(rect, copy = false) {\n        let layoutInfos = this.layout.getVisibleLayoutInfos(rect);\n        let map = new Map;\n        for (let layoutInfo of layoutInfos){\n            if (copy) layoutInfo = layoutInfo.copy();\n            map.set(layoutInfo.key, layoutInfo);\n        }\n        return map;\n    }\n    updateSubviews(forceUpdate = false) {\n        if (!this._collection) return;\n        let visibleLayoutInfos = this.getVisibleLayoutInfos();\n        let currentlyVisible = this._visibleViews;\n        let toAdd, toRemove, toUpdate;\n        // If this is a force update, remove and re-add all views.\n        // Otherwise, find and update the diff.\n        if (forceUpdate) {\n            toAdd = visibleLayoutInfos;\n            toRemove = currentlyVisible;\n            toUpdate = new Set();\n        } else {\n            ({ toAdd: toAdd, toRemove: toRemove, toUpdate: toUpdate } = (0, $fc36f9a046a9ce79$export$acaf96a27438246b)(currentlyVisible, visibleLayoutInfos));\n            for (let key of toUpdate){\n                let view = currentlyVisible.get(key);\n                if (!view || !view.layoutInfo) continue;\n                let item = this.getItem(visibleLayoutInfos.get(key).key);\n                if (view.content === item) toUpdate.delete(key);\n                else {\n                    // If the view type changes, delete and recreate the view instead of updating\n                    let { reuseType: reuseType } = this._getReuseType(view.layoutInfo, item);\n                    if (view.viewType !== reuseType) {\n                        toUpdate.delete(key);\n                        toAdd.add(key);\n                        toRemove.add(key);\n                    }\n                }\n            }\n            // We are done if the sets are equal\n            if (toAdd.size === 0 && toRemove.size === 0 && toUpdate.size === 0) {\n                if (this._transaction) this._applyLayoutInfos();\n                return;\n            }\n        }\n        // Track views that should be removed. They are not removed from\n        // the DOM immediately, since we may reuse and need to re-insert\n        // them back into the DOM anyway.\n        let removed = new Set();\n        for (let key of toRemove.keys()){\n            let view = this._visibleViews.get(key);\n            if (view) {\n                removed.add(view);\n                this._visibleViews.delete(key);\n                // If we are in the middle of a transaction, wait until the end\n                // of the animations to remove the views from the DOM. Also means\n                // we can't reuse those views immediately.\n                if (this._transaction) this._transaction.toRemove.set(key, view);\n                else this.reuseView(view);\n            }\n        }\n        for (let key of toAdd.keys()){\n            let layoutInfo = visibleLayoutInfos.get(key);\n            let view;\n            // If we're in a transaction, and a layout change happens\n            // during the animations such that a view that was going\n            // to be removed is now not, we don't create a new view\n            // since the old one is still in the DOM, marked as toRemove.\n            if (this._transaction) {\n                // if transaction, get initial layout attributes for the animation\n                if (this._transaction.initialLayoutInfo.has(key)) layoutInfo = this._transaction.initialLayoutInfo.get(key);\n                view = this._transaction.toRemove.get(key);\n                if (view) {\n                    this._transaction.toRemove.delete(key);\n                    this._applyLayoutInfo(view, layoutInfo);\n                }\n            }\n            if (!view) {\n                // Create or reuse a view for this row\n                view = this.getReusableView(layoutInfo);\n                // Add the view to the DOM if needed\n                if (!removed.has(view)) this._children.add(view);\n            }\n            this._visibleViews.set(key, view);\n            removed.delete(view);\n        }\n        for (let key of toUpdate){\n            let view = currentlyVisible.get(key);\n            this._renderedContent.delete(key);\n            this._renderView(view);\n        }\n        // Remove the remaining rows to delete from the DOM\n        if (!this._transaction) this.removeViews(removed);\n        this._correctItemOrder();\n        this._flushVisibleViews();\n        let hasLayoutUpdates = this._transaction && (toAdd.size > 0 || toRemove.size > 0 || this._hasLayoutUpdates());\n        if (hasLayoutUpdates) requestAnimationFrame(()=>{\n            // If we're in a transaction, apply animations to visible views\n            // and \"to be removed\" views, which animate off screen.\n            if (this._transaction) requestAnimationFrame(()=>this._applyLayoutInfos());\n        });\n        return hasLayoutUpdates;\n    }\n    afterRender() {\n        if (this._transactionQueue.length > 0) this._processTransactionQueue();\n        else if (this._invalidationContext) this.relayoutNow();\n        if (this.shouldOverscan) this._overscanManager.collectMetrics();\n    }\n    _flushVisibleViews() {\n        // CollectionVirtualizer deals with a flattened set of LayoutInfos, but they can represent heirarchy\n        // by referencing a parentKey. Just before rendering the visible views, we rebuild this heirarchy\n        // by creating a mapping of views by parent key and recursively calling the delegate's renderWrapper\n        // method to build the final tree.\n        let viewsByParentKey = new Map([\n            [\n                null,\n                []\n            ]\n        ]);\n        for (let view of this._children){\n            var _view_layoutInfo, _viewsByParentKey_get, _view_layoutInfo1, _view_layoutInfo2, _view_layoutInfo3;\n            if (((_view_layoutInfo = view.layoutInfo) === null || _view_layoutInfo === void 0 ? void 0 : _view_layoutInfo.parentKey) != null && !viewsByParentKey.has(view.layoutInfo.parentKey)) viewsByParentKey.set(view.layoutInfo.parentKey, []);\n            (_viewsByParentKey_get = viewsByParentKey.get((_view_layoutInfo1 = view.layoutInfo) === null || _view_layoutInfo1 === void 0 ? void 0 : _view_layoutInfo1.parentKey)) === null || _viewsByParentKey_get === void 0 ? void 0 : _viewsByParentKey_get.push(view);\n            if (!viewsByParentKey.has((_view_layoutInfo2 = view.layoutInfo) === null || _view_layoutInfo2 === void 0 ? void 0 : _view_layoutInfo2.key)) viewsByParentKey.set((_view_layoutInfo3 = view.layoutInfo) === null || _view_layoutInfo3 === void 0 ? void 0 : _view_layoutInfo3.key, []);\n        }\n        let buildTree = (parent, views)=>views.map((view)=>{\n                let children = viewsByParentKey.get(view.layoutInfo.key);\n                return this.delegate.renderWrapper(parent, view, children, (childViews)=>buildTree(view, childViews));\n            });\n        let children = buildTree(null, viewsByParentKey.get(null));\n        this.delegate.setVisibleViews(children);\n    }\n    _applyLayoutInfo(view, layoutInfo) {\n        if (view.layoutInfo === layoutInfo) return false;\n        view.layoutInfo = layoutInfo;\n        return true;\n    }\n    _applyLayoutInfos() {\n        let updated = false;\n        // Apply layout infos to visible views\n        for (let view of this._visibleViews.values()){\n            let cur = view.layoutInfo;\n            if ((cur === null || cur === void 0 ? void 0 : cur.key) != null) {\n                let layoutInfo = this.layout.getLayoutInfo(cur.key);\n                if (this._applyLayoutInfo(view, layoutInfo)) updated = true;\n            }\n        }\n        // Apply final layout infos for views that will be removed\n        if (this._transaction) {\n            for (let view of this._transaction.toRemove.values()){\n                let cur = view.layoutInfo;\n                if ((cur === null || cur === void 0 ? void 0 : cur.key) != null) {\n                    let layoutInfo = this.layout.getLayoutInfo(cur.key);\n                    if (this._applyLayoutInfo(view, layoutInfo)) updated = true;\n                }\n            }\n            for (let view of this._transaction.removed.values()){\n                let cur = view.layoutInfo;\n                let layoutInfo = this._transaction.finalLayoutInfo.get(cur.key) || cur;\n                layoutInfo = this.layout.getFinalLayoutInfo(layoutInfo.copy());\n                if (this._applyLayoutInfo(view, layoutInfo)) updated = true;\n            }\n        }\n        if (updated) this._flushVisibleViews();\n    }\n    _hasLayoutUpdates() {\n        if (!this._transaction) return false;\n        for (let view of this._visibleViews.values()){\n            let cur = view.layoutInfo;\n            if (!cur) return true;\n            let layoutInfo = this.layout.getLayoutInfo(cur.key);\n            if (!cur.rect.equals(layoutInfo.rect) || cur.opacity !== layoutInfo.opacity || cur.transform !== layoutInfo.transform) return true;\n        }\n        return false;\n    }\n    reuseView(view) {\n        view.prepareForReuse();\n        this._reusableViews[view.viewType].push(view);\n    }\n    removeViews(toRemove) {\n        for (let view of toRemove)this._children.delete(view);\n    }\n    updateItemSize(key, size) {\n        // TODO: we should be able to invalidate a single index path\n        // @ts-ignore\n        if (!this.layout.updateItemSize) return;\n        // If the scroll position is currently animating, add the update\n        // to a queue to be processed after the animation is complete.\n        if (this._scrollAnimation) {\n            this._sizeUpdateQueue.set(key, size);\n            return;\n        }\n        // @ts-ignore\n        let changed = this.layout.updateItemSize(key, size);\n        if (changed) this.relayout();\n    }\n    startScrolling() {\n        this._isScrolling = true;\n    }\n    endScrolling() {\n        this._isScrolling = false;\n        this._correctItemOrder();\n        this._flushVisibleViews();\n    }\n    _resetAnimatedContentOffset() {\n        // Reset the animated content offset of subviews. See comment in relayoutNow for details.\n        if (!this._animatedContentOffset.isOrigin()) {\n            this._animatedContentOffset = new (0, $3041db3296945e6e$export$baf26146a414f24a)(0, 0);\n            this._applyLayoutInfos();\n        }\n    }\n    /**\n   * Scrolls the item with the given key into view, optionally with an animation.\n   * @param key The key of the item to scroll into view.\n   * @param duration The duration of the scroll animation.\n   */ scrollToItem(key, options) {\n        // key can be 0, so check if null or undefined\n        if (key == null) return;\n        let layoutInfo = this.layout.getLayoutInfo(key);\n        if (!layoutInfo) return;\n        let { duration: duration = 300, shouldScrollX: shouldScrollX = true, shouldScrollY: shouldScrollY = true, offsetX: offsetX = 0, offsetY: offsetY = 0 } = options;\n        let x = this.visibleRect.x;\n        let y = this.visibleRect.y;\n        let minX = layoutInfo.rect.x - offsetX;\n        let minY = layoutInfo.rect.y - offsetY;\n        let maxX = x + this.visibleRect.width;\n        let maxY = y + this.visibleRect.height;\n        if (shouldScrollX) {\n            if (minX <= x || maxX === 0) x = minX;\n            else if (layoutInfo.rect.maxX > maxX) x += layoutInfo.rect.maxX - maxX;\n        }\n        if (shouldScrollY) {\n            if (minY <= y || maxY === 0) y = minY;\n            else if (layoutInfo.rect.maxY > maxY) y += layoutInfo.rect.maxY - maxY;\n        }\n        return this.scrollTo(new (0, $3041db3296945e6e$export$baf26146a414f24a)(x, y), duration);\n    }\n    /**\n   * Performs an animated scroll to the given offset.\n   * @param offset - The offset to scroll to.\n   * @param duration The duration of the animation.\n   * @returns A promise that resolves when the animation is complete.\n   */ scrollTo(offset, duration = 300) {\n        // Cancel the current scroll animation\n        if (this._scrollAnimation) {\n            this._scrollAnimation.cancel();\n            this._scrollAnimation = null;\n        }\n        // Set the content offset synchronously if the duration is zero\n        if (duration <= 0 || this.visibleRect.pointEquals(offset)) {\n            this._setContentOffset(offset);\n            return Promise.resolve();\n        }\n        this.startScrolling();\n        this._scrollAnimation = (0, $3eb131dcf37ad5f8$export$dc0b63720788090c)(this.visibleRect, offset, duration, (0, $3eb131dcf37ad5f8$export$57636bb43b1ccbb0), (offset)=>{\n            this._setContentOffset(offset);\n        });\n        this._scrollAnimation.then(()=>{\n            this._scrollAnimation = null;\n            // Process view size updates that occurred during the animation.\n            // Only views that are still visible will be actually updated.\n            for (let [key, size] of this._sizeUpdateQueue)this.updateItemSize(key, size);\n            this._sizeUpdateQueue.clear();\n            this.relayout();\n            this._processTransactionQueue();\n            this.endScrolling();\n        });\n        return this._scrollAnimation;\n    }\n    _runTransaction(action, animated) {\n        this._startTransaction();\n        if (this._nextTransaction) this._nextTransaction.actions.push(action);\n        this._endTransaction(animated);\n    }\n    _startTransaction() {\n        if (!this._nextTransaction) this._nextTransaction = new (0, $8e135e531d8dcb66$export$febc5573c75cefb0);\n        this._nextTransaction.level++;\n    }\n    _endTransaction(animated) {\n        if (!this._nextTransaction) return false;\n        // Save whether the transaction should be animated.\n        if (animated != null) this._nextTransaction.animated = animated;\n        // If we haven't reached level 0, we are still in a\n        // nested transaction. Wait for the parent to end.\n        if (--this._nextTransaction.level > 0) return false;\n        // Do nothing for empty transactions\n        if (this._nextTransaction.actions.length === 0) {\n            this._nextTransaction = null;\n            return false;\n        }\n        // Default animations to true\n        if (this._nextTransaction.animated == null) this._nextTransaction.animated = true;\n        // Enqueue the transaction\n        this._transactionQueue.push(this._nextTransaction);\n        this._nextTransaction = null;\n        return true;\n    }\n    _processTransactionQueue() {\n        // If the current transaction is animating, wait until the end\n        // to process the next transaction.\n        if (this._transaction || this._scrollAnimation) return;\n        let next = this._transactionQueue.shift();\n        if (next) this._performTransaction(next);\n    }\n    _getContentRect() {\n        return new (0, $60423f92c7f9ad87$export$c79fc6492f3af13d)(0, 0, this.contentSize.width, this.contentSize.height);\n    }\n    _performTransaction(transaction) {\n        this._transaction = transaction;\n        this.relayoutNow({\n            transaction: transaction,\n            animated: transaction.animated,\n            beforeLayout: ()=>{\n                // Get the initial layout infos for all views before the updates\n                // so we can figure out which views to add and remove.\n                if (transaction.animated) transaction.initialMap = this._getLayoutInfoMap(this._getContentRect(), true);\n                // Apply the actions that occurred during this transaction\n                for (let action of transaction.actions)action();\n            },\n            afterLayout: ()=>{\n                // Get the final layout infos after the updates\n                if (transaction.animated) {\n                    transaction.finalMap = this._getLayoutInfoMap(this._getContentRect());\n                    this._setupTransactionAnimations(transaction);\n                } else this._transaction = null;\n            },\n            afterAnimation: ()=>{\n                // Remove and reuse views when animations are done\n                if (transaction.toRemove.size > 0 || transaction.removed.size > 0) for (let view of (0, $fc36f9a046a9ce79$export$cfc14088dfefce5f)(transaction.toRemove.values(), transaction.removed.values())){\n                    this._children.delete(view);\n                    this.reuseView(view);\n                }\n                this._transaction = null;\n                // Ensure DOM order is correct for accessibility after animations are complete\n                this._correctItemOrder();\n                this._flushVisibleViews();\n                this._processTransactionQueue();\n            }\n        });\n    }\n    _setupTransactionAnimations(transaction) {\n        let { initialMap: initialMap, finalMap: finalMap } = transaction;\n        // Store initial and final layout infos for animations\n        for (let [key, layoutInfo] of initialMap)if (finalMap.has(key)) transaction.initialLayoutInfo.set(key, layoutInfo);\n        else // in Layout#getFinalLayoutInfo during animations.\n        transaction.finalLayoutInfo.set(layoutInfo.key, layoutInfo);\n        // Get initial layout infos for views that were added\n        for (let [key, layoutInfo] of finalMap)if (!initialMap.has(key)) {\n            let initialLayoutInfo = this.layout.getInitialLayoutInfo(layoutInfo.copy());\n            transaction.initialLayoutInfo.set(key, initialLayoutInfo);\n        }\n        // Figure out which views were removed.\n        for (let [key, view] of this._visibleViews)// Removing an item with  width of 0 can cause a loop where the item gets added, removed,\n        // added, removed... etc in a loop.\n        if (!finalMap.has(key) && view.layoutInfo.rect.width > 0) {\n            transaction.removed.set(key, view);\n            this._visibleViews.delete(key);\n            // In case something weird happened, where we have a view but no\n            // initial layout info, use the one attached to the view.\n            if (view.layoutInfo) {\n                if (!transaction.finalLayoutInfo.has(view.layoutInfo.key)) transaction.finalLayoutInfo.set(view.layoutInfo.key, view.layoutInfo);\n            }\n        }\n    }\n    constructor(options = {}){\n        this._contentSize = new (0, $ee1bfa90a957fb8a$export$cb6da89c6af1a8ec);\n        this._visibleRect = new (0, $60423f92c7f9ad87$export$c79fc6492f3af13d);\n        this._reusableViews = {};\n        this._visibleLayoutInfos = new Map();\n        this._visibleViews = new Map();\n        this._renderedContent = new WeakMap();\n        this._children = new Set();\n        this._invalidationContext = null;\n        this._overscanManager = new (0, $364191b3decf3697$export$4455ee6afb38dcbb)();\n        this._persistedKeys = new Set();\n        this._scrollAnimation = null;\n        this._isScrolling = false;\n        this._sizeUpdateQueue = new Map();\n        this._animatedContentOffset = new (0, $3041db3296945e6e$export$baf26146a414f24a)(0, 0);\n        this._transaction = null;\n        this._nextTransaction = null;\n        this._transactionQueue = [];\n        var _options_transitionDuration;\n        // Set options from passed object if given\n        this.transitionDuration = (_options_transitionDuration = options.transitionDuration) !== null && _options_transitionDuration !== void 0 ? _options_transitionDuration : 500;\n        this.anchorScrollPosition = options.anchorScrollPosition || false;\n        this.anchorScrollPositionAtTop = options.anchorScrollPositionAtTop || false;\n        this.shouldOverscan = options.shouldOverscan !== false;\n        for (let key of [\n            \"delegate\",\n            \"size\",\n            \"layout\",\n            \"collection\"\n        ])if (options[key]) this[key] = options[key];\n    }\n}\nfunction $fc0b13b484ac1194$export$1505db82fe357e65(opts) {\n    let [visibleViews, setVisibleViews] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    let [contentSize, setContentSize] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(new (0, $ee1bfa90a957fb8a$export$cb6da89c6af1a8ec)());\n    let [isAnimating, setAnimating] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    let [isScrolling, setScrolling] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    let virtualizer = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>new (0, $38b9490c1cca8fc4$export$89be5a243e59c4b2)(), []);\n    virtualizer.delegate = {\n        setVisibleViews: setVisibleViews,\n        setVisibleRect (rect) {\n            virtualizer.visibleRect = rect;\n            opts.onVisibleRectChange(rect);\n        },\n        setContentSize: setContentSize,\n        renderView: opts.renderView,\n        renderWrapper: opts.renderWrapper,\n        beginAnimations: ()=>setAnimating(true),\n        endAnimations: ()=>setAnimating(false),\n        getScrollAnchor: opts.getScrollAnchor\n    };\n    virtualizer.layout = opts.layout;\n    virtualizer.collection = opts.collection;\n    virtualizer.transitionDuration = opts.transitionDuration;\n    (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.useLayoutEffect)(()=>{\n        virtualizer.afterRender();\n    });\n    // eslint-disable-next-line arrow-body-style\n    (0, react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        return ()=>virtualizer.willUnmount();\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, []);\n    let setVisibleRect = (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((rect)=>{\n        virtualizer.visibleRect = rect;\n    }, [\n        virtualizer\n    ]);\n    let startScrolling = (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        virtualizer.startScrolling();\n        setScrolling(true);\n    }, [\n        virtualizer\n    ]);\n    let endScrolling = (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        virtualizer.endScrolling();\n        setScrolling(false);\n    }, [\n        virtualizer\n    ]);\n    let state = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>({\n            virtualizer: virtualizer,\n            visibleViews: visibleViews,\n            setVisibleRect: setVisibleRect,\n            contentSize: contentSize,\n            isAnimating: isAnimating,\n            isScrolling: isScrolling,\n            startScrolling: startScrolling,\n            endScrolling: endScrolling\n        }), [\n        virtualizer,\n        visibleViews,\n        setVisibleRect,\n        contentSize,\n        isAnimating,\n        isScrolling,\n        startScrolling,\n        endScrolling\n    ]);\n    return state;\n}\n //# sourceMappingURL=module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXN0YXRlbHkvdmlydHVhbGl6ZXIvZGlzdC9pbXBvcnQubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUErSTtBQUNuRTtBQUU1RTs7Ozs7Ozs7OztDQVVDLEdBQUc7Ozs7Ozs7Ozs7Q0FVSCxHQUFHLE1BQU1VO0lBQ047Ozs7O0dBS0QsR0FBR0MsaUJBQWlCQyxPQUFPLEVBQUVDLE9BQU8sRUFBRTtRQUNqQywrQ0FBK0M7UUFDL0MsT0FBT0QsUUFBUUUsS0FBSyxLQUFLRCxRQUFRQyxLQUFLLElBQUlGLFFBQVFHLE1BQU0sS0FBS0YsUUFBUUUsTUFBTTtJQUMvRTtJQUNBOzs7OztHQUtELEdBQUdDLFNBQVNDLG1CQUFtQixFQUFFLENBQUM7SUFDakM7Ozs7R0FJRCxHQUFHLG1EQUFtRDtJQUNyRCxxREFBcUQ7SUFDckQsbUJBQW1CO0lBQ25CLG1CQUFtQjtJQUNuQixNQUFNO0lBQ04sYUFBYTtJQUNiLG9CQUFvQjtJQUNwQixrQkFBa0I7SUFDbEIsT0FBTztJQUNQLElBQUk7SUFDSjs7OztHQUlELEdBQUcsbURBQW1EO0lBQ3JELGlCQUFpQjtJQUNqQixJQUFJO0lBQ0o7Ozs7OztHQU1ELEdBQUdDLHFCQUFxQkMsVUFBVSxFQUFFO1FBQy9CLE9BQU9BO0lBQ1g7SUFDQTs7Ozs7O0dBTUQsR0FBR0MsbUJBQW1CRCxVQUFVLEVBQUU7UUFDN0IsT0FBT0E7SUFDWDtBQUNKO0FBR0E7Ozs7Ozs7Ozs7Q0FVQyxHQUFHLE1BQU1FO0lBQ047O0dBRUQsR0FBR0MsT0FBTztRQUNMLElBQUlDLE1BQU0sSUFBSUYsMENBQTBDLElBQUksQ0FBQ0csSUFBSSxFQUFFLElBQUksQ0FBQ0MsR0FBRyxFQUFFLElBQUksQ0FBQ0MsSUFBSSxDQUFDSixJQUFJO1FBQzNGQyxJQUFJSSxhQUFhLEdBQUcsSUFBSSxDQUFDQSxhQUFhO1FBQ3RDSixJQUFJSyxPQUFPLEdBQUcsSUFBSSxDQUFDQSxPQUFPO1FBQzFCTCxJQUFJTSxTQUFT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LDhDQUFpQixFQUFHLENBQUNtQjtRQUMxQzBDLFlBQVlrRSxXQUFXLEdBQUc1RztJQUM5QixHQUFHO1FBQ0MwQztLQUNIO0lBQ0QsSUFBSXVPLGlCQUFpQixDQUFDLEdBQUdwUyw4Q0FBaUIsRUFBRztRQUN6QzZELFlBQVl1TyxjQUFjO1FBQzFCNkIsYUFBYTtJQUNqQixHQUFHO1FBQ0NwUTtLQUNIO0lBQ0QsSUFBSXdPLGVBQWUsQ0FBQyxHQUFHclMsOENBQWlCLEVBQUc7UUFDdkM2RCxZQUFZd08sWUFBWTtRQUN4QjRCLGFBQWE7SUFDakIsR0FBRztRQUNDcFE7S0FDSDtJQUNELElBQUlzUSxRQUFRLENBQUMsR0FBR3ZVLDBDQUFhLEVBQUcsSUFBSztZQUM3QmlFLGFBQWFBO1lBQ2JnSixjQUFjQTtZQUNkbEYsZ0JBQWdCQTtZQUNoQmlDLGFBQWFBO1lBQ2JrSyxhQUFhQTtZQUNiRSxhQUFhQTtZQUNiNUIsZ0JBQWdCQTtZQUNoQkMsY0FBY0E7UUFDbEIsSUFBSTtRQUNKeE87UUFDQWdKO1FBQ0FsRjtRQUNBaUM7UUFDQWtLO1FBQ0FFO1FBQ0E1QjtRQUNBQztLQUNIO0lBQ0QsT0FBTzhCO0FBQ1g7QUFLNFksQ0FDNVksa0NBQWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1mbGFzay8uL25vZGVfbW9kdWxlcy9AcmVhY3Qtc3RhdGVseS92aXJ0dWFsaXplci9kaXN0L2ltcG9ydC5tanM/ZTlhMSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge3VzZVN0YXRlIGFzICQ4RDNuciR1c2VTdGF0ZSwgdXNlTWVtbyBhcyAkOEQzbnIkdXNlTWVtbywgdXNlRWZmZWN0IGFzICQ4RDNuciR1c2VFZmZlY3QsIHVzZUNhbGxiYWNrIGFzICQ4RDNuciR1c2VDYWxsYmFja30gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQge3VzZUxheW91dEVmZmVjdCBhcyAkOEQzbnIkdXNlTGF5b3V0RWZmZWN0fSBmcm9tIFwiQHJlYWN0LWFyaWEvdXRpbHNcIjtcblxuLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIC8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyBjbGFzcyAkYzc0Y2RhN2QzMWFmMTI1MyRleHBvcnQkYzg0NjcxZjQ2ZDZhMWNhIHtcbiAgICAvKipcbiAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBsYXlvdXQgc2hvdWxkIGludmFsaWRhdGUgaW4gcmVzcG9uc2UgdG9cbiAgICogdmlzaWJsZSByZWN0YW5nbGUgY2hhbmdlcy4gQnkgZGVmYXVsdCwgaXQgb25seSBpbnZhbGlkYXRlc1xuICAgKiB3aGVuIHRoZSBjb2xsZWN0aW9uIHZpZXcncyBzaXplIGNoYW5nZXMuIFJldHVybiB0cnVlIGFsd2F5c1xuICAgKiB0byBtYWtlIHRoZSBsYXlvdXQgaW52YWxpZGF0ZSB3aGlsZSBzY3JvbGxpbmcgKGUuZy4gc3RpY2t5IGhlYWRlcnMpLlxuICAgKi8gc2hvdWxkSW52YWxpZGF0ZShuZXdSZWN0LCBvbGRSZWN0KSB7XG4gICAgICAgIC8vIEJ5IGRlZmF1bHQsIGludmFsaWRhdGUgd2hlbiB0aGUgc2l6ZSBjaGFuZ2VzXG4gICAgICAgIHJldHVybiBuZXdSZWN0LndpZHRoICE9PSBvbGRSZWN0LndpZHRoIHx8IG5ld1JlY3QuaGVpZ2h0ICE9PSBvbGRSZWN0LmhlaWdodDtcbiAgICB9XG4gICAgLyoqXG4gICAqIFRoaXMgbWV0aG9kIGFsbG93cyB0aGUgbGF5b3V0IHRvIHBlcmZvcm0gYW55IHByZS1jb21wdXRhdGlvblxuICAgKiBpdCBuZWVkcyB0byBpbiBvcmRlciB0byBwcmVwYXJlIHtAbGluayBMYXlvdXRJbmZvfXMgZm9yIHJldHJpZXZhbC5cbiAgICogQ2FsbGVkIGJ5IHRoZSBjb2xsZWN0aW9uIHZpZXcgYmVmb3JlIHtAbGluayBnZXRWaXNpYmxlTGF5b3V0SW5mb3N9XG4gICAqIG9yIHtAbGluayBnZXRMYXlvdXRJbmZvfSBhcmUgY2FsbGVkLlxuICAgKi8gdmFsaWRhdGUoaW52YWxpZGF0aW9uQ29udGV4dCkge31cbiAgICAvKipcbiAgICogUmV0dXJucyBhIHtAbGluayBEcmFnVGFyZ2V0fSBkZXNjcmliaW5nIGEgdmlldyBhdCB0aGUgZ2l2ZW4gcG9pbnQgdG8gYmUgZHJhZ2dlZC5cbiAgICogUmV0dXJuIGBudWxsYCB0byBjYW5jZWwgdGhlIGRyYWcuIFRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIHJldHVybnMgdGhlIHZpZXcgYXQgdGhlIGdpdmVuIHBvaW50LlxuICAgKiBAcGFyYW0gcG9pbnQgVGhlIHBvaW50IGF0IHdoaWNoIHRoZSBkcmFnIG9jY3VycmVkLlxuICAgKi8gLy8gZ2V0RHJhZ1RhcmdldChwb2ludDogUG9pbnQpOiBEcmFnVGFyZ2V0IHwgbnVsbCB7XG4gICAgLy8gICBsZXQgdGFyZ2V0ID0gdGhpcy52aXJ0dWFsaXplci5rZXlBdFBvaW50KHBvaW50KTtcbiAgICAvLyAgIGlmICghdGFyZ2V0KSB7XG4gICAgLy8gICAgIHJldHVybiBudWxsO1xuICAgIC8vICAgfVxuICAgIC8vICAgcmV0dXJuIHtcbiAgICAvLyAgICAgdHlwZTogJ2l0ZW0nLFxuICAgIC8vICAgICBrZXk6IHRhcmdldFxuICAgIC8vICAgfTtcbiAgICAvLyB9XG4gICAgLyoqXG4gICAqIFJldHVybnMgYSB7QGxpbmsgRHJhZ1RhcmdldH0gb2JqZWN0IGRlc2NyaWJpbmcgd2hlcmUgYSBkcm9wIHNob3VsZCBvY2N1ci4gUmV0dXJuIGBudWxsYFxuICAgKiB0byByZWplY3QgdGhlIGRyb3AuIFRoZSBkcm9wcGVkIGl0ZW1zIHdpbGwgYmUgaW5zZXJ0ZWQgYmVmb3JlIHRoZSByZXN1bHRpbmcgdGFyZ2V0LlxuICAgKiBAcGFyYW0gcG9pbnQgVGhlIHBvaW50IGF0IHdoaWNoIHRoZSBkcm9wIG9jY3VycmVkLlxuICAgKi8gLy8gZ2V0RHJvcFRhcmdldChwb2ludDogUG9pbnQpOiBEcm9wVGFyZ2V0IHwgbnVsbCB7XG4gICAgLy8gICByZXR1cm4gbnVsbDtcbiAgICAvLyB9XG4gICAgLyoqXG4gICAqIFJldHVybnMgdGhlIHN0YXJ0aW5nIGF0dHJpYnV0ZXMgZm9yIGFuIGFuaW1hdGVkIGluc2VydGlvbi5cbiAgICogVGhlIHZpZXcgaXMgYW5pbWF0ZWQgZnJvbSB0aGlzIHtAbGluayBMYXlvdXRJbmZvfSB0byB0aGUgb25lIHJldHVybmVkIGJ5IHtAbGluayBnZXRMYXlvdXRJbmZvfS5cbiAgICogVGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24ganVzdCByZXR1cm5zIGl0cyBpbnB1dC5cbiAgICpcbiAgICogQHBhcmFtIGxheW91dEluZm8gVGhlIHByb3Bvc2VkIExheW91dEluZm8gZm9yIHRoaXMgdmlldy5cbiAgICovIGdldEluaXRpYWxMYXlvdXRJbmZvKGxheW91dEluZm8pIHtcbiAgICAgICAgcmV0dXJuIGxheW91dEluZm87XG4gICAgfVxuICAgIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBlbmRpbmcgYXR0cmlidXRlcyBmb3IgYW4gYW5pbWF0ZWQgcmVtb3ZhbC5cbiAgICogVGhlIHZpZXcgaXMgYW5pbWF0ZWQgZnJvbSB0aGUge0BsaW5rIExheW91dEluZm99IHJldHVybmVkIGJ5IHtAbGluayBnZXRMYXlvdXRJbmZvfVxuICAgKiB0byB0aGUgb25lIHJldHVybmVkIGJ5IHRoaXMgbWV0aG9kLiBUaGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiByZXR1cm5zIGl0cyBpbnB1dC5cbiAgICpcbiAgICogQHBhcmFtIGxheW91dEluZm8gVGhlIG9yaWdpbmFsIExheW91dEluZm8gZm9yIHRoaXMgdmlldy5cbiAgICovIGdldEZpbmFsTGF5b3V0SW5mbyhsYXlvdXRJbmZvKSB7XG4gICAgICAgIHJldHVybiBsYXlvdXRJbmZvO1xuICAgIH1cbn1cblxuXG4vKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gY2xhc3MgJGQ3ZmQ2MTAwOWMyMWQwYmIkZXhwb3J0JDdlMGVlYjlkYTcwMmEwODUge1xuICAgIC8qKlxuICAgKiBSZXR1cm5zIGEgY29weSBvZiB0aGUgTGF5b3V0SW5mby5cbiAgICovIGNvcHkoKSB7XG4gICAgICAgIGxldCByZXMgPSBuZXcgJGQ3ZmQ2MTAwOWMyMWQwYmIkZXhwb3J0JDdlMGVlYjlkYTcwMmEwODUodGhpcy50eXBlLCB0aGlzLmtleSwgdGhpcy5yZWN0LmNvcHkoKSk7XG4gICAgICAgIHJlcy5lc3RpbWF0ZWRTaXplID0gdGhpcy5lc3RpbWF0ZWRTaXplO1xuICAgICAgICByZXMub3BhY2l0eSA9IHRoaXMub3BhY2l0eTtcbiAgICAgICAgcmVzLnRyYW5zZm9ybSA9IHRoaXMudHJhbnNmb3JtO1xuICAgICAgICByZXMucGFyZW50S2V5ID0gdGhpcy5wYXJlbnRLZXk7XG4gICAgICAgIHJlcy5pc1N0aWNreSA9IHRoaXMuaXNTdGlja3k7XG4gICAgICAgIHJlcy56SW5kZXggPSB0aGlzLnpJbmRleDtcbiAgICAgICAgcmVzLmFsbG93T3ZlcmZsb3cgPSB0aGlzLmFsbG93T3ZlcmZsb3c7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuICAgIC8qKlxuICAgKiBAcGFyYW0gdHlwZSBBIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIHZpZXcgdHlwZS4gU2hvdWxkIGJlIGAnaXRlbSdgIGZvciBpdGVtIHZpZXdzLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIE90aGVyIHR5cGVzIGFyZSB1c2VkIGJ5IHN1cHBsZW1lbnRhcnkgdmlld3MuXG4gICAqIEBwYXJhbSBrZXkgVGhlIHVuaXF1ZSBrZXkgZm9yIHRoaXMgdmlldy5cbiAgICogQHBhcmFtIHJlY3QgVGhlIHJlY3RhbmdsZSBkZXNjcmliaW5nIHRoZSBzaXplIGFuZCBwb3NpdGlvbiBvZiB0aGlzIHZpZXcuXG4gICAqLyBjb25zdHJ1Y3Rvcih0eXBlLCBrZXksIHJlY3Qpe1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLmtleSA9IGtleTtcbiAgICAgICAgdGhpcy5wYXJlbnRLZXkgPSBudWxsO1xuICAgICAgICB0aGlzLnJlY3QgPSByZWN0O1xuICAgICAgICB0aGlzLmVzdGltYXRlZFNpemUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5pc1N0aWNreSA9IGZhbHNlO1xuICAgICAgICB0aGlzLm9wYWNpdHkgPSAxO1xuICAgICAgICB0aGlzLnRyYW5zZm9ybSA9IG51bGw7XG4gICAgICAgIHRoaXMuekluZGV4ID0gMDtcbiAgICAgICAgdGhpcy5hbGxvd092ZXJmbG93ID0gZmFsc2U7XG4gICAgfVxufVxuXG5cbi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyBjbGFzcyAkMzA0MWRiMzI5Njk0NWU2ZSRleHBvcnQkYmFmMjYxNDZhNDE0ZjI0YSB7XG4gICAgLyoqXG4gICAqIFJldHVybnMgYSBjb3B5IG9mIHRoaXMgcG9pbnQuXG4gICAqLyBjb3B5KCkge1xuICAgICAgICByZXR1cm4gbmV3ICQzMDQxZGIzMjk2OTQ1ZTZlJGV4cG9ydCRiYWYyNjE0NmE0MTRmMjRhKHRoaXMueCwgdGhpcy55KTtcbiAgICB9XG4gICAgLyoqXG4gICAqIENoZWNrcyBpZiB0d28gcG9pbnRzIGFyZSBlcXVhbC5cbiAgICovIGVxdWFscyhwb2ludCkge1xuICAgICAgICByZXR1cm4gdGhpcy54ID09PSBwb2ludC54ICYmIHRoaXMueSA9PT0gcG9pbnQueTtcbiAgICB9XG4gICAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiB0aGlzIHBvaW50IGlzIHRoZSBvcmlnaW4uXG4gICAqLyBpc09yaWdpbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMueCA9PT0gMCAmJiB0aGlzLnkgPT09IDA7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKHggPSAwLCB5ID0gMCl7XG4gICAgICAgIHRoaXMueCA9IHg7XG4gICAgICAgIHRoaXMueSA9IHk7XG4gICAgfVxufVxuXG5cbi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyBcbmNsYXNzICQ2MDQyM2Y5MmM3ZjlhZDg3JGV4cG9ydCRjNzlmYzY0OTJmM2FmMTNkIHtcbiAgICAvKipcbiAgICogVGhlIG1heGltdW0geC1jb29yZGluYXRlIGluIHRoZSByZWN0YW5nbGUuXG4gICAqLyBnZXQgbWF4WCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMueCArIHRoaXMud2lkdGg7XG4gICAgfVxuICAgIC8qKlxuICAgKiBUaGUgbWF4aW11bSB5LWNvb3JkaW5hdGUgaW4gdGhlIHJlY3RhbmdsZS5cbiAgICovIGdldCBtYXhZKCkge1xuICAgICAgICByZXR1cm4gdGhpcy55ICsgdGhpcy5oZWlnaHQ7XG4gICAgfVxuICAgIC8qKlxuICAgKiBUaGUgYXJlYSBvZiB0aGUgcmVjdGFuZ2xlLlxuICAgKi8gZ2V0IGFyZWEoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLndpZHRoICogdGhpcy5oZWlnaHQ7XG4gICAgfVxuICAgIC8qKlxuICAgKiBUaGUgdG9wIGxlZnQgY29ybmVyIG9mIHRoZSByZWN0YW5nbGUuXG4gICAqLyBnZXQgdG9wTGVmdCgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyAoMCwgJDMwNDFkYjMyOTY5NDVlNmUkZXhwb3J0JGJhZjI2MTQ2YTQxNGYyNGEpKHRoaXMueCwgdGhpcy55KTtcbiAgICB9XG4gICAgLyoqXG4gICAqIFRoZSB0b3AgcmlnaHQgY29ybmVyIG9mIHRoZSByZWN0YW5nbGUuXG4gICAqLyBnZXQgdG9wUmlnaHQoKSB7XG4gICAgICAgIHJldHVybiBuZXcgKDAsICQzMDQxZGIzMjk2OTQ1ZTZlJGV4cG9ydCRiYWYyNjE0NmE0MTRmMjRhKSh0aGlzLm1heFgsIHRoaXMueSk7XG4gICAgfVxuICAgIC8qKlxuICAgKiBUaGUgYm90dG9tIGxlZnQgY29ybmVyIG9mIHRoZSByZWN0YW5nbGUuXG4gICAqLyBnZXQgYm90dG9tTGVmdCgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyAoMCwgJDMwNDFkYjMyOTY5NDVlNmUkZXhwb3J0JGJhZjI2MTQ2YTQxNGYyNGEpKHRoaXMueCwgdGhpcy5tYXhZKTtcbiAgICB9XG4gICAgLyoqXG4gICAqIFRoZSBib3R0b20gcmlnaHQgY29ybmVyIG9mIHRoZSByZWN0YW5nbGUuXG4gICAqLyBnZXQgYm90dG9tUmlnaHQoKSB7XG4gICAgICAgIHJldHVybiBuZXcgKDAsICQzMDQxZGIzMjk2OTQ1ZTZlJGV4cG9ydCRiYWYyNjE0NmE0MTRmMjRhKSh0aGlzLm1heFgsIHRoaXMubWF4WSk7XG4gICAgfVxuICAgIC8qKlxuICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhpcyByZWN0YW5nbGUgaW50ZXJzZWN0cyBhbm90aGVyIHJlY3RhbmdsZS5cbiAgICogQHBhcmFtIHJlY3QgLSBUaGUgcmVjdGFuZ2xlIHRvIGNoZWNrLlxuICAgKi8gaW50ZXJzZWN0cyhyZWN0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnggPD0gcmVjdC54ICsgcmVjdC53aWR0aCAmJiByZWN0LnggPD0gdGhpcy54ICsgdGhpcy53aWR0aCAmJiB0aGlzLnkgPD0gcmVjdC55ICsgcmVjdC5oZWlnaHQgJiYgcmVjdC55IDw9IHRoaXMueSArIHRoaXMuaGVpZ2h0O1xuICAgIH1cbiAgICAvKipcbiAgICogUmV0dXJucyB3aGV0aGVyIHRoaXMgcmVjdGFuZ2xlIGZ1bGx5IGNvbnRhaW5zIGFub3RoZXIgcmVjdGFuZ2xlLlxuICAgKiBAcGFyYW0gcmVjdCAtIFRoZSByZWN0YW5nbGUgdG8gY2hlY2suXG4gICAqLyBjb250YWluc1JlY3QocmVjdCkge1xuICAgICAgICByZXR1cm4gdGhpcy54IDw9IHJlY3QueCAmJiB0aGlzLnkgPD0gcmVjdC55ICYmIHRoaXMubWF4WCA+PSByZWN0Lm1heFggJiYgdGhpcy5tYXhZID49IHJlY3QubWF4WTtcbiAgICB9XG4gICAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlciB0aGUgcmVjdGFuZ2xlIGNvbnRhaW5zIHRoZSBnaXZlbiBwb2ludC5cbiAgICogQHBhcmFtIHBvaW50IC0gVGhlIHBvaW50IHRvIGNoZWNrLlxuICAgKi8gY29udGFpbnNQb2ludChwb2ludCkge1xuICAgICAgICByZXR1cm4gdGhpcy54IDw9IHBvaW50LnggJiYgdGhpcy55IDw9IHBvaW50LnkgJiYgdGhpcy5tYXhYID49IHBvaW50LnggJiYgdGhpcy5tYXhZID49IHBvaW50Lnk7XG4gICAgfVxuICAgIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBmaXJzdCBjb3JuZXIgb2YgdGhpcyByZWN0YW5nbGUgKGZyb20gdG9wIHRvIGJvdHRvbSwgbGVmdCB0byByaWdodClcbiAgICogdGhhdCBpcyBjb250YWluZWQgaW4gdGhlIGdpdmVuIHJlY3RhbmdsZSwgb3IgbnVsbCBvZiB0aGUgcmVjdGFuZ2xlcyBkbyBub3QgaW50ZXJzZWN0LlxuICAgKiBAcGFyYW0gcmVjdCAtIFRoZSByZWN0YW5nbGUgdG8gY2hlY2suXG4gICAqLyBnZXRDb3JuZXJJblJlY3QocmVjdCkge1xuICAgICAgICBmb3IgKGxldCBrZXkgb2YgW1xuICAgICAgICAgICAgXCJ0b3BMZWZ0XCIsXG4gICAgICAgICAgICBcInRvcFJpZ2h0XCIsXG4gICAgICAgICAgICBcImJvdHRvbUxlZnRcIixcbiAgICAgICAgICAgIFwiYm90dG9tUmlnaHRcIlxuICAgICAgICBdKXtcbiAgICAgICAgICAgIGlmIChyZWN0LmNvbnRhaW5zUG9pbnQodGhpc1trZXldKSkgcmV0dXJuIGtleTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZXF1YWxzKHJlY3QpIHtcbiAgICAgICAgcmV0dXJuIHJlY3QueCA9PT0gdGhpcy54ICYmIHJlY3QueSA9PT0gdGhpcy55ICYmIHJlY3Qud2lkdGggPT09IHRoaXMud2lkdGggJiYgcmVjdC5oZWlnaHQgPT09IHRoaXMuaGVpZ2h0O1xuICAgIH1cbiAgICBwb2ludEVxdWFscyhwb2ludCkge1xuICAgICAgICByZXR1cm4gdGhpcy54ID09PSBwb2ludC54ICYmIHRoaXMueSA9PT0gcG9pbnQueTtcbiAgICB9XG4gICAgc2l6ZUVxdWFscyhzaXplKSB7XG4gICAgICAgIHJldHVybiB0aGlzLndpZHRoID09PSBzaXplLndpZHRoICYmIHRoaXMuaGVpZ2h0ID09PSBzaXplLmhlaWdodDtcbiAgICB9XG4gICAgLyoqXG4gICAqIFJldHVybnMgdGhlIHVuaW9uIG9mIHRoaXMgUmVjdCBhbmQgYW5vdGhlci5cbiAgICovIHVuaW9uKG90aGVyKSB7XG4gICAgICAgIGxldCB4ID0gTWF0aC5taW4odGhpcy54LCBvdGhlci54KTtcbiAgICAgICAgbGV0IHkgPSBNYXRoLm1pbih0aGlzLnksIG90aGVyLnkpO1xuICAgICAgICBsZXQgd2lkdGggPSBNYXRoLm1heCh0aGlzLm1heFgsIG90aGVyLm1heFgpIC0geDtcbiAgICAgICAgbGV0IGhlaWdodCA9IE1hdGgubWF4KHRoaXMubWF4WSwgb3RoZXIubWF4WSkgLSB5O1xuICAgICAgICByZXR1cm4gbmV3ICQ2MDQyM2Y5MmM3ZjlhZDg3JGV4cG9ydCRjNzlmYzY0OTJmM2FmMTNkKHgsIHksIHdpZHRoLCBoZWlnaHQpO1xuICAgIH1cbiAgICAvKipcbiAgICogUmV0dXJucyB0aGUgaW50ZXJzZWN0aW9uIG9mIHRoaXMgUmVjdCB3aXRoIGFub3RoZXIuXG4gICAqIElmIHRoZSByZWN0YW5nbGVzIGRvIG5vdCBpbnRlcnNlY3QsIGFuIGFsbCB6ZXJvIFJlY3QgaXMgcmV0dXJuZWQuXG4gICAqLyBpbnRlcnNlY3Rpb24ob3RoZXIpIHtcbiAgICAgICAgaWYgKCF0aGlzLmludGVyc2VjdHMob3RoZXIpKSByZXR1cm4gbmV3ICQ2MDQyM2Y5MmM3ZjlhZDg3JGV4cG9ydCRjNzlmYzY0OTJmM2FmMTNkKDAsIDAsIDAsIDApO1xuICAgICAgICBsZXQgeCA9IE1hdGgubWF4KHRoaXMueCwgb3RoZXIueCk7XG4gICAgICAgIGxldCB5ID0gTWF0aC5tYXgodGhpcy55LCBvdGhlci55KTtcbiAgICAgICAgcmV0dXJuIG5ldyAkNjA0MjNmOTJjN2Y5YWQ4NyRleHBvcnQkYzc5ZmM2NDkyZjNhZjEzZCh4LCB5LCBNYXRoLm1pbih0aGlzLm1heFgsIG90aGVyLm1heFgpIC0geCwgTWF0aC5taW4odGhpcy5tYXhZLCBvdGhlci5tYXhZKSAtIHkpO1xuICAgIH1cbiAgICAvKipcbiAgICogUmV0dXJucyBhIGNvcHkgb2YgdGhpcyByZWN0YW5nbGUuXG4gICAqLyBjb3B5KCkge1xuICAgICAgICByZXR1cm4gbmV3ICQ2MDQyM2Y5MmM3ZjlhZDg3JGV4cG9ydCRjNzlmYzY0OTJmM2FmMTNkKHRoaXMueCwgdGhpcy55LCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKHggPSAwLCB5ID0gMCwgd2lkdGggPSAwLCBoZWlnaHQgPSAwKXtcbiAgICAgICAgdGhpcy54ID0geDtcbiAgICAgICAgdGhpcy55ID0geTtcbiAgICAgICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgICAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgICB9XG59XG5cblxuLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIGNsYXNzICRlZTFiZmE5MGE5NTdmYjhhJGV4cG9ydCRjYjZkYTg5YzZhZjFhOGVjIHtcbiAgICAvKipcbiAgICogUmV0dXJucyBhIGNvcHkgb2YgdGhpcyBzaXplLlxuICAgKi8gY29weSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyAkZWUxYmZhOTBhOTU3ZmI4YSRleHBvcnQkY2I2ZGE4OWM2YWYxYThlYyh0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG4gICAgfVxuICAgIC8qKlxuICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhpcyBzaXplIGlzIGVxdWFsIHRvIGFub3RoZXIgb25lLlxuICAgKi8gZXF1YWxzKG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLndpZHRoID09PSBvdGhlci53aWR0aCAmJiB0aGlzLmhlaWdodCA9PT0gb3RoZXIuaGVpZ2h0O1xuICAgIH1cbiAgICAvKipcbiAgICogVGhlIHRvdGFsIGFyZWEgb2YgdGhlIFNpemUuXG4gICAqLyBnZXQgYXJlYSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud2lkdGggKiB0aGlzLmhlaWdodDtcbiAgICB9XG4gICAgY29uc3RydWN0b3Iod2lkdGggPSAwLCBoZWlnaHQgPSAwKXtcbiAgICAgICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgICAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgICB9XG59XG5cblxuLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIGxldCAkYWQxZDk4YWE4ZjBjMzFiNCR2YXIkS0VZID0gMDtcbmNsYXNzICRhZDFkOThhYThmMGMzMWI0JGV4cG9ydCQxYTUyMjM4ODdjNTYwNDQxIHtcbiAgICAvKipcbiAgICogUHJlcGFyZXMgdGhlIHZpZXcgZm9yIHJldXNlLiBDYWxsZWQganVzdCBiZWZvcmUgdGhlIHZpZXcgaXMgcmVtb3ZlZCBmcm9tIHRoZSBET00uXG4gICAqLyBwcmVwYXJlRm9yUmV1c2UoKSB7XG4gICAgICAgIHRoaXMuY29udGVudCA9IG51bGw7XG4gICAgICAgIHRoaXMucmVuZGVyZWQgPSBudWxsO1xuICAgICAgICB0aGlzLmxheW91dEluZm8gPSBudWxsO1xuICAgIH1cbiAgICBjb25zdHJ1Y3Rvcih2aXJ0dWFsaXplcil7XG4gICAgICAgIHRoaXMudmlydHVhbGl6ZXIgPSB2aXJ0dWFsaXplcjtcbiAgICAgICAgdGhpcy5rZXkgPSArKyRhZDFkOThhYThmMGMzMWI0JHZhciRLRVk7XG4gICAgfVxufVxuXG5cbi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyBcblxuXG4vKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIFxuLy8gdXNlIGhpZ2ggcmVzIHRpbWVyIGlmIGF2YWlsYWJsZVxubGV0ICQzZWIxMzFkY2YzN2FkNWY4JHZhciRwZXJmID0gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdy5wZXJmb3JtYW5jZSA6IG51bGw7XG4vLyBAdHMtaWdub3JlXG5sZXQgJDNlYjEzMWRjZjM3YWQ1ZjgkdmFyJHBlcmZOb3cgPSAkM2ViMTMxZGNmMzdhZDVmOCR2YXIkcGVyZiAmJiAoJDNlYjEzMWRjZjM3YWQ1ZjgkdmFyJHBlcmYubm93IHx8ICQzZWIxMzFkY2YzN2FkNWY4JHZhciRwZXJmLndlYmtpdE5vdyB8fCAkM2ViMTMxZGNmMzdhZDVmOCR2YXIkcGVyZi5tc05vdyB8fCAkM2ViMTMxZGNmMzdhZDVmOCR2YXIkcGVyZi5tb3pOb3cpO1xubGV0ICQzZWIxMzFkY2YzN2FkNWY4JHZhciRnZXRUaW1lID0gJDNlYjEzMWRjZjM3YWQ1ZjgkdmFyJHBlcmZOb3cgPyAkM2ViMTMxZGNmMzdhZDVmOCR2YXIkcGVyZk5vdy5iaW5kKCQzZWIxMzFkY2YzN2FkNWY4JHZhciRwZXJmKSA6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBEYXRlLm5vdyA/IERhdGUubm93KCkgOiBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbn07XG5sZXQgJDNlYjEzMWRjZjM3YWQ1ZjgkdmFyJGZpeFRzO1xuZnVuY3Rpb24gJDNlYjEzMWRjZjM3YWQ1ZjgkZXhwb3J0JGRjMGI2MzcyMDc4ODA5MGMoYmVnaW4sIGVuZCwgZHVyYXRpb24sIGVhc2UsIGZuKSB7XG4gICAgbGV0IGNhbmNlbGVkID0gZmFsc2U7XG4gICAgbGV0IHJhZl9pZDtcbiAgICBsZXQgcHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlKT0+e1xuICAgICAgICBsZXQgc3RhcnQgPSAkM2ViMTMxZGNmMzdhZDVmOCR2YXIkZ2V0VGltZSgpO1xuICAgICAgICBsZXQgZGlmZlggPSBlbmQueCAtIGJlZ2luLng7XG4gICAgICAgIGxldCBkaWZmWSA9IGVuZC55IC0gYmVnaW4ueTtcbiAgICAgICAgcmFmX2lkID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uIHJ1bih0KSB7XG4gICAgICAgICAgICAvLyBpZiB3ZSdyZSB1c2luZyBhIGhpZ2ggcmVzIHRpbWVyLCBtYWtlIHN1cmUgdGltZXN0YW1wIGlzIG5vdCB0aGUgb2xkIGVwb2NoLWJhc2VkIHZhbHVlLlxuICAgICAgICAgICAgLy8gaHR0cDovL3VwZGF0ZXMuaHRtbDVyb2Nrcy5jb20vMjAxMi8wNS9yZXF1ZXN0QW5pbWF0aW9uRnJhbWUtQVBJLW5vdy13aXRoLXN1Yi1taWxsaXNlY29uZC1wcmVjaXNpb25cbiAgICAgICAgICAgIGlmICgkM2ViMTMxZGNmMzdhZDVmOCR2YXIkZml4VHMgPT0gbnVsbCkgJDNlYjEzMWRjZjM3YWQ1ZjgkdmFyJGZpeFRzID0gdCA+IDFlMTIgIT09ICQzZWIxMzFkY2YzN2FkNWY4JHZhciRnZXRUaW1lKCkgPiAxZTEyO1xuICAgICAgICAgICAgaWYgKCQzZWIxMzFkY2YzN2FkNWY4JHZhciRmaXhUcykgdCA9ICQzZWIxMzFkY2YzN2FkNWY4JHZhciRnZXRUaW1lKCk7XG4gICAgICAgICAgICAvLyBjaGVjayBpZiB3ZSdyZSBkb25lXG4gICAgICAgICAgICBsZXQgZGVsdGEgPSB0IC0gc3RhcnQ7XG4gICAgICAgICAgICBpZiAoZGVsdGEgPiBkdXJhdGlvbikge1xuICAgICAgICAgICAgICAgIGZuKGVuZCk7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBjYWxsIGZyYW1lIGNhbGxiYWNrIGFmdGVyIGNvbXB1dGluZyBlYXNlZCB0aW1lIGFuZCBnZXQgdGhlIG5leHQgZnJhbWVcbiAgICAgICAgICAgICAgICBsZXQgcHJvY2VlZCA9IGZuKG5ldyAoMCwgJDMwNDFkYjMyOTY5NDVlNmUkZXhwb3J0JGJhZjI2MTQ2YTQxNGYyNGEpKGJlZ2luLnggKyBkaWZmWCAqIGVhc2UoZGVsdGEgLyBkdXJhdGlvbiksIGJlZ2luLnkgKyBkaWZmWSAqIGVhc2UoZGVsdGEgLyBkdXJhdGlvbikpKTtcbiAgICAgICAgICAgICAgICBpZiAocHJvY2VlZCAhPT0gZmFsc2UgJiYgIWNhbmNlbGVkKSByYWZfaWQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUocnVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgcHJvbWlzZS5jYW5jZWwgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgY2FuY2VsZWQgPSB0cnVlO1xuICAgICAgICBjYW5jZWxBbmltYXRpb25GcmFtZShyYWZfaWQpO1xuICAgIH07XG4gICAgcmV0dXJuIHByb21pc2U7XG59XG5mdW5jdGlvbiAkM2ViMTMxZGNmMzdhZDVmOCRleHBvcnQkNzc4NjBjMTA2YjRhNmEyZSh0KSB7XG4gICAgcmV0dXJuIHQ7XG59XG5mdW5jdGlvbiAkM2ViMTMxZGNmMzdhZDVmOCRleHBvcnQkNTc2MzZiYjQzYjFjY2JiMCh0KSB7XG4gICAgcmV0dXJuIE1hdGguc2luKHQgKiBNYXRoLlBJIC8gMik7XG59XG5cblxuLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIGZ1bmN0aW9uICRmYzM2ZjlhMDQ2YTljZTc5JGV4cG9ydCQzN2EyNmIyODNmZDc3NDBlKGEsIGIpIHtcbiAgICBsZXQgcmVzID0gbmV3IFNldCgpO1xuICAgIGZvciAobGV0IGtleSBvZiBhLmtleXMoKSlpZiAoIWIuaGFzKGtleSkpIHJlcy5hZGQoa2V5KTtcbiAgICByZXR1cm4gcmVzO1xufVxuZnVuY3Rpb24gJGZjMzZmOWEwNDZhOWNlNzkkZXhwb3J0JGFjYWY5NmEyNzQzODI0NmIoYSwgYikge1xuICAgIGxldCB0b1JlbW92ZSA9ICRmYzM2ZjlhMDQ2YTljZTc5JGV4cG9ydCQzN2EyNmIyODNmZDc3NDBlKGEsIGIpO1xuICAgIGxldCB0b0FkZCA9ICRmYzM2ZjlhMDQ2YTljZTc5JGV4cG9ydCQzN2EyNmIyODNmZDc3NDBlKGIsIGEpO1xuICAgIGxldCB0b1VwZGF0ZSA9IG5ldyBTZXQ7XG4gICAgZm9yIChsZXQga2V5IG9mIGEua2V5cygpKWlmIChiLmhhcyhrZXkpKSB0b1VwZGF0ZS5hZGQoa2V5KTtcbiAgICByZXR1cm4ge1xuICAgICAgICB0b1JlbW92ZTogdG9SZW1vdmUsXG4gICAgICAgIHRvQWRkOiB0b0FkZCxcbiAgICAgICAgdG9VcGRhdGU6IHRvVXBkYXRlXG4gICAgfTtcbn1cbmZ1bmN0aW9uKiAkZmMzNmY5YTA0NmE5Y2U3OSRleHBvcnQkY2ZjMTQwODhkZmVmY2U1ZiguLi5pdGVyYXRvcnMpIHtcbiAgICBmb3IgKGxldCBpdGVyYXRvciBvZiBpdGVyYXRvcnMpeWllbGQqIGl0ZXJhdG9yO1xufVxuZnVuY3Rpb24gJGZjMzZmOWEwNDZhOWNlNzkkZXhwb3J0JDY4OTdjMjg0YjZmOWY0ZGMob2JqZWN0KSB7XG4gICAgbGV0IHJlcyA9IHt9O1xuICAgIGZvcihsZXQga2V5IGluIG9iamVjdClyZXNbb2JqZWN0W2tleV1dID0ga2V5O1xuICAgIHJldHVybiByZXM7XG59XG5mdW5jdGlvbiAkZmMzNmY5YTA0NmE5Y2U3OSRleHBvcnQkYThkMGQwYzhkMWM1ZGY2NChhLCBiKSB7XG4gICAgaWYgKGEgPT09IGIpIHJldHVybiB0cnVlO1xuICAgIGlmIChhLnNpemUgIT09IGIuc2l6ZSkgcmV0dXJuIGZhbHNlO1xuICAgIGZvciAobGV0IGtleSBvZiBhKXtcbiAgICAgICAgaWYgKCFiLmhhcyhrZXkpKSByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuXG5cbi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyBcblxuY2xhc3MgJDM2NDE5MWIzZGVjZjM2OTckdmFyJFJvbGxpbmdBdmVyYWdlIHtcbiAgICBhZGRTYW1wbGUoc2FtcGxlKSB7XG4gICAgICAgIHRoaXMuY291bnQrKztcbiAgICAgICAgdGhpcy52YWx1ZSArPSAoc2FtcGxlIC0gdGhpcy52YWx1ZSkgLyB0aGlzLmNvdW50O1xuICAgIH1cbiAgICBjb25zdHJ1Y3Rvcigpe1xuICAgICAgICB0aGlzLmNvdW50ID0gMDtcbiAgICAgICAgdGhpcy52YWx1ZSA9IDA7XG4gICAgfVxufVxuY2xhc3MgJDM2NDE5MWIzZGVjZjM2OTckZXhwb3J0JDQ0NTVlZTZhZmIzOGRjYmIge1xuICAgIHNldFZpc2libGVSZWN0KHJlY3QpIHtcbiAgICAgICAgbGV0IHRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKSAtIHRoaXMuc3RhcnRUaW1lO1xuICAgICAgICBpZiAodGltZSA8IDUwMCkge1xuICAgICAgICAgICAgdGhpcy5hdmVyYWdlVGltZS5hZGRTYW1wbGUodGltZSk7XG4gICAgICAgICAgICBpZiAocmVjdC54ICE9PSB0aGlzLnZpc2libGVSZWN0LnggJiYgdGltZSA+IDApIHRoaXMudmVsb2NpdHkueCA9IChyZWN0LnggLSB0aGlzLnZpc2libGVSZWN0LngpIC8gdGltZTtcbiAgICAgICAgICAgIGlmIChyZWN0LnkgIT09IHRoaXMudmlzaWJsZVJlY3QueSAmJiB0aW1lID4gMCkgdGhpcy52ZWxvY2l0eS55ID0gKHJlY3QueSAtIHRoaXMudmlzaWJsZVJlY3QueSkgLyB0aW1lO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RhcnRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgIHRoaXMudmlzaWJsZVJlY3QgPSByZWN0O1xuICAgIH1cbiAgICBjb2xsZWN0TWV0cmljcygpIHtcbiAgICAgICAgbGV0IHRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKSAtIHRoaXMuc3RhcnRUaW1lO1xuICAgICAgICBpZiAodGltZSA8IDUwMCkgdGhpcy5hdmVyYWdlUGVyZi5hZGRTYW1wbGUodGltZSk7XG4gICAgICAgIGlmICh0aGlzLnZpc2libGVSZWN0LmhlaWdodCA+IDApIHtcbiAgICAgICAgICAgIGxldCBvID0gTWF0aC5hYnModGhpcy52ZWxvY2l0eS55ICogKHRoaXMuYXZlcmFnZVRpbWUudmFsdWUgKyB0aGlzLmF2ZXJhZ2VQZXJmLnZhbHVlKSk7XG4gICAgICAgICAgICB0aGlzLm92ZXJzY2FuWS5hZGRTYW1wbGUobyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMudmlzaWJsZVJlY3Qud2lkdGggPiAwKSB7XG4gICAgICAgICAgICBsZXQgbyA9IE1hdGguYWJzKHRoaXMudmVsb2NpdHkueCAqICh0aGlzLmF2ZXJhZ2VUaW1lLnZhbHVlICsgdGhpcy5hdmVyYWdlUGVyZi52YWx1ZSkpO1xuICAgICAgICAgICAgdGhpcy5vdmVyc2NhblguYWRkU2FtcGxlKG8pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldE92ZXJzY2FubmVkUmVjdCgpIHtcbiAgICAgICAgbGV0IG92ZXJzY2FubmVkID0gdGhpcy52aXNpYmxlUmVjdC5jb3B5KCk7XG4gICAgICAgIGxldCBvdmVyc2NhblkgPSBNYXRoLnJvdW5kKE1hdGgubWluKHRoaXMudmlzaWJsZVJlY3QuaGVpZ2h0ICogMiwgdGhpcy5vdmVyc2NhblkudmFsdWUpIC8gMTAwKSAqIDEwMDtcbiAgICAgICAgaWYgKHRoaXMudmVsb2NpdHkueSA+IDApIHtcbiAgICAgICAgICAgIG92ZXJzY2FubmVkLnkgLT0gb3ZlcnNjYW5ZICogMC4yO1xuICAgICAgICAgICAgb3ZlcnNjYW5uZWQuaGVpZ2h0ICs9IG92ZXJzY2FuWSArIG92ZXJzY2FuWSAqIDAuMjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG92ZXJzY2FubmVkLnkgLT0gb3ZlcnNjYW5ZO1xuICAgICAgICAgICAgb3ZlcnNjYW5uZWQuaGVpZ2h0ICs9IG92ZXJzY2FuWSArIG92ZXJzY2FuWSAqIDAuMjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgb3ZlcnNjYW5YID0gTWF0aC5yb3VuZChNYXRoLm1pbih0aGlzLnZpc2libGVSZWN0LndpZHRoICogMiwgdGhpcy5vdmVyc2NhblgudmFsdWUpIC8gMTAwKSAqIDEwMDtcbiAgICAgICAgaWYgKHRoaXMudmVsb2NpdHkueCA+IDApIHtcbiAgICAgICAgICAgIG92ZXJzY2FubmVkLnggLT0gb3ZlcnNjYW5YICogMC4yO1xuICAgICAgICAgICAgb3ZlcnNjYW5uZWQud2lkdGggKz0gb3ZlcnNjYW5YICsgb3ZlcnNjYW5YICogMC4yO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb3ZlcnNjYW5uZWQueCAtPSBvdmVyc2Nhblg7XG4gICAgICAgICAgICBvdmVyc2Nhbm5lZC53aWR0aCArPSBvdmVyc2NhblggKyBvdmVyc2NhblggKiAwLjI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG92ZXJzY2FubmVkO1xuICAgIH1cbiAgICBjb25zdHJ1Y3Rvcigpe1xuICAgICAgICB0aGlzLnN0YXJ0VGltZSA9IDA7XG4gICAgICAgIHRoaXMuYXZlcmFnZVBlcmYgPSBuZXcgJDM2NDE5MWIzZGVjZjM2OTckdmFyJFJvbGxpbmdBdmVyYWdlKCk7XG4gICAgICAgIHRoaXMuYXZlcmFnZVRpbWUgPSBuZXcgJDM2NDE5MWIzZGVjZjM2OTckdmFyJFJvbGxpbmdBdmVyYWdlKCk7XG4gICAgICAgIHRoaXMudmVsb2NpdHkgPSBuZXcgKDAsICQzMDQxZGIzMjk2OTQ1ZTZlJGV4cG9ydCRiYWYyNjE0NmE0MTRmMjRhKSg1LCA1KTtcbiAgICAgICAgdGhpcy5vdmVyc2NhblggPSBuZXcgJDM2NDE5MWIzZGVjZjM2OTckdmFyJFJvbGxpbmdBdmVyYWdlKCk7XG4gICAgICAgIHRoaXMub3ZlcnNjYW5ZID0gbmV3ICQzNjQxOTFiM2RlY2YzNjk3JHZhciRSb2xsaW5nQXZlcmFnZSgpO1xuICAgICAgICB0aGlzLnZpc2libGVSZWN0ID0gbmV3ICgwLCAkNjA0MjNmOTJjN2Y5YWQ4NyRleHBvcnQkYzc5ZmM2NDkyZjNhZjEzZCkoKTtcbiAgICB9XG59XG5cblxuXG5cblxuXG4vKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gY2xhc3MgJDhlMTM1ZTUzMWQ4ZGNiNjYkZXhwb3J0JGZlYmM1NTczYzc1Y2VmYjAge1xuICAgIGNvbnN0cnVjdG9yKCl7XG4gICAgICAgIHRoaXMubGV2ZWwgPSAwO1xuICAgICAgICB0aGlzLmFjdGlvbnMgPSBbXTtcbiAgICAgICAgdGhpcy5hbmltYXRlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuaW5pdGlhbE1hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5maW5hbE1hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5pbml0aWFsTGF5b3V0SW5mbyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5maW5hbExheW91dEluZm8gPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMucmVtb3ZlZCA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy50b1JlbW92ZSA9IG5ldyBNYXAoKTtcbiAgICB9XG59XG5cblxuY2xhc3MgJDM4Yjk0OTBjMWNjYThmYzQkZXhwb3J0JDg5YmU1YTI0M2U1OWM0YjIge1xuICAgIF9zZXRDb250ZW50U2l6ZShzaXplKSB7XG4gICAgICAgIHRoaXMuX2NvbnRlbnRTaXplID0gc2l6ZTtcbiAgICAgICAgdGhpcy5kZWxlZ2F0ZS5zZXRDb250ZW50U2l6ZShzaXplKTtcbiAgICB9XG4gICAgX3NldENvbnRlbnRPZmZzZXQob2Zmc2V0KSB7XG4gICAgICAgIGxldCByZWN0ID0gbmV3ICgwLCAkNjA0MjNmOTJjN2Y5YWQ4NyRleHBvcnQkYzc5ZmM2NDkyZjNhZjEzZCkob2Zmc2V0LngsIG9mZnNldC55LCB0aGlzLl92aXNpYmxlUmVjdC53aWR0aCwgdGhpcy5fdmlzaWJsZVJlY3QuaGVpZ2h0KTtcbiAgICAgICAgdGhpcy5kZWxlZ2F0ZS5zZXRWaXNpYmxlUmVjdChyZWN0KTtcbiAgICB9XG4gICAgLyoqXG4gICAqIEdldCB0aGUgc2l6ZSBvZiB0aGUgc2Nyb2xsYWJsZSBjb250ZW50LlxuICAgKi8gZ2V0IGNvbnRlbnRTaXplKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY29udGVudFNpemU7XG4gICAgfVxuICAgIC8qKlxuICAgKiBHZXQgdGhlIGNvbGxlY3Rpb24gdmlldydzIGN1cnJlbnRseSB2aXNpYmxlIHJlY3RhbmdsZS5cbiAgICovIGdldCB2aXNpYmxlUmVjdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Zpc2libGVSZWN0O1xuICAgIH1cbiAgICAvKipcbiAgICogU2V0IHRoZSBjb2xsZWN0aW9uIHZpZXcncyBjdXJyZW50bHkgdmlzaWJsZSByZWN0YW5nbGUuXG4gICAqLyBzZXQgdmlzaWJsZVJlY3QocmVjdCkge1xuICAgICAgICB0aGlzLl9zZXRWaXNpYmxlUmVjdChyZWN0KTtcbiAgICB9XG4gICAgX3NldFZpc2libGVSZWN0KHJlY3QsIGZvcmNlVXBkYXRlID0gZmFsc2UpIHtcbiAgICAgICAgbGV0IGN1cnJlbnQgPSB0aGlzLl92aXNpYmxlUmVjdDtcbiAgICAgICAgLy8gSWdub3JlIGlmIHRoZSByZWN0cyBhcmUgZXF1YWxcbiAgICAgICAgaWYgKHJlY3QuZXF1YWxzKGN1cnJlbnQpKSByZXR1cm47XG4gICAgICAgIGlmICh0aGlzLnNob3VsZE92ZXJzY2FuKSB0aGlzLl9vdmVyc2Nhbk1hbmFnZXIuc2V0VmlzaWJsZVJlY3QocmVjdCk7XG4gICAgICAgIGxldCBzaG91bGRJbnZhbGlkYXRlID0gdGhpcy5sYXlvdXQgJiYgdGhpcy5sYXlvdXQuc2hvdWxkSW52YWxpZGF0ZShyZWN0LCB0aGlzLl92aXNpYmxlUmVjdCk7XG4gICAgICAgIHRoaXMuX3Jlc2V0QW5pbWF0ZWRDb250ZW50T2Zmc2V0KCk7XG4gICAgICAgIHRoaXMuX3Zpc2libGVSZWN0ID0gcmVjdDtcbiAgICAgICAgaWYgKHNob3VsZEludmFsaWRhdGUpIC8vIFdlIGFyZSBhbHJlYWR5IGluIGEgbGF5b3V0IGVmZmVjdCB3aGVuIHRoaXMgbWV0aG9kIGlzIGNhbGxlZCwgc28gcmVsYXlvdXROb3cgaXMgYXBwcm9wcmlhdGUuXG4gICAgICAgIHRoaXMucmVsYXlvdXROb3coe1xuICAgICAgICAgICAgb2Zmc2V0Q2hhbmdlZDogIXJlY3QucG9pbnRFcXVhbHMoY3VycmVudCksXG4gICAgICAgICAgICBzaXplQ2hhbmdlZDogIXJlY3Quc2l6ZUVxdWFscyhjdXJyZW50KVxuICAgICAgICB9KTtcbiAgICAgICAgZWxzZSB0aGlzLnVwZGF0ZVN1YnZpZXdzKGZvcmNlVXBkYXRlKTtcbiAgICB9XG4gICAgZ2V0IGNvbGxlY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb2xsZWN0aW9uO1xuICAgIH1cbiAgICBzZXQgY29sbGVjdGlvbihkYXRhKSB7XG4gICAgICAgIHRoaXMuX3NldERhdGEoZGF0YSk7XG4gICAgfVxuICAgIF9zZXREYXRhKGRhdGEpIHtcbiAgICAgICAgaWYgKGRhdGEgPT09IHRoaXMuX2NvbGxlY3Rpb24pIHJldHVybjtcbiAgICAgICAgaWYgKHRoaXMuX2NvbGxlY3Rpb24pIHRoaXMuX3J1blRyYW5zYWN0aW9uKCgpPT57XG4gICAgICAgICAgICB0aGlzLl9jb2xsZWN0aW9uID0gZGF0YTtcbiAgICAgICAgfSwgdGhpcy50cmFuc2l0aW9uRHVyYXRpb24gPiAwKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9jb2xsZWN0aW9uID0gZGF0YTtcbiAgICAgICAgICAgIHRoaXMucmVsb2FkRGF0YSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgKiBSZWxvYWRzIHRoZSBkYXRhIGZyb20gdGhlIGRhdGEgc291cmNlIGFuZCByZWxheW91dHMgdGhlIGNvbGxlY3Rpb24gdmlldy5cbiAgICogRG9lcyBub3QgYW5pbWF0ZSBhbnkgY2hhbmdlcy4gRXF1aXZhbGVudCB0byByZS1hc3NpZ25pbmcgdGhlIHNhbWUgZGF0YSBzb3VyY2VcbiAgICogdG8gdGhlIGNvbGxlY3Rpb24gdmlldy5cbiAgICovIHJlbG9hZERhdGEoKSB7XG4gICAgICAgIHRoaXMucmVsYXlvdXQoe1xuICAgICAgICAgICAgY29udGVudENoYW5nZWQ6IHRydWVcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBpdGVtIHdpdGggdGhlIGdpdmVuIGtleS5cbiAgICovIGdldEl0ZW0oa2V5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb2xsZWN0aW9uID8gdGhpcy5fY29sbGVjdGlvbi5nZXRJdGVtKGtleSkgOiBudWxsO1xuICAgIH1cbiAgICAvKiogVGhlIHNldCBvZiBwZXJzaXN0ZWQga2V5cyBhcmUgYWx3YXlzIHByZXNlbnQgaW4gdGhlIERPTSwgZXZlbiBpZiBub3QgY3VycmVudGx5IGluIHZpZXcuICovIGdldCBwZXJzaXN0ZWRLZXlzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGVyc2lzdGVkS2V5cztcbiAgICB9XG4gICAgLyoqIFRoZSBzZXQgb2YgcGVyc2lzdGVkIGtleXMgYXJlIGFsd2F5cyBwcmVzZW50IGluIHRoZSBET00sIGV2ZW4gaWYgbm90IGN1cnJlbnRseSBpbiB2aWV3LiAqLyBzZXQgcGVyc2lzdGVkS2V5cyhwZXJzaXN0ZWRLZXlzKSB7XG4gICAgICAgIGlmICghKDAsICRmYzM2ZjlhMDQ2YTljZTc5JGV4cG9ydCRhOGQwZDBjOGQxYzVkZjY0KShwZXJzaXN0ZWRLZXlzLCB0aGlzLl9wZXJzaXN0ZWRLZXlzKSkge1xuICAgICAgICAgICAgdGhpcy5fcGVyc2lzdGVkS2V5cyA9IHBlcnNpc3RlZEtleXM7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVN1YnZpZXdzKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqIFJldHVybnMgd2hldGhlciB0aGUgZ2l2ZW4ga2V5LCBvciBhbiBhbmNlc3RvciwgaXMgcGVyc2lzdGVkLiAqLyBpc1BlcnNpc3RlZEtleShrZXkpIHtcbiAgICAgICAgLy8gUXVpY2sgY2hlY2sgaWYgdGhlIGtleSBpcyBkaXJlY3RseSBpbiB0aGUgc2V0IG9mIHBlcnNpc3RlZCBrZXlzLlxuICAgICAgICBpZiAodGhpcy5fcGVyc2lzdGVkS2V5cy5oYXMoa2V5KSkgcmV0dXJuIHRydWU7XG4gICAgICAgIC8vIElmIG5vdCwgY2hlY2sgaWYgdGhlIGtleSBpcyBhbiBhbmNlc3RvciBvZiBhbnkgb2YgdGhlIHBlcnNpc3RlZCBrZXlzLlxuICAgICAgICBmb3IgKGxldCBrIG9mIHRoaXMuX3BlcnNpc3RlZEtleXMpd2hpbGUoayAhPSBudWxsKXtcbiAgICAgICAgICAgIGxldCBsYXlvdXRJbmZvID0gdGhpcy5sYXlvdXQuZ2V0TGF5b3V0SW5mbyhrKTtcbiAgICAgICAgICAgIGlmICghbGF5b3V0SW5mbykgYnJlYWs7XG4gICAgICAgICAgICBrID0gbGF5b3V0SW5mby5wYXJlbnRLZXk7XG4gICAgICAgICAgICBpZiAoayA9PT0ga2V5KSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgKiBHZXQgdGhlIGNvbGxlY3Rpb24gdmlldydzIGxheW91dC5cbiAgICovIGdldCBsYXlvdXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sYXlvdXQ7XG4gICAgfVxuICAgIC8qKlxuICAgKiBTZXQgdGhlIGNvbGxlY3Rpb24gdmlldydzIGxheW91dC5cbiAgICovIHNldCBsYXlvdXQobGF5b3V0KSB7XG4gICAgICAgIHRoaXMuc2V0TGF5b3V0KGxheW91dCk7XG4gICAgfVxuICAgIC8qKlxuICAgKiBTZXRzIHRoZSBjb2xsZWN0aW9uIHZpZXcncyBsYXlvdXQsIG9wdGlvbmFsbHkgd2l0aCBhbiBhbmltYXRlZCB0cmFuc2l0aW9uXG4gICAqIGZyb20gdGhlIGN1cnJlbnQgbGF5b3V0IHRvIHRoZSBuZXcgbGF5b3V0LlxuICAgKiBAcGFyYW0gbGF5b3V0IFRoZSBsYXlvdXQgdG8gc3dpdGNoIHRvLlxuICAgKiBAcGFyYW0gYW5pbWF0ZWQgV2hldGhlciB0byBhbmltYXRlIHRoZSBsYXlvdXQgY2hhbmdlLlxuICAgKi8gc2V0TGF5b3V0KGxheW91dCwgYW5pbWF0ZWQgPSBmYWxzZSkge1xuICAgICAgICBpZiAobGF5b3V0ID09PSB0aGlzLl9sYXlvdXQpIHJldHVybjtcbiAgICAgICAgbGV0IGFwcGx5TGF5b3V0ID0gKCk9PntcbiAgICAgICAgICAgIGlmICh0aGlzLl9sYXlvdXQpIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIHRoaXMuX2xheW91dC52aXJ0dWFsaXplciA9IG51bGw7XG4gICAgICAgICAgICBsYXlvdXQudmlydHVhbGl6ZXIgPSB0aGlzO1xuICAgICAgICAgICAgdGhpcy5fbGF5b3V0ID0gbGF5b3V0O1xuICAgICAgICB9O1xuICAgICAgICBpZiAoYW5pbWF0ZWQpIC8vIEFuaW1hdGVkIGxheW91dCB0cmFuc2l0aW9ucyBhcmUgcmVhbGx5IHNpbXBsZSwgdGhhbmtzIHRvIG91ciB0cmFuc2FjdGlvbiBzdXBwb3J0LlxuICAgICAgICAvLyBXZSBqdXN0IHNldCB0aGUgbGF5b3V0IGluc2lkZSBhIHRyYW5zYWN0aW9uIGFjdGlvbiwgd2hpY2ggcnVucyBhZnRlciB0aGUgaW5pdGlhbFxuICAgICAgICAvLyBsYXlvdXQgaW5mb3MgZm9yIHRoZSBhbmltYXRpb24gYXJlIHJldHJpZXZlZCBmcm9tIHRoZSBwcmV2aW91cyBsYXlvdXQuIFRoZW4sIHRoZVxuICAgICAgICAvLyBmaW5hbCBsYXlvdXQgaW5mb3MgYXJlIHJldHJpZXZlZCBmcm9tIHRoZSBuZXcgbGF5b3V0LCBhbmQgYW5pbWF0aW9ucyBvY2N1ci5cbiAgICAgICAgdGhpcy5fcnVuVHJhbnNhY3Rpb24oYXBwbHlMYXlvdXQpO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGFwcGx5TGF5b3V0KCk7XG4gICAgICAgICAgICB0aGlzLnJlbGF5b3V0KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2dldFJldXNlVHlwZShsYXlvdXRJbmZvLCBjb250ZW50KSB7XG4gICAgICAgIGlmIChsYXlvdXRJbmZvLnR5cGUgPT09IFwiaXRlbVwiICYmIGNvbnRlbnQpIHtcbiAgICAgICAgICAgIGxldCB0eXBlID0gdGhpcy5kZWxlZ2F0ZS5nZXRUeXBlID8gdGhpcy5kZWxlZ2F0ZS5nZXRUeXBlKGNvbnRlbnQpIDogXCJpdGVtXCI7XG4gICAgICAgICAgICBsZXQgcmV1c2VUeXBlID0gdHlwZSA9PT0gXCJpdGVtXCIgPyBcIml0ZW1cIiA6IGxheW91dEluZm8udHlwZSArIFwiX1wiICsgdHlwZTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgICAgICAgICByZXVzZVR5cGU6IHJldXNlVHlwZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogbGF5b3V0SW5mby50eXBlLFxuICAgICAgICAgICAgcmV1c2VUeXBlOiBsYXlvdXRJbmZvLnR5cGVcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZ2V0UmV1c2FibGVWaWV3KGxheW91dEluZm8pIHtcbiAgICAgICAgbGV0IGNvbnRlbnQgPSB0aGlzLmdldEl0ZW0obGF5b3V0SW5mby5rZXkpO1xuICAgICAgICBsZXQgeyByZXVzZVR5cGU6IHJldXNlVHlwZSB9ID0gdGhpcy5fZ2V0UmV1c2VUeXBlKGxheW91dEluZm8sIGNvbnRlbnQpO1xuICAgICAgICBpZiAoIXRoaXMuX3JldXNhYmxlVmlld3NbcmV1c2VUeXBlXSkgdGhpcy5fcmV1c2FibGVWaWV3c1tyZXVzZVR5cGVdID0gW107XG4gICAgICAgIGxldCByZXVzYWJsZSA9IHRoaXMuX3JldXNhYmxlVmlld3NbcmV1c2VUeXBlXTtcbiAgICAgICAgbGV0IHZpZXcgPSByZXVzYWJsZS5sZW5ndGggPiAwID8gcmV1c2FibGUucG9wKCkgOiBuZXcgKDAsICRhZDFkOThhYThmMGMzMWI0JGV4cG9ydCQxYTUyMjM4ODdjNTYwNDQxKSh0aGlzKTtcbiAgICAgICAgdmlldy52aWV3VHlwZSA9IHJldXNlVHlwZTtcbiAgICAgICAgaWYgKCF0aGlzLl9hbmltYXRlZENvbnRlbnRPZmZzZXQuaXNPcmlnaW4oKSkge1xuICAgICAgICAgICAgbGF5b3V0SW5mbyA9IGxheW91dEluZm8uY29weSgpO1xuICAgICAgICAgICAgbGF5b3V0SW5mby5yZWN0LnggKz0gdGhpcy5fYW5pbWF0ZWRDb250ZW50T2Zmc2V0Lng7XG4gICAgICAgICAgICBsYXlvdXRJbmZvLnJlY3QueSArPSB0aGlzLl9hbmltYXRlZENvbnRlbnRPZmZzZXQueTtcbiAgICAgICAgfVxuICAgICAgICB2aWV3LmxheW91dEluZm8gPSBsYXlvdXRJbmZvO1xuICAgICAgICB0aGlzLl9yZW5kZXJWaWV3KHZpZXcpO1xuICAgICAgICByZXR1cm4gdmlldztcbiAgICB9XG4gICAgX3JlbmRlclZpZXcocmV1c2FibGVWaWV3KSB7XG4gICAgICAgIGxldCB7IHR5cGU6IHR5cGUsIGtleToga2V5IH0gPSByZXVzYWJsZVZpZXcubGF5b3V0SW5mbztcbiAgICAgICAgcmV1c2FibGVWaWV3LmNvbnRlbnQgPSB0aGlzLmdldEl0ZW0oa2V5KTtcbiAgICAgICAgcmV1c2FibGVWaWV3LnJlbmRlcmVkID0gdGhpcy5fcmVuZGVyQ29udGVudCh0eXBlLCByZXVzYWJsZVZpZXcuY29udGVudCk7XG4gICAgfVxuICAgIF9yZW5kZXJDb250ZW50KHR5cGUsIGNvbnRlbnQpIHtcbiAgICAgICAgbGV0IGNhY2hlZCA9IHRoaXMuX3JlbmRlcmVkQ29udGVudC5nZXQoY29udGVudCk7XG4gICAgICAgIGlmIChjYWNoZWQgIT0gbnVsbCkgcmV0dXJuIGNhY2hlZDtcbiAgICAgICAgbGV0IHJlbmRlcmVkID0gdGhpcy5kZWxlZ2F0ZS5yZW5kZXJWaWV3KHR5cGUsIGNvbnRlbnQpO1xuICAgICAgICBpZiAoY29udGVudCkgdGhpcy5fcmVuZGVyZWRDb250ZW50LnNldChjb250ZW50LCByZW5kZXJlZCk7XG4gICAgICAgIHJldHVybiByZW5kZXJlZDtcbiAgICB9XG4gICAgLyoqXG4gICAqIFJldHVybnMgYW4gYXJyYXkgb2YgYWxsIGN1cnJlbnRseSB2aXNpYmxlIHZpZXdzLCBpbmNsdWRpbmcgYm90aFxuICAgKiBpdGVtIHZpZXdzIGFuZCBzdXBwbGVtZW50YXJ5IHZpZXdzLlxuICAgKi8gZ2V0IHZpc2libGVWaWV3cygpIHtcbiAgICAgICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5fdmlzaWJsZVZpZXdzLnZhbHVlcygpKTtcbiAgICB9XG4gICAgLyoqXG4gICAqIEdldHMgdGhlIHZpc2libGUgdmlldyBmb3IgdGhlIGdpdmVuIHR5cGUgYW5kIGtleS4gUmV0dXJucyBudWxsIGlmXG4gICAqIHRoZSB2aWV3IGlzIG5vdCBjdXJyZW50bHkgdmlzaWJsZS5cbiAgICpcbiAgICogQHBhcmFtIGtleSBUaGUga2V5IG9mIHRoZSB2aWV3IHRvIHJldHJpZXZlLlxuICAgKi8gZ2V0VmlldyhrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Zpc2libGVWaWV3cy5nZXQoa2V5KSB8fCBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICogUmV0dXJucyBhbiBhcnJheSBvZiB2aXNpYmxlIHZpZXdzIG1hdGNoaW5nIHRoZSBnaXZlbiB0eXBlLlxuICAgKiBAcGFyYW0gdHlwZSBUaGUgdmlldyB0eXBlIHRvIGZpbmQuXG4gICAqLyBnZXRWaWV3c09mVHlwZSh0eXBlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZpc2libGVWaWV3cy5maWx0ZXIoKHYpPT52LmxheW91dEluZm8gJiYgdi5sYXlvdXRJbmZvLnR5cGUgPT09IHR5cGUpO1xuICAgIH1cbiAgICAvKipcbiAgICogUmV0dXJucyB0aGUga2V5IGZvciB0aGUgZ2l2ZW4gdmlldy4gUmV0dXJucyBudWxsXG4gICAqIGlmIHRoZSB2aWV3IGlzIG5vdCBjdXJyZW50bHkgdmlzaWJsZS5cbiAgICovIGtleUZvclZpZXcodmlldykge1xuICAgICAgICBpZiAodmlldyAmJiB2aWV3LmxheW91dEluZm8pIHJldHVybiB2aWV3LmxheW91dEluZm8ua2V5O1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAqIFJldHVybnMgdGhlIGtleSBmb3IgdGhlIGl0ZW0gdmlldyBjdXJyZW50bHkgYXQgdGhlIGdpdmVuIHBvaW50LlxuICAgKi8ga2V5QXRQb2ludChwb2ludCkge1xuICAgICAgICBsZXQgcmVjdCA9IG5ldyAoMCwgJDYwNDIzZjkyYzdmOWFkODckZXhwb3J0JGM3OWZjNjQ5MmYzYWYxM2QpKHBvaW50LngsIHBvaW50LnksIDEsIDEpO1xuICAgICAgICBsZXQgbGF5b3V0SW5mb3MgPSB0aGlzLmxheW91dC5nZXRWaXNpYmxlTGF5b3V0SW5mb3MocmVjdCk7XG4gICAgICAgIC8vIExheW91dCBtYXkgcmV0dXJuIG11bHRpcGxlIGxheW91dCBpbmZvcyBpbiB0aGUgY2FzZSBvZlxuICAgICAgICAvLyBwZXJzaXN0ZWQga2V5cywgc28gZmluZCB0aGUgZmlyc3Qgb25lIHRoYXQgYWN0dWFsbHkgaW50ZXJzZWN0cy5cbiAgICAgICAgZm9yIChsZXQgbGF5b3V0SW5mbyBvZiBsYXlvdXRJbmZvcyl7XG4gICAgICAgICAgICBpZiAobGF5b3V0SW5mby5yZWN0LmludGVyc2VjdHMocmVjdCkpIHJldHVybiBsYXlvdXRJbmZvLmtleTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAqIENsZWFudXAgZm9yIHdoZW4gdGhlIFZpcnR1YWxpemVyIHdpbGwgYmUgdW5tb3VudGVkLlxuICAgKi8gd2lsbFVubW91bnQoKSB7XG4gICAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuX3JlbGF5b3V0UmFmKTtcbiAgICB9XG4gICAgLyoqXG4gICAqIFRyaWdnZXJzIGEgbGF5b3V0IGludmFsaWRhdGlvbiwgYW5kIHVwZGF0ZXMgdGhlIHZpc2libGUgc3Vidmlld3MuXG4gICAqLyByZWxheW91dChjb250ZXh0ID0ge30pIHtcbiAgICAgICAgLy8gSWdub3JlIHJlbGF5b3V0cyB3aGlsZSBhbmltYXRpbmcgdGhlIHNjcm9sbCBwb3NpdGlvblxuICAgICAgICBpZiAodGhpcy5fc2Nyb2xsQW5pbWF0aW9uIHx8IHR5cGVvZiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPT09IFwidW5kZWZpbmVkXCIpIHJldHVybjtcbiAgICAgICAgLy8gSWYgd2UgYWxyZWFkeSBzY2hlZHVsZWQgYSByZWxheW91dCwgZXh0ZW5kIHRoZSBpbnZhbGlkYXRpb25cbiAgICAgICAgLy8gY29udGV4dCBzbyB3ZSBjb2FsZXNjZSBtdWx0aXBsZSByZWxheW91dHMgaW4gdGhlIHNhbWUgZnJhbWUuXG4gICAgICAgIGlmICh0aGlzLl9pbnZhbGlkYXRpb25Db250ZXh0KSB7XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMuX2ludmFsaWRhdGlvbkNvbnRleHQsIGNvbnRleHQpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2ludmFsaWRhdGlvbkNvbnRleHQgPSBjb250ZXh0O1xuICAgIH1cbiAgICAvKipcbiAgICogUGVyZm9ybXMgYSByZWxheW91dCBpbW1lZGlhdGVseS4gUHJlZmVyIHtAbGluayByZWxheW91dH0gb3ZlciB0aGlzIG1ldGhvZFxuICAgKiB3aGVyZSBwb3NzaWJsZSwgc2luY2UgaXQgY29hbGVzY2VzIG11bHRpcGxlIGxheW91dCBwYXNzZXMgaW4gdGhlIHNhbWUgdGljay5cbiAgICovIHJlbGF5b3V0Tm93KGNvbnRleHQgPSB0aGlzLl9pbnZhbGlkYXRpb25Db250ZXh0IHx8IHt9KSB7XG4gICAgICAgIC8vIENhbmNlbCB0aGUgc2NoZWR1bGVkIHJlbGF5b3V0LCBzaW5jZSB3ZSdyZSBkb2luZyBpdCBub3cuXG4gICAgICAgIGlmICh0aGlzLl9yZWxheW91dFJhZikge1xuICAgICAgICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5fcmVsYXlvdXRSYWYpO1xuICAgICAgICAgICAgdGhpcy5fcmVsYXlvdXRSYWYgPSBudWxsO1xuICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSBwcm92aWRlZCBjb250ZXh0IHdpdGggdGhlIGN1cnJlbnQgaW52YWxpZGF0aW9uQ29udGV4dCBzaW5jZSB3ZSBhcmUgY2FuY2VsbGluZ1xuICAgICAgICAgICAgLy8gYSBzY2hlZHVsZWQgcmVsYXlvdXROb3cgY2FsbCB0aGF0IGhhcyB0aGlzLl9pbnZhbGlkYXRpb25Db250ZXh0IHNldCBhcyBpdHMgZGVmYXVsdCBjb250ZXh0IGFyZyAocmVsYXlvdXROb3coKSBpbiByZWxheW91dClcbiAgICAgICAgICAgIGNvbnRleHQgPSB7XG4gICAgICAgICAgICAgICAgLi4udGhpcy5faW52YWxpZGF0aW9uQ29udGV4dCxcbiAgICAgICAgICAgICAgICAuLi5jb250ZXh0XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlc2V0IHRoZSBpbnZhbGlkYXRpb24gY29udGV4dFxuICAgICAgICB0aGlzLl9pbnZhbGlkYXRpb25Db250ZXh0ID0gbnVsbDtcbiAgICAgICAgLy8gRG8gbm90aGluZyBpZiB3ZSBkb24ndCBoYXZlIGEgbGF5b3V0IG9yIGNvbnRlbnQsIG9yIHdlIGFyZVxuICAgICAgICAvLyBpbiB0aGUgbWlkZGxlIG9mIGFuIGFuaW1hdGVkIHNjcm9sbCB0cmFuc2l0aW9uLlxuICAgICAgICBpZiAoIXRoaXMubGF5b3V0IHx8ICF0aGlzLl9jb2xsZWN0aW9uIHx8IHRoaXMuX3Njcm9sbEFuaW1hdGlvbikgcmV0dXJuO1xuICAgICAgICBsZXQgc2Nyb2xsQW5jaG9yID0gdGhpcy5fZ2V0U2Nyb2xsQW5jaG9yKCk7XG4gICAgICAgIC8vIFRyaWdnZXIgdGhlIGJlZm9yZUxheW91dCBob29rLCBpZiBwcm92aWRlZFxuICAgICAgICBpZiAodHlwZW9mIGNvbnRleHQuYmVmb3JlTGF5b3V0ID09PSBcImZ1bmN0aW9uXCIpIGNvbnRleHQuYmVmb3JlTGF5b3V0KCk7XG4gICAgICAgIC8vIFZhbGlkYXRlIHRoZSBsYXlvdXRcbiAgICAgICAgdGhpcy5sYXlvdXQudmFsaWRhdGUoY29udGV4dCk7XG4gICAgICAgIHRoaXMuX3NldENvbnRlbnRTaXplKHRoaXMubGF5b3V0LmdldENvbnRlbnRTaXplKCkpO1xuICAgICAgICAvLyBUcmlnZ2VyIHRoZSBhZnRlckxheW91dCBob29rLCBpZiBwcm92aWRlZFxuICAgICAgICBpZiAodHlwZW9mIGNvbnRleHQuYWZ0ZXJMYXlvdXQgPT09IFwiZnVuY3Rpb25cIikgY29udGV4dC5hZnRlckxheW91dCgpO1xuICAgICAgICAvLyBBZGp1c3Qgc2Nyb2xsIHBvc2l0aW9uIGJhc2VkIG9uIHNjcm9sbCBhbmNob3IsIGFuZCBjb25zdHJhaW4uXG4gICAgICAgIC8vIElmIHRoZSBjb250ZW50IGNoYW5nZWQsIHNjcm9sbCB0byB0aGUgdG9wLlxuICAgICAgICBsZXQgdmlzaWJsZVJlY3QgPSB0aGlzLmdldFZpc2libGVSZWN0KCk7XG4gICAgICAgIGxldCByZXN0b3JlZFNjcm9sbEFuY2hvciA9IHRoaXMuX3Jlc3RvcmVTY3JvbGxBbmNob3Ioc2Nyb2xsQW5jaG9yLCBjb250ZXh0KTtcbiAgICAgICAgbGV0IGNvbnRlbnRPZmZzZXRYID0gY29udGV4dC5jb250ZW50Q2hhbmdlZCA/IDAgOiByZXN0b3JlZFNjcm9sbEFuY2hvci54O1xuICAgICAgICBsZXQgY29udGVudE9mZnNldFkgPSBjb250ZXh0LmNvbnRlbnRDaGFuZ2VkID8gMCA6IHJlc3RvcmVkU2Nyb2xsQW5jaG9yLnk7XG4gICAgICAgIGNvbnRlbnRPZmZzZXRYID0gTWF0aC5tYXgoMCwgTWF0aC5taW4odGhpcy5jb250ZW50U2l6ZS53aWR0aCAtIHZpc2libGVSZWN0LndpZHRoLCBjb250ZW50T2Zmc2V0WCkpO1xuICAgICAgICBjb250ZW50T2Zmc2V0WSA9IE1hdGgubWF4KDAsIE1hdGgubWluKHRoaXMuY29udGVudFNpemUuaGVpZ2h0IC0gdmlzaWJsZVJlY3QuaGVpZ2h0LCBjb250ZW50T2Zmc2V0WSkpO1xuICAgICAgICBsZXQgaGFzTGF5b3V0VXBkYXRlcyA9IGZhbHNlO1xuICAgICAgICBpZiAoY29udGVudE9mZnNldFggIT09IHZpc2libGVSZWN0LnggfHwgY29udGVudE9mZnNldFkgIT09IHZpc2libGVSZWN0LnkpIHtcbiAgICAgICAgICAgIC8vIElmIHRoaXMgaXMgYW4gYW5pbWF0ZWQgcmVsYXlvdXQsIHdlIGRvIG5vdCBpbW1lZGlhdGVseSBzY3JvbGwgYmVjYXVzZSBpdCB3b3VsZCBiZSBqaXR0ZXJ5LlxuICAgICAgICAgICAgLy8gU2F2ZSB0aGUgZGlmZmVyZW5jZSBiZXR3ZWVuIHRoZSBjdXJyZW50IGFuZCBuZXcgY29udGVudCBvZmZzZXRzLCBhbmQgYXBwbHkgaXQgdG8gdGhlXG4gICAgICAgICAgICAvLyBpbmRpdmlkdWFsIGNvbnRlbnQgaXRlbXMgaW5zdGVhZC4gQXQgdGhlIGVuZCBvZiB0aGUgYW5pbWF0aW9uLCB3ZSdsbCByZXNldCBhbmQgc2V0IHRoZVxuICAgICAgICAgICAgLy8gc2Nyb2xsIG9mZnNldCBmb3IgcmVhbC4gVGhpcyBlbnN1cmVzIGppdHRlci1mcmVlIGFuaW1hdGlvbiBzaW5jZSB3ZSBkb24ndCBuZWVkIHRvIHN5bmNcbiAgICAgICAgICAgIC8vIHRoZSBzY3JvbGwgYW5pbWF0aW9uIGFuZCB0aGUgY29udGVudCBhbmltYXRpb24uXG4gICAgICAgICAgICBpZiAoY29udGV4dC5hbmltYXRlZCB8fCAhdGhpcy5fYW5pbWF0ZWRDb250ZW50T2Zmc2V0LmlzT3JpZ2luKCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9hbmltYXRlZENvbnRlbnRPZmZzZXQueCArPSB2aXNpYmxlUmVjdC54IC0gY29udGVudE9mZnNldFg7XG4gICAgICAgICAgICAgICAgdGhpcy5fYW5pbWF0ZWRDb250ZW50T2Zmc2V0LnkgKz0gdmlzaWJsZVJlY3QueSAtIGNvbnRlbnRPZmZzZXRZO1xuICAgICAgICAgICAgICAgIGhhc0xheW91dFVwZGF0ZXMgPSB0aGlzLnVwZGF0ZVN1YnZpZXdzKGNvbnRleHQuY29udGVudENoYW5nZWQpO1xuICAgICAgICAgICAgfSBlbHNlIHRoaXMuX3NldENvbnRlbnRPZmZzZXQobmV3ICgwLCAkMzA0MWRiMzI5Njk0NWU2ZSRleHBvcnQkYmFmMjYxNDZhNDE0ZjI0YSkoY29udGVudE9mZnNldFgsIGNvbnRlbnRPZmZzZXRZKSk7XG4gICAgICAgIH0gZWxzZSBoYXNMYXlvdXRVcGRhdGVzID0gdGhpcy51cGRhdGVTdWJ2aWV3cyhjb250ZXh0LmNvbnRlbnRDaGFuZ2VkKTtcbiAgICAgICAgLy8gQXBwbHkgbGF5b3V0IGluZm9zLCB1bmxlc3MgdGhpcyBpcyBjb21pbmcgZnJvbSBhbiBhbmltYXRlZCB0cmFuc2FjdGlvblxuICAgICAgICBpZiAoIShjb250ZXh0LnRyYW5zYWN0aW9uICYmIGNvbnRleHQuYW5pbWF0ZWQpKSB0aGlzLl9hcHBseUxheW91dEluZm9zKCk7XG4gICAgICAgIC8vIFdhaXQgZm9yIGFuaW1hdGlvbnMsIGFuZCBhcHBseSB0aGUgYWZ0ZXJBbmltYXRpb24gaG9vaywgaWYgcHJvdmlkZWRcbiAgICAgICAgaWYgKGNvbnRleHQuYW5pbWF0ZWQgJiYgaGFzTGF5b3V0VXBkYXRlcykge1xuICAgICAgICAgICAgdGhpcy5fZW5hYmxlVHJhbnNpdGlvbnMoKTtcbiAgICAgICAgICAgIGxldCBkb25lID0gKCk9PntcbiAgICAgICAgICAgICAgICB0aGlzLl9kaXNhYmxlVHJhbnNpdGlvbnMoKTtcbiAgICAgICAgICAgICAgICAvLyBSZXNldCBzY3JvbGwgcG9zaXRpb24gYWZ0ZXIgYW5pbWF0aW9ucyAoc2VlIGFib3ZlIGNvbW1lbnQpLlxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5fYW5pbWF0ZWRDb250ZW50T2Zmc2V0LmlzT3JpZ2luKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gR2V0IHRoZSBjb250ZW50IG9mZnNldCB0byBzY3JvbGwgdG8sIHRha2luZyBfYW5pbWF0ZWRDb250ZW50T2Zmc2V0IGludG8gYWNjb3VudC5cbiAgICAgICAgICAgICAgICAgICAgbGV0IHsgeDogeCwgeTogeSB9ID0gdGhpcy5nZXRWaXNpYmxlUmVjdCgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZXNldEFuaW1hdGVkQ29udGVudE9mZnNldCgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zZXRDb250ZW50T2Zmc2V0KG5ldyAoMCwgJDMwNDFkYjMyOTY5NDVlNmUkZXhwb3J0JGJhZjI2MTQ2YTQxNGYyNGEpKHgsIHkpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjb250ZXh0LmFmdGVyQW5pbWF0aW9uID09PSBcImZ1bmN0aW9uXCIpIGNvbnRleHQuYWZ0ZXJBbmltYXRpb24oKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvLyBTb21ldGltZXMgdGhlIGFuaW1hdGlvbiB0YWtlcyBzbGlnaHRseSBsb25nZXIgdGhhbiBleHBlY3RlZC5cbiAgICAgICAgICAgIHNldFRpbWVvdXQoZG9uZSwgdGhpcy50cmFuc2l0aW9uRHVyYXRpb24gKyAxMDApO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBjb250ZXh0LmFmdGVyQW5pbWF0aW9uID09PSBcImZ1bmN0aW9uXCIpIGNvbnRleHQuYWZ0ZXJBbmltYXRpb24oKTtcbiAgICB9XG4gICAgLyoqXG4gICAqIENvcnJlY3RzIERPTSBvcmRlciBvZiB2aXNpYmxlIHZpZXdzIHRvIG1hdGNoIGl0ZW0gb3JkZXIgb2YgY29sbGVjdGlvbi5cbiAgICovIF9jb3JyZWN0SXRlbU9yZGVyKCkge1xuICAgICAgICAvLyBEZWZlciB1bnRpbCBhZnRlciBzY3JvbGxpbmcgYW5kIGFuaW1hdGVkIHRyYW5zYWN0aW9ucyBhcmUgY29tcGxldGVcbiAgICAgICAgaWYgKHRoaXMuX2lzU2Nyb2xsaW5nIHx8IHRoaXMuX3RyYW5zYWN0aW9uKSByZXR1cm47XG4gICAgICAgIGZvciAobGV0IGtleSBvZiB0aGlzLl92aXNpYmxlTGF5b3V0SW5mb3Mua2V5cygpKXtcbiAgICAgICAgICAgIGxldCB2aWV3ID0gdGhpcy5fdmlzaWJsZVZpZXdzLmdldChrZXkpO1xuICAgICAgICAgICAgdGhpcy5fY2hpbGRyZW4uZGVsZXRlKHZpZXcpO1xuICAgICAgICAgICAgdGhpcy5fY2hpbGRyZW4uYWRkKHZpZXcpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9lbmFibGVUcmFuc2l0aW9ucygpIHtcbiAgICAgICAgdGhpcy5kZWxlZ2F0ZS5iZWdpbkFuaW1hdGlvbnMoKTtcbiAgICB9XG4gICAgX2Rpc2FibGVUcmFuc2l0aW9ucygpIHtcbiAgICAgICAgdGhpcy5kZWxlZ2F0ZS5lbmRBbmltYXRpb25zKCk7XG4gICAgfVxuICAgIF9nZXRTY3JvbGxBbmNob3IoKSB7XG4gICAgICAgIGlmICghdGhpcy5hbmNob3JTY3JvbGxQb3NpdGlvbikgcmV0dXJuIG51bGw7XG4gICAgICAgIGxldCB2aXNpYmxlUmVjdCA9IHRoaXMuZ2V0VmlzaWJsZVJlY3QoKTtcbiAgICAgICAgLy8gQXNrIHRoZSBkZWxlZ2F0ZSB0byBwcm92aWRlIGEgc2Nyb2xsIGFuY2hvciwgaWYgcG9zc2libGVcbiAgICAgICAgaWYgKHRoaXMuZGVsZWdhdGUuZ2V0U2Nyb2xsQW5jaG9yKSB7XG4gICAgICAgICAgICBsZXQga2V5ID0gdGhpcy5kZWxlZ2F0ZS5nZXRTY3JvbGxBbmNob3IodmlzaWJsZVJlY3QpO1xuICAgICAgICAgICAgaWYgKGtleSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgbGV0IGxheW91dEluZm8gPSB0aGlzLmxheW91dC5nZXRMYXlvdXRJbmZvKGtleSk7XG4gICAgICAgICAgICAgICAgbGV0IGNvcm5lciA9IGxheW91dEluZm8ucmVjdC5nZXRDb3JuZXJJblJlY3QodmlzaWJsZVJlY3QpO1xuICAgICAgICAgICAgICAgIGlmIChjb3JuZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGtleSA9IGxheW91dEluZm8ua2V5O1xuICAgICAgICAgICAgICAgICAgICBsZXQgb2Zmc2V0ID0gbGF5b3V0SW5mby5yZWN0W2Nvcm5lcl0ueSAtIHZpc2libGVSZWN0Lnk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXk6IGtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxheW91dEluZm86IGxheW91dEluZm8sXG4gICAgICAgICAgICAgICAgICAgICAgICBjb3JuZXI6IGNvcm5lcixcbiAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldDogb2Zmc2V0XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIE5vIG5lZWQgdG8gYW5jaG9yIHRoZSBzY3JvbGwgcG9zaXRpb24gaWYgaXQgaXMgYXQgdGhlIHRvcFxuICAgICAgICBpZiAodmlzaWJsZVJlY3QueSA9PT0gMCAmJiAhdGhpcy5hbmNob3JTY3JvbGxQb3NpdGlvbkF0VG9wKSByZXR1cm4gbnVsbDtcbiAgICAgICAgLy8gRmluZCBhIHZpZXcgd2l0aCBhIHZpc2libGUgY29ybmVyIHRoYXQgaGFzIHRoZSBzbWFsbGVzdCBkaXN0YW5jZSB0byB0aGUgdG9wIG9mIHRoZSBjb2xsZWN0aW9uIHZpZXdcbiAgICAgICAgbGV0IGNvcm5lckFuY2hvciA9IG51bGw7XG4gICAgICAgIGZvciAobGV0IFtrZXksIHZpZXddIG9mIHRoaXMuX3Zpc2libGVWaWV3cyl7XG4gICAgICAgICAgICBsZXQgbGF5b3V0SW5mbyA9IHZpZXcubGF5b3V0SW5mbztcbiAgICAgICAgICAgIGlmIChsYXlvdXRJbmZvICYmIGxheW91dEluZm8ucmVjdC5hcmVhID4gMCkge1xuICAgICAgICAgICAgICAgIGxldCBjb3JuZXIgPSBsYXlvdXRJbmZvLnJlY3QuZ2V0Q29ybmVySW5SZWN0KHZpc2libGVSZWN0KTtcbiAgICAgICAgICAgICAgICBpZiAoY29ybmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBvZmZzZXQgPSBsYXlvdXRJbmZvLnJlY3RbY29ybmVyXS55IC0gdmlzaWJsZVJlY3QueTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjb3JuZXJBbmNob3IgfHwgb2Zmc2V0IDwgY29ybmVyQW5jaG9yLm9mZnNldCkgY29ybmVyQW5jaG9yID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAga2V5OiBrZXksXG4gICAgICAgICAgICAgICAgICAgICAgICBsYXlvdXRJbmZvOiBsYXlvdXRJbmZvLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29ybmVyOiBjb3JuZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXQ6IG9mZnNldFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29ybmVyQW5jaG9yO1xuICAgIH1cbiAgICBfcmVzdG9yZVNjcm9sbEFuY2hvcihzY3JvbGxBbmNob3IsIGNvbnRleHQpIHtcbiAgICAgICAgbGV0IGNvbnRlbnRPZmZzZXQgPSB0aGlzLmdldFZpc2libGVSZWN0KCk7XG4gICAgICAgIGlmIChzY3JvbGxBbmNob3IpIHtcbiAgICAgICAgICAgIHZhciBfY29udGV4dF90cmFuc2FjdGlvbjtcbiAgICAgICAgICAgIGxldCBmaW5hbEFuY2hvciA9ICgoX2NvbnRleHRfdHJhbnNhY3Rpb24gPSBjb250ZXh0LnRyYW5zYWN0aW9uKSA9PT0gbnVsbCB8fCBfY29udGV4dF90cmFuc2FjdGlvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2NvbnRleHRfdHJhbnNhY3Rpb24uYW5pbWF0ZWQpID8gY29udGV4dC50cmFuc2FjdGlvbi5maW5hbE1hcC5nZXQoc2Nyb2xsQW5jaG9yLmtleSkgOiB0aGlzLmxheW91dC5nZXRMYXlvdXRJbmZvKHNjcm9sbEFuY2hvci5sYXlvdXRJbmZvLmtleSk7XG4gICAgICAgICAgICBpZiAoZmluYWxBbmNob3IpIHtcbiAgICAgICAgICAgICAgICBsZXQgYWRqdXN0bWVudCA9IGZpbmFsQW5jaG9yLnJlY3Rbc2Nyb2xsQW5jaG9yLmNvcm5lcl0ueSAtIGNvbnRlbnRPZmZzZXQueSAtIHNjcm9sbEFuY2hvci5vZmZzZXQ7XG4gICAgICAgICAgICAgICAgY29udGVudE9mZnNldC55ICs9IGFkanVzdG1lbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbnRlbnRPZmZzZXQ7XG4gICAgfVxuICAgIGdldFZpc2libGVSZWN0KCkge1xuICAgICAgICBsZXQgdiA9IHRoaXMudmlzaWJsZVJlY3Q7XG4gICAgICAgIGxldCB4ID0gdi54IC0gdGhpcy5fYW5pbWF0ZWRDb250ZW50T2Zmc2V0Lng7XG4gICAgICAgIGxldCB5ID0gdi55IC0gdGhpcy5fYW5pbWF0ZWRDb250ZW50T2Zmc2V0Lnk7XG4gICAgICAgIHJldHVybiBuZXcgKDAsICQ2MDQyM2Y5MmM3ZjlhZDg3JGV4cG9ydCRjNzlmYzY0OTJmM2FmMTNkKSh4LCB5LCB2LndpZHRoLCB2LmhlaWdodCk7XG4gICAgfVxuICAgIGdldFZpc2libGVMYXlvdXRJbmZvcygpIHtcbiAgICAgICAgbGV0IHJlY3QgPSB0aGlzLnNob3VsZE92ZXJzY2FuID8gdGhpcy5fb3ZlcnNjYW5NYW5hZ2VyLmdldE92ZXJzY2FubmVkUmVjdCgpIDogdGhpcy5nZXRWaXNpYmxlUmVjdCgpO1xuICAgICAgICB0aGlzLl92aXNpYmxlTGF5b3V0SW5mb3MgPSB0aGlzLl9nZXRMYXlvdXRJbmZvTWFwKHJlY3QpO1xuICAgICAgICByZXR1cm4gdGhpcy5fdmlzaWJsZUxheW91dEluZm9zO1xuICAgIH1cbiAgICBfZ2V0TGF5b3V0SW5mb01hcChyZWN0LCBjb3B5ID0gZmFsc2UpIHtcbiAgICAgICAgbGV0IGxheW91dEluZm9zID0gdGhpcy5sYXlvdXQuZ2V0VmlzaWJsZUxheW91dEluZm9zKHJlY3QpO1xuICAgICAgICBsZXQgbWFwID0gbmV3IE1hcDtcbiAgICAgICAgZm9yIChsZXQgbGF5b3V0SW5mbyBvZiBsYXlvdXRJbmZvcyl7XG4gICAgICAgICAgICBpZiAoY29weSkgbGF5b3V0SW5mbyA9IGxheW91dEluZm8uY29weSgpO1xuICAgICAgICAgICAgbWFwLnNldChsYXlvdXRJbmZvLmtleSwgbGF5b3V0SW5mbyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1hcDtcbiAgICB9XG4gICAgdXBkYXRlU3Vidmlld3MoZm9yY2VVcGRhdGUgPSBmYWxzZSkge1xuICAgICAgICBpZiAoIXRoaXMuX2NvbGxlY3Rpb24pIHJldHVybjtcbiAgICAgICAgbGV0IHZpc2libGVMYXlvdXRJbmZvcyA9IHRoaXMuZ2V0VmlzaWJsZUxheW91dEluZm9zKCk7XG4gICAgICAgIGxldCBjdXJyZW50bHlWaXNpYmxlID0gdGhpcy5fdmlzaWJsZVZpZXdzO1xuICAgICAgICBsZXQgdG9BZGQsIHRvUmVtb3ZlLCB0b1VwZGF0ZTtcbiAgICAgICAgLy8gSWYgdGhpcyBpcyBhIGZvcmNlIHVwZGF0ZSwgcmVtb3ZlIGFuZCByZS1hZGQgYWxsIHZpZXdzLlxuICAgICAgICAvLyBPdGhlcndpc2UsIGZpbmQgYW5kIHVwZGF0ZSB0aGUgZGlmZi5cbiAgICAgICAgaWYgKGZvcmNlVXBkYXRlKSB7XG4gICAgICAgICAgICB0b0FkZCA9IHZpc2libGVMYXlvdXRJbmZvcztcbiAgICAgICAgICAgIHRvUmVtb3ZlID0gY3VycmVudGx5VmlzaWJsZTtcbiAgICAgICAgICAgIHRvVXBkYXRlID0gbmV3IFNldCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgKHsgdG9BZGQ6IHRvQWRkLCB0b1JlbW92ZTogdG9SZW1vdmUsIHRvVXBkYXRlOiB0b1VwZGF0ZSB9ID0gKDAsICRmYzM2ZjlhMDQ2YTljZTc5JGV4cG9ydCRhY2FmOTZhMjc0MzgyNDZiKShjdXJyZW50bHlWaXNpYmxlLCB2aXNpYmxlTGF5b3V0SW5mb3MpKTtcbiAgICAgICAgICAgIGZvciAobGV0IGtleSBvZiB0b1VwZGF0ZSl7XG4gICAgICAgICAgICAgICAgbGV0IHZpZXcgPSBjdXJyZW50bHlWaXNpYmxlLmdldChrZXkpO1xuICAgICAgICAgICAgICAgIGlmICghdmlldyB8fCAhdmlldy5sYXlvdXRJbmZvKSBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBsZXQgaXRlbSA9IHRoaXMuZ2V0SXRlbSh2aXNpYmxlTGF5b3V0SW5mb3MuZ2V0KGtleSkua2V5KTtcbiAgICAgICAgICAgICAgICBpZiAodmlldy5jb250ZW50ID09PSBpdGVtKSB0b1VwZGF0ZS5kZWxldGUoa2V5KTtcbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIHZpZXcgdHlwZSBjaGFuZ2VzLCBkZWxldGUgYW5kIHJlY3JlYXRlIHRoZSB2aWV3IGluc3RlYWQgb2YgdXBkYXRpbmdcbiAgICAgICAgICAgICAgICAgICAgbGV0IHsgcmV1c2VUeXBlOiByZXVzZVR5cGUgfSA9IHRoaXMuX2dldFJldXNlVHlwZSh2aWV3LmxheW91dEluZm8sIGl0ZW0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAodmlldy52aWV3VHlwZSAhPT0gcmV1c2VUeXBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b1VwZGF0ZS5kZWxldGUoa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvQWRkLmFkZChrZXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9SZW1vdmUuYWRkKGtleSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBXZSBhcmUgZG9uZSBpZiB0aGUgc2V0cyBhcmUgZXF1YWxcbiAgICAgICAgICAgIGlmICh0b0FkZC5zaXplID09PSAwICYmIHRvUmVtb3ZlLnNpemUgPT09IDAgJiYgdG9VcGRhdGUuc2l6ZSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl90cmFuc2FjdGlvbikgdGhpcy5fYXBwbHlMYXlvdXRJbmZvcygpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBUcmFjayB2aWV3cyB0aGF0IHNob3VsZCBiZSByZW1vdmVkLiBUaGV5IGFyZSBub3QgcmVtb3ZlZCBmcm9tXG4gICAgICAgIC8vIHRoZSBET00gaW1tZWRpYXRlbHksIHNpbmNlIHdlIG1heSByZXVzZSBhbmQgbmVlZCB0byByZS1pbnNlcnRcbiAgICAgICAgLy8gdGhlbSBiYWNrIGludG8gdGhlIERPTSBhbnl3YXkuXG4gICAgICAgIGxldCByZW1vdmVkID0gbmV3IFNldCgpO1xuICAgICAgICBmb3IgKGxldCBrZXkgb2YgdG9SZW1vdmUua2V5cygpKXtcbiAgICAgICAgICAgIGxldCB2aWV3ID0gdGhpcy5fdmlzaWJsZVZpZXdzLmdldChrZXkpO1xuICAgICAgICAgICAgaWYgKHZpZXcpIHtcbiAgICAgICAgICAgICAgICByZW1vdmVkLmFkZCh2aWV3KTtcbiAgICAgICAgICAgICAgICB0aGlzLl92aXNpYmxlVmlld3MuZGVsZXRlKGtleSk7XG4gICAgICAgICAgICAgICAgLy8gSWYgd2UgYXJlIGluIHRoZSBtaWRkbGUgb2YgYSB0cmFuc2FjdGlvbiwgd2FpdCB1bnRpbCB0aGUgZW5kXG4gICAgICAgICAgICAgICAgLy8gb2YgdGhlIGFuaW1hdGlvbnMgdG8gcmVtb3ZlIHRoZSB2aWV3cyBmcm9tIHRoZSBET00uIEFsc28gbWVhbnNcbiAgICAgICAgICAgICAgICAvLyB3ZSBjYW4ndCByZXVzZSB0aG9zZSB2aWV3cyBpbW1lZGlhdGVseS5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fdHJhbnNhY3Rpb24pIHRoaXMuX3RyYW5zYWN0aW9uLnRvUmVtb3ZlLnNldChrZXksIHZpZXcpO1xuICAgICAgICAgICAgICAgIGVsc2UgdGhpcy5yZXVzZVZpZXcodmlldyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQga2V5IG9mIHRvQWRkLmtleXMoKSl7XG4gICAgICAgICAgICBsZXQgbGF5b3V0SW5mbyA9IHZpc2libGVMYXlvdXRJbmZvcy5nZXQoa2V5KTtcbiAgICAgICAgICAgIGxldCB2aWV3O1xuICAgICAgICAgICAgLy8gSWYgd2UncmUgaW4gYSB0cmFuc2FjdGlvbiwgYW5kIGEgbGF5b3V0IGNoYW5nZSBoYXBwZW5zXG4gICAgICAgICAgICAvLyBkdXJpbmcgdGhlIGFuaW1hdGlvbnMgc3VjaCB0aGF0IGEgdmlldyB0aGF0IHdhcyBnb2luZ1xuICAgICAgICAgICAgLy8gdG8gYmUgcmVtb3ZlZCBpcyBub3cgbm90LCB3ZSBkb24ndCBjcmVhdGUgYSBuZXcgdmlld1xuICAgICAgICAgICAgLy8gc2luY2UgdGhlIG9sZCBvbmUgaXMgc3RpbGwgaW4gdGhlIERPTSwgbWFya2VkIGFzIHRvUmVtb3ZlLlxuICAgICAgICAgICAgaWYgKHRoaXMuX3RyYW5zYWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgdHJhbnNhY3Rpb24sIGdldCBpbml0aWFsIGxheW91dCBhdHRyaWJ1dGVzIGZvciB0aGUgYW5pbWF0aW9uXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3RyYW5zYWN0aW9uLmluaXRpYWxMYXlvdXRJbmZvLmhhcyhrZXkpKSBsYXlvdXRJbmZvID0gdGhpcy5fdHJhbnNhY3Rpb24uaW5pdGlhbExheW91dEluZm8uZ2V0KGtleSk7XG4gICAgICAgICAgICAgICAgdmlldyA9IHRoaXMuX3RyYW5zYWN0aW9uLnRvUmVtb3ZlLmdldChrZXkpO1xuICAgICAgICAgICAgICAgIGlmICh2aWV3KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3RyYW5zYWN0aW9uLnRvUmVtb3ZlLmRlbGV0ZShrZXkpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9hcHBseUxheW91dEluZm8odmlldywgbGF5b3V0SW5mbyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF2aWV3KSB7XG4gICAgICAgICAgICAgICAgLy8gQ3JlYXRlIG9yIHJldXNlIGEgdmlldyBmb3IgdGhpcyByb3dcbiAgICAgICAgICAgICAgICB2aWV3ID0gdGhpcy5nZXRSZXVzYWJsZVZpZXcobGF5b3V0SW5mbyk7XG4gICAgICAgICAgICAgICAgLy8gQWRkIHRoZSB2aWV3IHRvIHRoZSBET00gaWYgbmVlZGVkXG4gICAgICAgICAgICAgICAgaWYgKCFyZW1vdmVkLmhhcyh2aWV3KSkgdGhpcy5fY2hpbGRyZW4uYWRkKHZpZXcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fdmlzaWJsZVZpZXdzLnNldChrZXksIHZpZXcpO1xuICAgICAgICAgICAgcmVtb3ZlZC5kZWxldGUodmlldyk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQga2V5IG9mIHRvVXBkYXRlKXtcbiAgICAgICAgICAgIGxldCB2aWV3ID0gY3VycmVudGx5VmlzaWJsZS5nZXQoa2V5KTtcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVkQ29udGVudC5kZWxldGUoa2V5KTtcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlclZpZXcodmlldyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVtb3ZlIHRoZSByZW1haW5pbmcgcm93cyB0byBkZWxldGUgZnJvbSB0aGUgRE9NXG4gICAgICAgIGlmICghdGhpcy5fdHJhbnNhY3Rpb24pIHRoaXMucmVtb3ZlVmlld3MocmVtb3ZlZCk7XG4gICAgICAgIHRoaXMuX2NvcnJlY3RJdGVtT3JkZXIoKTtcbiAgICAgICAgdGhpcy5fZmx1c2hWaXNpYmxlVmlld3MoKTtcbiAgICAgICAgbGV0IGhhc0xheW91dFVwZGF0ZXMgPSB0aGlzLl90cmFuc2FjdGlvbiAmJiAodG9BZGQuc2l6ZSA+IDAgfHwgdG9SZW1vdmUuc2l6ZSA+IDAgfHwgdGhpcy5faGFzTGF5b3V0VXBkYXRlcygpKTtcbiAgICAgICAgaWYgKGhhc0xheW91dFVwZGF0ZXMpIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKT0+e1xuICAgICAgICAgICAgLy8gSWYgd2UncmUgaW4gYSB0cmFuc2FjdGlvbiwgYXBwbHkgYW5pbWF0aW9ucyB0byB2aXNpYmxlIHZpZXdzXG4gICAgICAgICAgICAvLyBhbmQgXCJ0byBiZSByZW1vdmVkXCIgdmlld3MsIHdoaWNoIGFuaW1hdGUgb2ZmIHNjcmVlbi5cbiAgICAgICAgICAgIGlmICh0aGlzLl90cmFuc2FjdGlvbikgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpPT50aGlzLl9hcHBseUxheW91dEluZm9zKCkpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGhhc0xheW91dFVwZGF0ZXM7XG4gICAgfVxuICAgIGFmdGVyUmVuZGVyKCkge1xuICAgICAgICBpZiAodGhpcy5fdHJhbnNhY3Rpb25RdWV1ZS5sZW5ndGggPiAwKSB0aGlzLl9wcm9jZXNzVHJhbnNhY3Rpb25RdWV1ZSgpO1xuICAgICAgICBlbHNlIGlmICh0aGlzLl9pbnZhbGlkYXRpb25Db250ZXh0KSB0aGlzLnJlbGF5b3V0Tm93KCk7XG4gICAgICAgIGlmICh0aGlzLnNob3VsZE92ZXJzY2FuKSB0aGlzLl9vdmVyc2Nhbk1hbmFnZXIuY29sbGVjdE1ldHJpY3MoKTtcbiAgICB9XG4gICAgX2ZsdXNoVmlzaWJsZVZpZXdzKCkge1xuICAgICAgICAvLyBDb2xsZWN0aW9uVmlydHVhbGl6ZXIgZGVhbHMgd2l0aCBhIGZsYXR0ZW5lZCBzZXQgb2YgTGF5b3V0SW5mb3MsIGJ1dCB0aGV5IGNhbiByZXByZXNlbnQgaGVpcmFyY2h5XG4gICAgICAgIC8vIGJ5IHJlZmVyZW5jaW5nIGEgcGFyZW50S2V5LiBKdXN0IGJlZm9yZSByZW5kZXJpbmcgdGhlIHZpc2libGUgdmlld3MsIHdlIHJlYnVpbGQgdGhpcyBoZWlyYXJjaHlcbiAgICAgICAgLy8gYnkgY3JlYXRpbmcgYSBtYXBwaW5nIG9mIHZpZXdzIGJ5IHBhcmVudCBrZXkgYW5kIHJlY3Vyc2l2ZWx5IGNhbGxpbmcgdGhlIGRlbGVnYXRlJ3MgcmVuZGVyV3JhcHBlclxuICAgICAgICAvLyBtZXRob2QgdG8gYnVpbGQgdGhlIGZpbmFsIHRyZWUuXG4gICAgICAgIGxldCB2aWV3c0J5UGFyZW50S2V5ID0gbmV3IE1hcChbXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgICBbXVxuICAgICAgICAgICAgXVxuICAgICAgICBdKTtcbiAgICAgICAgZm9yIChsZXQgdmlldyBvZiB0aGlzLl9jaGlsZHJlbil7XG4gICAgICAgICAgICB2YXIgX3ZpZXdfbGF5b3V0SW5mbywgX3ZpZXdzQnlQYXJlbnRLZXlfZ2V0LCBfdmlld19sYXlvdXRJbmZvMSwgX3ZpZXdfbGF5b3V0SW5mbzIsIF92aWV3X2xheW91dEluZm8zO1xuICAgICAgICAgICAgaWYgKCgoX3ZpZXdfbGF5b3V0SW5mbyA9IHZpZXcubGF5b3V0SW5mbykgPT09IG51bGwgfHwgX3ZpZXdfbGF5b3V0SW5mbyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3ZpZXdfbGF5b3V0SW5mby5wYXJlbnRLZXkpICE9IG51bGwgJiYgIXZpZXdzQnlQYXJlbnRLZXkuaGFzKHZpZXcubGF5b3V0SW5mby5wYXJlbnRLZXkpKSB2aWV3c0J5UGFyZW50S2V5LnNldCh2aWV3LmxheW91dEluZm8ucGFyZW50S2V5LCBbXSk7XG4gICAgICAgICAgICAoX3ZpZXdzQnlQYXJlbnRLZXlfZ2V0ID0gdmlld3NCeVBhcmVudEtleS5nZXQoKF92aWV3X2xheW91dEluZm8xID0gdmlldy5sYXlvdXRJbmZvKSA9PT0gbnVsbCB8fCBfdmlld19sYXlvdXRJbmZvMSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3ZpZXdfbGF5b3V0SW5mbzEucGFyZW50S2V5KSkgPT09IG51bGwgfHwgX3ZpZXdzQnlQYXJlbnRLZXlfZ2V0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfdmlld3NCeVBhcmVudEtleV9nZXQucHVzaCh2aWV3KTtcbiAgICAgICAgICAgIGlmICghdmlld3NCeVBhcmVudEtleS5oYXMoKF92aWV3X2xheW91dEluZm8yID0gdmlldy5sYXlvdXRJbmZvKSA9PT0gbnVsbCB8fCBfdmlld19sYXlvdXRJbmZvMiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3ZpZXdfbGF5b3V0SW5mbzIua2V5KSkgdmlld3NCeVBhcmVudEtleS5zZXQoKF92aWV3X2xheW91dEluZm8zID0gdmlldy5sYXlvdXRJbmZvKSA9PT0gbnVsbCB8fCBfdmlld19sYXlvdXRJbmZvMyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3ZpZXdfbGF5b3V0SW5mbzMua2V5LCBbXSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGJ1aWxkVHJlZSA9IChwYXJlbnQsIHZpZXdzKT0+dmlld3MubWFwKCh2aWV3KT0+e1xuICAgICAgICAgICAgICAgIGxldCBjaGlsZHJlbiA9IHZpZXdzQnlQYXJlbnRLZXkuZ2V0KHZpZXcubGF5b3V0SW5mby5rZXkpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmRlbGVnYXRlLnJlbmRlcldyYXBwZXIocGFyZW50LCB2aWV3LCBjaGlsZHJlbiwgKGNoaWxkVmlld3MpPT5idWlsZFRyZWUodmlldywgY2hpbGRWaWV3cykpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIGxldCBjaGlsZHJlbiA9IGJ1aWxkVHJlZShudWxsLCB2aWV3c0J5UGFyZW50S2V5LmdldChudWxsKSk7XG4gICAgICAgIHRoaXMuZGVsZWdhdGUuc2V0VmlzaWJsZVZpZXdzKGNoaWxkcmVuKTtcbiAgICB9XG4gICAgX2FwcGx5TGF5b3V0SW5mbyh2aWV3LCBsYXlvdXRJbmZvKSB7XG4gICAgICAgIGlmICh2aWV3LmxheW91dEluZm8gPT09IGxheW91dEluZm8pIHJldHVybiBmYWxzZTtcbiAgICAgICAgdmlldy5sYXlvdXRJbmZvID0gbGF5b3V0SW5mbztcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIF9hcHBseUxheW91dEluZm9zKCkge1xuICAgICAgICBsZXQgdXBkYXRlZCA9IGZhbHNlO1xuICAgICAgICAvLyBBcHBseSBsYXlvdXQgaW5mb3MgdG8gdmlzaWJsZSB2aWV3c1xuICAgICAgICBmb3IgKGxldCB2aWV3IG9mIHRoaXMuX3Zpc2libGVWaWV3cy52YWx1ZXMoKSl7XG4gICAgICAgICAgICBsZXQgY3VyID0gdmlldy5sYXlvdXRJbmZvO1xuICAgICAgICAgICAgaWYgKChjdXIgPT09IG51bGwgfHwgY3VyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjdXIua2V5KSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgbGV0IGxheW91dEluZm8gPSB0aGlzLmxheW91dC5nZXRMYXlvdXRJbmZvKGN1ci5rZXkpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9hcHBseUxheW91dEluZm8odmlldywgbGF5b3V0SW5mbykpIHVwZGF0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEFwcGx5IGZpbmFsIGxheW91dCBpbmZvcyBmb3Igdmlld3MgdGhhdCB3aWxsIGJlIHJlbW92ZWRcbiAgICAgICAgaWYgKHRoaXMuX3RyYW5zYWN0aW9uKSB7XG4gICAgICAgICAgICBmb3IgKGxldCB2aWV3IG9mIHRoaXMuX3RyYW5zYWN0aW9uLnRvUmVtb3ZlLnZhbHVlcygpKXtcbiAgICAgICAgICAgICAgICBsZXQgY3VyID0gdmlldy5sYXlvdXRJbmZvO1xuICAgICAgICAgICAgICAgIGlmICgoY3VyID09PSBudWxsIHx8IGN1ciA9PT0gdm9pZCAwID8gdm9pZCAwIDogY3VyLmtleSkgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbGF5b3V0SW5mbyA9IHRoaXMubGF5b3V0LmdldExheW91dEluZm8oY3VyLmtleSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9hcHBseUxheW91dEluZm8odmlldywgbGF5b3V0SW5mbykpIHVwZGF0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAobGV0IHZpZXcgb2YgdGhpcy5fdHJhbnNhY3Rpb24ucmVtb3ZlZC52YWx1ZXMoKSl7XG4gICAgICAgICAgICAgICAgbGV0IGN1ciA9IHZpZXcubGF5b3V0SW5mbztcbiAgICAgICAgICAgICAgICBsZXQgbGF5b3V0SW5mbyA9IHRoaXMuX3RyYW5zYWN0aW9uLmZpbmFsTGF5b3V0SW5mby5nZXQoY3VyLmtleSkgfHwgY3VyO1xuICAgICAgICAgICAgICAgIGxheW91dEluZm8gPSB0aGlzLmxheW91dC5nZXRGaW5hbExheW91dEluZm8obGF5b3V0SW5mby5jb3B5KCkpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9hcHBseUxheW91dEluZm8odmlldywgbGF5b3V0SW5mbykpIHVwZGF0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh1cGRhdGVkKSB0aGlzLl9mbHVzaFZpc2libGVWaWV3cygpO1xuICAgIH1cbiAgICBfaGFzTGF5b3V0VXBkYXRlcygpIHtcbiAgICAgICAgaWYgKCF0aGlzLl90cmFuc2FjdGlvbikgcmV0dXJuIGZhbHNlO1xuICAgICAgICBmb3IgKGxldCB2aWV3IG9mIHRoaXMuX3Zpc2libGVWaWV3cy52YWx1ZXMoKSl7XG4gICAgICAgICAgICBsZXQgY3VyID0gdmlldy5sYXlvdXRJbmZvO1xuICAgICAgICAgICAgaWYgKCFjdXIpIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgbGV0IGxheW91dEluZm8gPSB0aGlzLmxheW91dC5nZXRMYXlvdXRJbmZvKGN1ci5rZXkpO1xuICAgICAgICAgICAgaWYgKC8vIFVzZXMgZXF1YWxzIHJhdGhlciB0aGFuIHBvaW50RXF1YWxzIHNvIHRoYXQgd2lkdGgvaGVpZ2h0IGNoYW5nZXMgYXJlIHRha2VuIGludG8gYWNjb3VudFxuICAgICAgICAgICAgIWN1ci5yZWN0LmVxdWFscyhsYXlvdXRJbmZvLnJlY3QpIHx8IGN1ci5vcGFjaXR5ICE9PSBsYXlvdXRJbmZvLm9wYWNpdHkgfHwgY3VyLnRyYW5zZm9ybSAhPT0gbGF5b3V0SW5mby50cmFuc2Zvcm0pIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV1c2VWaWV3KHZpZXcpIHtcbiAgICAgICAgdmlldy5wcmVwYXJlRm9yUmV1c2UoKTtcbiAgICAgICAgdGhpcy5fcmV1c2FibGVWaWV3c1t2aWV3LnZpZXdUeXBlXS5wdXNoKHZpZXcpO1xuICAgIH1cbiAgICByZW1vdmVWaWV3cyh0b1JlbW92ZSkge1xuICAgICAgICBmb3IgKGxldCB2aWV3IG9mIHRvUmVtb3ZlKXRoaXMuX2NoaWxkcmVuLmRlbGV0ZSh2aWV3KTtcbiAgICB9XG4gICAgdXBkYXRlSXRlbVNpemUoa2V5LCBzaXplKSB7XG4gICAgICAgIC8vIFRPRE86IHdlIHNob3VsZCBiZSBhYmxlIHRvIGludmFsaWRhdGUgYSBzaW5nbGUgaW5kZXggcGF0aFxuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIGlmICghdGhpcy5sYXlvdXQudXBkYXRlSXRlbVNpemUpIHJldHVybjtcbiAgICAgICAgLy8gSWYgdGhlIHNjcm9sbCBwb3NpdGlvbiBpcyBjdXJyZW50bHkgYW5pbWF0aW5nLCBhZGQgdGhlIHVwZGF0ZVxuICAgICAgICAvLyB0byBhIHF1ZXVlIHRvIGJlIHByb2Nlc3NlZCBhZnRlciB0aGUgYW5pbWF0aW9uIGlzIGNvbXBsZXRlLlxuICAgICAgICBpZiAodGhpcy5fc2Nyb2xsQW5pbWF0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLl9zaXplVXBkYXRlUXVldWUuc2V0KGtleSwgc2l6ZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBsZXQgY2hhbmdlZCA9IHRoaXMubGF5b3V0LnVwZGF0ZUl0ZW1TaXplKGtleSwgc2l6ZSk7XG4gICAgICAgIGlmIChjaGFuZ2VkKSB0aGlzLnJlbGF5b3V0KCk7XG4gICAgfVxuICAgIHN0YXJ0U2Nyb2xsaW5nKCkge1xuICAgICAgICB0aGlzLl9pc1Njcm9sbGluZyA9IHRydWU7XG4gICAgfVxuICAgIGVuZFNjcm9sbGluZygpIHtcbiAgICAgICAgdGhpcy5faXNTY3JvbGxpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fY29ycmVjdEl0ZW1PcmRlcigpO1xuICAgICAgICB0aGlzLl9mbHVzaFZpc2libGVWaWV3cygpO1xuICAgIH1cbiAgICBfcmVzZXRBbmltYXRlZENvbnRlbnRPZmZzZXQoKSB7XG4gICAgICAgIC8vIFJlc2V0IHRoZSBhbmltYXRlZCBjb250ZW50IG9mZnNldCBvZiBzdWJ2aWV3cy4gU2VlIGNvbW1lbnQgaW4gcmVsYXlvdXROb3cgZm9yIGRldGFpbHMuXG4gICAgICAgIGlmICghdGhpcy5fYW5pbWF0ZWRDb250ZW50T2Zmc2V0LmlzT3JpZ2luKCkpIHtcbiAgICAgICAgICAgIHRoaXMuX2FuaW1hdGVkQ29udGVudE9mZnNldCA9IG5ldyAoMCwgJDMwNDFkYjMyOTY5NDVlNmUkZXhwb3J0JGJhZjI2MTQ2YTQxNGYyNGEpKDAsIDApO1xuICAgICAgICAgICAgdGhpcy5fYXBwbHlMYXlvdXRJbmZvcygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgKiBTY3JvbGxzIHRoZSBpdGVtIHdpdGggdGhlIGdpdmVuIGtleSBpbnRvIHZpZXcsIG9wdGlvbmFsbHkgd2l0aCBhbiBhbmltYXRpb24uXG4gICAqIEBwYXJhbSBrZXkgVGhlIGtleSBvZiB0aGUgaXRlbSB0byBzY3JvbGwgaW50byB2aWV3LlxuICAgKiBAcGFyYW0gZHVyYXRpb24gVGhlIGR1cmF0aW9uIG9mIHRoZSBzY3JvbGwgYW5pbWF0aW9uLlxuICAgKi8gc2Nyb2xsVG9JdGVtKGtleSwgb3B0aW9ucykge1xuICAgICAgICAvLyBrZXkgY2FuIGJlIDAsIHNvIGNoZWNrIGlmIG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgIGlmIChrZXkgPT0gbnVsbCkgcmV0dXJuO1xuICAgICAgICBsZXQgbGF5b3V0SW5mbyA9IHRoaXMubGF5b3V0LmdldExheW91dEluZm8oa2V5KTtcbiAgICAgICAgaWYgKCFsYXlvdXRJbmZvKSByZXR1cm47XG4gICAgICAgIGxldCB7IGR1cmF0aW9uOiBkdXJhdGlvbiA9IDMwMCwgc2hvdWxkU2Nyb2xsWDogc2hvdWxkU2Nyb2xsWCA9IHRydWUsIHNob3VsZFNjcm9sbFk6IHNob3VsZFNjcm9sbFkgPSB0cnVlLCBvZmZzZXRYOiBvZmZzZXRYID0gMCwgb2Zmc2V0WTogb2Zmc2V0WSA9IDAgfSA9IG9wdGlvbnM7XG4gICAgICAgIGxldCB4ID0gdGhpcy52aXNpYmxlUmVjdC54O1xuICAgICAgICBsZXQgeSA9IHRoaXMudmlzaWJsZVJlY3QueTtcbiAgICAgICAgbGV0IG1pblggPSBsYXlvdXRJbmZvLnJlY3QueCAtIG9mZnNldFg7XG4gICAgICAgIGxldCBtaW5ZID0gbGF5b3V0SW5mby5yZWN0LnkgLSBvZmZzZXRZO1xuICAgICAgICBsZXQgbWF4WCA9IHggKyB0aGlzLnZpc2libGVSZWN0LndpZHRoO1xuICAgICAgICBsZXQgbWF4WSA9IHkgKyB0aGlzLnZpc2libGVSZWN0LmhlaWdodDtcbiAgICAgICAgaWYgKHNob3VsZFNjcm9sbFgpIHtcbiAgICAgICAgICAgIGlmIChtaW5YIDw9IHggfHwgbWF4WCA9PT0gMCkgeCA9IG1pblg7XG4gICAgICAgICAgICBlbHNlIGlmIChsYXlvdXRJbmZvLnJlY3QubWF4WCA+IG1heFgpIHggKz0gbGF5b3V0SW5mby5yZWN0Lm1heFggLSBtYXhYO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzaG91bGRTY3JvbGxZKSB7XG4gICAgICAgICAgICBpZiAobWluWSA8PSB5IHx8IG1heFkgPT09IDApIHkgPSBtaW5ZO1xuICAgICAgICAgICAgZWxzZSBpZiAobGF5b3V0SW5mby5yZWN0Lm1heFkgPiBtYXhZKSB5ICs9IGxheW91dEluZm8ucmVjdC5tYXhZIC0gbWF4WTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5zY3JvbGxUbyhuZXcgKDAsICQzMDQxZGIzMjk2OTQ1ZTZlJGV4cG9ydCRiYWYyNjE0NmE0MTRmMjRhKSh4LCB5KSwgZHVyYXRpb24pO1xuICAgIH1cbiAgICAvKipcbiAgICogUGVyZm9ybXMgYW4gYW5pbWF0ZWQgc2Nyb2xsIHRvIHRoZSBnaXZlbiBvZmZzZXQuXG4gICAqIEBwYXJhbSBvZmZzZXQgLSBUaGUgb2Zmc2V0IHRvIHNjcm9sbCB0by5cbiAgICogQHBhcmFtIGR1cmF0aW9uIFRoZSBkdXJhdGlvbiBvZiB0aGUgYW5pbWF0aW9uLlxuICAgKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aGVuIHRoZSBhbmltYXRpb24gaXMgY29tcGxldGUuXG4gICAqLyBzY3JvbGxUbyhvZmZzZXQsIGR1cmF0aW9uID0gMzAwKSB7XG4gICAgICAgIC8vIENhbmNlbCB0aGUgY3VycmVudCBzY3JvbGwgYW5pbWF0aW9uXG4gICAgICAgIGlmICh0aGlzLl9zY3JvbGxBbmltYXRpb24pIHtcbiAgICAgICAgICAgIHRoaXMuX3Njcm9sbEFuaW1hdGlvbi5jYW5jZWwoKTtcbiAgICAgICAgICAgIHRoaXMuX3Njcm9sbEFuaW1hdGlvbiA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2V0IHRoZSBjb250ZW50IG9mZnNldCBzeW5jaHJvbm91c2x5IGlmIHRoZSBkdXJhdGlvbiBpcyB6ZXJvXG4gICAgICAgIGlmIChkdXJhdGlvbiA8PSAwIHx8IHRoaXMudmlzaWJsZVJlY3QucG9pbnRFcXVhbHMob2Zmc2V0KSkge1xuICAgICAgICAgICAgdGhpcy5fc2V0Q29udGVudE9mZnNldChvZmZzZXQpO1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RhcnRTY3JvbGxpbmcoKTtcbiAgICAgICAgdGhpcy5fc2Nyb2xsQW5pbWF0aW9uID0gKDAsICQzZWIxMzFkY2YzN2FkNWY4JGV4cG9ydCRkYzBiNjM3MjA3ODgwOTBjKSh0aGlzLnZpc2libGVSZWN0LCBvZmZzZXQsIGR1cmF0aW9uLCAoMCwgJDNlYjEzMWRjZjM3YWQ1ZjgkZXhwb3J0JDU3NjM2YmI0M2IxY2NiYjApLCAob2Zmc2V0KT0+e1xuICAgICAgICAgICAgdGhpcy5fc2V0Q29udGVudE9mZnNldChvZmZzZXQpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fc2Nyb2xsQW5pbWF0aW9uLnRoZW4oKCk9PntcbiAgICAgICAgICAgIHRoaXMuX3Njcm9sbEFuaW1hdGlvbiA9IG51bGw7XG4gICAgICAgICAgICAvLyBQcm9jZXNzIHZpZXcgc2l6ZSB1cGRhdGVzIHRoYXQgb2NjdXJyZWQgZHVyaW5nIHRoZSBhbmltYXRpb24uXG4gICAgICAgICAgICAvLyBPbmx5IHZpZXdzIHRoYXQgYXJlIHN0aWxsIHZpc2libGUgd2lsbCBiZSBhY3R1YWxseSB1cGRhdGVkLlxuICAgICAgICAgICAgZm9yIChsZXQgW2tleSwgc2l6ZV0gb2YgdGhpcy5fc2l6ZVVwZGF0ZVF1ZXVlKXRoaXMudXBkYXRlSXRlbVNpemUoa2V5LCBzaXplKTtcbiAgICAgICAgICAgIHRoaXMuX3NpemVVcGRhdGVRdWV1ZS5jbGVhcigpO1xuICAgICAgICAgICAgdGhpcy5yZWxheW91dCgpO1xuICAgICAgICAgICAgdGhpcy5fcHJvY2Vzc1RyYW5zYWN0aW9uUXVldWUoKTtcbiAgICAgICAgICAgIHRoaXMuZW5kU2Nyb2xsaW5nKCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcy5fc2Nyb2xsQW5pbWF0aW9uO1xuICAgIH1cbiAgICBfcnVuVHJhbnNhY3Rpb24oYWN0aW9uLCBhbmltYXRlZCkge1xuICAgICAgICB0aGlzLl9zdGFydFRyYW5zYWN0aW9uKCk7XG4gICAgICAgIGlmICh0aGlzLl9uZXh0VHJhbnNhY3Rpb24pIHRoaXMuX25leHRUcmFuc2FjdGlvbi5hY3Rpb25zLnB1c2goYWN0aW9uKTtcbiAgICAgICAgdGhpcy5fZW5kVHJhbnNhY3Rpb24oYW5pbWF0ZWQpO1xuICAgIH1cbiAgICBfc3RhcnRUcmFuc2FjdGlvbigpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9uZXh0VHJhbnNhY3Rpb24pIHRoaXMuX25leHRUcmFuc2FjdGlvbiA9IG5ldyAoMCwgJDhlMTM1ZTUzMWQ4ZGNiNjYkZXhwb3J0JGZlYmM1NTczYzc1Y2VmYjApO1xuICAgICAgICB0aGlzLl9uZXh0VHJhbnNhY3Rpb24ubGV2ZWwrKztcbiAgICB9XG4gICAgX2VuZFRyYW5zYWN0aW9uKGFuaW1hdGVkKSB7XG4gICAgICAgIGlmICghdGhpcy5fbmV4dFRyYW5zYWN0aW9uKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIC8vIFNhdmUgd2hldGhlciB0aGUgdHJhbnNhY3Rpb24gc2hvdWxkIGJlIGFuaW1hdGVkLlxuICAgICAgICBpZiAoYW5pbWF0ZWQgIT0gbnVsbCkgdGhpcy5fbmV4dFRyYW5zYWN0aW9uLmFuaW1hdGVkID0gYW5pbWF0ZWQ7XG4gICAgICAgIC8vIElmIHdlIGhhdmVuJ3QgcmVhY2hlZCBsZXZlbCAwLCB3ZSBhcmUgc3RpbGwgaW4gYVxuICAgICAgICAvLyBuZXN0ZWQgdHJhbnNhY3Rpb24uIFdhaXQgZm9yIHRoZSBwYXJlbnQgdG8gZW5kLlxuICAgICAgICBpZiAoLS10aGlzLl9uZXh0VHJhbnNhY3Rpb24ubGV2ZWwgPiAwKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIC8vIERvIG5vdGhpbmcgZm9yIGVtcHR5IHRyYW5zYWN0aW9uc1xuICAgICAgICBpZiAodGhpcy5fbmV4dFRyYW5zYWN0aW9uLmFjdGlvbnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLl9uZXh0VHJhbnNhY3Rpb24gPSBudWxsO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIERlZmF1bHQgYW5pbWF0aW9ucyB0byB0cnVlXG4gICAgICAgIGlmICh0aGlzLl9uZXh0VHJhbnNhY3Rpb24uYW5pbWF0ZWQgPT0gbnVsbCkgdGhpcy5fbmV4dFRyYW5zYWN0aW9uLmFuaW1hdGVkID0gdHJ1ZTtcbiAgICAgICAgLy8gRW5xdWV1ZSB0aGUgdHJhbnNhY3Rpb25cbiAgICAgICAgdGhpcy5fdHJhbnNhY3Rpb25RdWV1ZS5wdXNoKHRoaXMuX25leHRUcmFuc2FjdGlvbik7XG4gICAgICAgIHRoaXMuX25leHRUcmFuc2FjdGlvbiA9IG51bGw7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBfcHJvY2Vzc1RyYW5zYWN0aW9uUXVldWUoKSB7XG4gICAgICAgIC8vIElmIHRoZSBjdXJyZW50IHRyYW5zYWN0aW9uIGlzIGFuaW1hdGluZywgd2FpdCB1bnRpbCB0aGUgZW5kXG4gICAgICAgIC8vIHRvIHByb2Nlc3MgdGhlIG5leHQgdHJhbnNhY3Rpb24uXG4gICAgICAgIGlmICh0aGlzLl90cmFuc2FjdGlvbiB8fCB0aGlzLl9zY3JvbGxBbmltYXRpb24pIHJldHVybjtcbiAgICAgICAgbGV0IG5leHQgPSB0aGlzLl90cmFuc2FjdGlvblF1ZXVlLnNoaWZ0KCk7XG4gICAgICAgIGlmIChuZXh0KSB0aGlzLl9wZXJmb3JtVHJhbnNhY3Rpb24obmV4dCk7XG4gICAgfVxuICAgIF9nZXRDb250ZW50UmVjdCgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyAoMCwgJDYwNDIzZjkyYzdmOWFkODckZXhwb3J0JGM3OWZjNjQ5MmYzYWYxM2QpKDAsIDAsIHRoaXMuY29udGVudFNpemUud2lkdGgsIHRoaXMuY29udGVudFNpemUuaGVpZ2h0KTtcbiAgICB9XG4gICAgX3BlcmZvcm1UcmFuc2FjdGlvbih0cmFuc2FjdGlvbikge1xuICAgICAgICB0aGlzLl90cmFuc2FjdGlvbiA9IHRyYW5zYWN0aW9uO1xuICAgICAgICB0aGlzLnJlbGF5b3V0Tm93KHtcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uOiB0cmFuc2FjdGlvbixcbiAgICAgICAgICAgIGFuaW1hdGVkOiB0cmFuc2FjdGlvbi5hbmltYXRlZCxcbiAgICAgICAgICAgIGJlZm9yZUxheW91dDogKCk9PntcbiAgICAgICAgICAgICAgICAvLyBHZXQgdGhlIGluaXRpYWwgbGF5b3V0IGluZm9zIGZvciBhbGwgdmlld3MgYmVmb3JlIHRoZSB1cGRhdGVzXG4gICAgICAgICAgICAgICAgLy8gc28gd2UgY2FuIGZpZ3VyZSBvdXQgd2hpY2ggdmlld3MgdG8gYWRkIGFuZCByZW1vdmUuXG4gICAgICAgICAgICAgICAgaWYgKHRyYW5zYWN0aW9uLmFuaW1hdGVkKSB0cmFuc2FjdGlvbi5pbml0aWFsTWFwID0gdGhpcy5fZ2V0TGF5b3V0SW5mb01hcCh0aGlzLl9nZXRDb250ZW50UmVjdCgpLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAvLyBBcHBseSB0aGUgYWN0aW9ucyB0aGF0IG9jY3VycmVkIGR1cmluZyB0aGlzIHRyYW5zYWN0aW9uXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgYWN0aW9uIG9mIHRyYW5zYWN0aW9uLmFjdGlvbnMpYWN0aW9uKCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYWZ0ZXJMYXlvdXQ6ICgpPT57XG4gICAgICAgICAgICAgICAgLy8gR2V0IHRoZSBmaW5hbCBsYXlvdXQgaW5mb3MgYWZ0ZXIgdGhlIHVwZGF0ZXNcbiAgICAgICAgICAgICAgICBpZiAodHJhbnNhY3Rpb24uYW5pbWF0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNhY3Rpb24uZmluYWxNYXAgPSB0aGlzLl9nZXRMYXlvdXRJbmZvTWFwKHRoaXMuX2dldENvbnRlbnRSZWN0KCkpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zZXR1cFRyYW5zYWN0aW9uQW5pbWF0aW9ucyh0cmFuc2FjdGlvbik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHRoaXMuX3RyYW5zYWN0aW9uID0gbnVsbDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhZnRlckFuaW1hdGlvbjogKCk9PntcbiAgICAgICAgICAgICAgICAvLyBSZW1vdmUgYW5kIHJldXNlIHZpZXdzIHdoZW4gYW5pbWF0aW9ucyBhcmUgZG9uZVxuICAgICAgICAgICAgICAgIGlmICh0cmFuc2FjdGlvbi50b1JlbW92ZS5zaXplID4gMCB8fCB0cmFuc2FjdGlvbi5yZW1vdmVkLnNpemUgPiAwKSBmb3IgKGxldCB2aWV3IG9mICgwLCAkZmMzNmY5YTA0NmE5Y2U3OSRleHBvcnQkY2ZjMTQwODhkZmVmY2U1ZikodHJhbnNhY3Rpb24udG9SZW1vdmUudmFsdWVzKCksIHRyYW5zYWN0aW9uLnJlbW92ZWQudmFsdWVzKCkpKXtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2hpbGRyZW4uZGVsZXRlKHZpZXcpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJldXNlVmlldyh2aWV3KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5fdHJhbnNhY3Rpb24gPSBudWxsO1xuICAgICAgICAgICAgICAgIC8vIEVuc3VyZSBET00gb3JkZXIgaXMgY29ycmVjdCBmb3IgYWNjZXNzaWJpbGl0eSBhZnRlciBhbmltYXRpb25zIGFyZSBjb21wbGV0ZVxuICAgICAgICAgICAgICAgIHRoaXMuX2NvcnJlY3RJdGVtT3JkZXIoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9mbHVzaFZpc2libGVWaWV3cygpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3Byb2Nlc3NUcmFuc2FjdGlvblF1ZXVlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfc2V0dXBUcmFuc2FjdGlvbkFuaW1hdGlvbnModHJhbnNhY3Rpb24pIHtcbiAgICAgICAgbGV0IHsgaW5pdGlhbE1hcDogaW5pdGlhbE1hcCwgZmluYWxNYXA6IGZpbmFsTWFwIH0gPSB0cmFuc2FjdGlvbjtcbiAgICAgICAgLy8gU3RvcmUgaW5pdGlhbCBhbmQgZmluYWwgbGF5b3V0IGluZm9zIGZvciBhbmltYXRpb25zXG4gICAgICAgIGZvciAobGV0IFtrZXksIGxheW91dEluZm9dIG9mIGluaXRpYWxNYXApaWYgKGZpbmFsTWFwLmhhcyhrZXkpKSAvLyBTdG9yZSB0aGUgaW5pdGlhbCBsYXlvdXQgaW5mbyBmb3IgdXNlIGR1cmluZyBhbmltYXRpb25zLlxuICAgICAgICB0cmFuc2FjdGlvbi5pbml0aWFsTGF5b3V0SW5mby5zZXQoa2V5LCBsYXlvdXRJbmZvKTtcbiAgICAgICAgZWxzZSAvLyBUaGlzIHZpZXcgd2FzIHJlbW92ZWQuIFN0b3JlIHRoZSBsYXlvdXQgaW5mbyBmb3IgdXNlXG4gICAgICAgIC8vIGluIExheW91dCNnZXRGaW5hbExheW91dEluZm8gZHVyaW5nIGFuaW1hdGlvbnMuXG4gICAgICAgIHRyYW5zYWN0aW9uLmZpbmFsTGF5b3V0SW5mby5zZXQobGF5b3V0SW5mby5rZXksIGxheW91dEluZm8pO1xuICAgICAgICAvLyBHZXQgaW5pdGlhbCBsYXlvdXQgaW5mb3MgZm9yIHZpZXdzIHRoYXQgd2VyZSBhZGRlZFxuICAgICAgICBmb3IgKGxldCBba2V5LCBsYXlvdXRJbmZvXSBvZiBmaW5hbE1hcClpZiAoIWluaXRpYWxNYXAuaGFzKGtleSkpIHtcbiAgICAgICAgICAgIGxldCBpbml0aWFsTGF5b3V0SW5mbyA9IHRoaXMubGF5b3V0LmdldEluaXRpYWxMYXlvdXRJbmZvKGxheW91dEluZm8uY29weSgpKTtcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uLmluaXRpYWxMYXlvdXRJbmZvLnNldChrZXksIGluaXRpYWxMYXlvdXRJbmZvKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBGaWd1cmUgb3V0IHdoaWNoIHZpZXdzIHdlcmUgcmVtb3ZlZC5cbiAgICAgICAgZm9yIChsZXQgW2tleSwgdmlld10gb2YgdGhpcy5fdmlzaWJsZVZpZXdzKS8vIElmIGFuIGl0ZW0gaGFzIGEgd2lkdGggb2YgMCwgdGhlcmUgaXMgbm8gbmVlZCB0byByZW1vdmUgaXQgZnJvbSB0aGUgX3Zpc2libGVWaWV3cy5cbiAgICAgICAgLy8gUmVtb3ZpbmcgYW4gaXRlbSB3aXRoICB3aWR0aCBvZiAwIGNhbiBjYXVzZSBhIGxvb3Agd2hlcmUgdGhlIGl0ZW0gZ2V0cyBhZGRlZCwgcmVtb3ZlZCxcbiAgICAgICAgLy8gYWRkZWQsIHJlbW92ZWQuLi4gZXRjIGluIGEgbG9vcC5cbiAgICAgICAgaWYgKCFmaW5hbE1hcC5oYXMoa2V5KSAmJiB2aWV3LmxheW91dEluZm8ucmVjdC53aWR0aCA+IDApIHtcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uLnJlbW92ZWQuc2V0KGtleSwgdmlldyk7XG4gICAgICAgICAgICB0aGlzLl92aXNpYmxlVmlld3MuZGVsZXRlKGtleSk7XG4gICAgICAgICAgICAvLyBJbiBjYXNlIHNvbWV0aGluZyB3ZWlyZCBoYXBwZW5lZCwgd2hlcmUgd2UgaGF2ZSBhIHZpZXcgYnV0IG5vXG4gICAgICAgICAgICAvLyBpbml0aWFsIGxheW91dCBpbmZvLCB1c2UgdGhlIG9uZSBhdHRhY2hlZCB0byB0aGUgdmlldy5cbiAgICAgICAgICAgIGlmICh2aWV3LmxheW91dEluZm8pIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRyYW5zYWN0aW9uLmZpbmFsTGF5b3V0SW5mby5oYXModmlldy5sYXlvdXRJbmZvLmtleSkpIHRyYW5zYWN0aW9uLmZpbmFsTGF5b3V0SW5mby5zZXQodmlldy5sYXlvdXRJbmZvLmtleSwgdmlldy5sYXlvdXRJbmZvKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pe1xuICAgICAgICB0aGlzLl9jb250ZW50U2l6ZSA9IG5ldyAoMCwgJGVlMWJmYTkwYTk1N2ZiOGEkZXhwb3J0JGNiNmRhODljNmFmMWE4ZWMpO1xuICAgICAgICB0aGlzLl92aXNpYmxlUmVjdCA9IG5ldyAoMCwgJDYwNDIzZjkyYzdmOWFkODckZXhwb3J0JGM3OWZjNjQ5MmYzYWYxM2QpO1xuICAgICAgICB0aGlzLl9yZXVzYWJsZVZpZXdzID0ge307XG4gICAgICAgIHRoaXMuX3Zpc2libGVMYXlvdXRJbmZvcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5fdmlzaWJsZVZpZXdzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl9yZW5kZXJlZENvbnRlbnQgPSBuZXcgV2Vha01hcCgpO1xuICAgICAgICB0aGlzLl9jaGlsZHJlbiA9IG5ldyBTZXQoKTtcbiAgICAgICAgdGhpcy5faW52YWxpZGF0aW9uQ29udGV4dCA9IG51bGw7XG4gICAgICAgIHRoaXMuX292ZXJzY2FuTWFuYWdlciA9IG5ldyAoMCwgJDM2NDE5MWIzZGVjZjM2OTckZXhwb3J0JDQ0NTVlZTZhZmIzOGRjYmIpKCk7XG4gICAgICAgIHRoaXMuX3BlcnNpc3RlZEtleXMgPSBuZXcgU2V0KCk7XG4gICAgICAgIHRoaXMuX3Njcm9sbEFuaW1hdGlvbiA9IG51bGw7XG4gICAgICAgIHRoaXMuX2lzU2Nyb2xsaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3NpemVVcGRhdGVRdWV1ZSA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5fYW5pbWF0ZWRDb250ZW50T2Zmc2V0ID0gbmV3ICgwLCAkMzA0MWRiMzI5Njk0NWU2ZSRleHBvcnQkYmFmMjYxNDZhNDE0ZjI0YSkoMCwgMCk7XG4gICAgICAgIHRoaXMuX3RyYW5zYWN0aW9uID0gbnVsbDtcbiAgICAgICAgdGhpcy5fbmV4dFRyYW5zYWN0aW9uID0gbnVsbDtcbiAgICAgICAgdGhpcy5fdHJhbnNhY3Rpb25RdWV1ZSA9IFtdO1xuICAgICAgICB2YXIgX29wdGlvbnNfdHJhbnNpdGlvbkR1cmF0aW9uO1xuICAgICAgICAvLyBTZXQgb3B0aW9ucyBmcm9tIHBhc3NlZCBvYmplY3QgaWYgZ2l2ZW5cbiAgICAgICAgdGhpcy50cmFuc2l0aW9uRHVyYXRpb24gPSAoX29wdGlvbnNfdHJhbnNpdGlvbkR1cmF0aW9uID0gb3B0aW9ucy50cmFuc2l0aW9uRHVyYXRpb24pICE9PSBudWxsICYmIF9vcHRpb25zX3RyYW5zaXRpb25EdXJhdGlvbiAhPT0gdm9pZCAwID8gX29wdGlvbnNfdHJhbnNpdGlvbkR1cmF0aW9uIDogNTAwO1xuICAgICAgICB0aGlzLmFuY2hvclNjcm9sbFBvc2l0aW9uID0gb3B0aW9ucy5hbmNob3JTY3JvbGxQb3NpdGlvbiB8fCBmYWxzZTtcbiAgICAgICAgdGhpcy5hbmNob3JTY3JvbGxQb3NpdGlvbkF0VG9wID0gb3B0aW9ucy5hbmNob3JTY3JvbGxQb3NpdGlvbkF0VG9wIHx8IGZhbHNlO1xuICAgICAgICB0aGlzLnNob3VsZE92ZXJzY2FuID0gb3B0aW9ucy5zaG91bGRPdmVyc2NhbiAhPT0gZmFsc2U7XG4gICAgICAgIGZvciAobGV0IGtleSBvZiBbXG4gICAgICAgICAgICBcImRlbGVnYXRlXCIsXG4gICAgICAgICAgICBcInNpemVcIixcbiAgICAgICAgICAgIFwibGF5b3V0XCIsXG4gICAgICAgICAgICBcImNvbGxlY3Rpb25cIlxuICAgICAgICBdKWlmIChvcHRpb25zW2tleV0pIHRoaXNba2V5XSA9IG9wdGlvbnNba2V5XTtcbiAgICB9XG59XG5cblxuZnVuY3Rpb24gJGZjMGIxM2I0ODRhYzExOTQkZXhwb3J0JDE1MDVkYjgyZmUzNTdlNjUob3B0cykge1xuICAgIGxldCBbdmlzaWJsZVZpZXdzLCBzZXRWaXNpYmxlVmlld3NdID0gKDAsICQ4RDNuciR1c2VTdGF0ZSkoW10pO1xuICAgIGxldCBbY29udGVudFNpemUsIHNldENvbnRlbnRTaXplXSA9ICgwLCAkOEQzbnIkdXNlU3RhdGUpKG5ldyAoMCwgJGVlMWJmYTkwYTk1N2ZiOGEkZXhwb3J0JGNiNmRhODljNmFmMWE4ZWMpKCkpO1xuICAgIGxldCBbaXNBbmltYXRpbmcsIHNldEFuaW1hdGluZ10gPSAoMCwgJDhEM25yJHVzZVN0YXRlKShmYWxzZSk7XG4gICAgbGV0IFtpc1Njcm9sbGluZywgc2V0U2Nyb2xsaW5nXSA9ICgwLCAkOEQzbnIkdXNlU3RhdGUpKGZhbHNlKTtcbiAgICBsZXQgdmlydHVhbGl6ZXIgPSAoMCwgJDhEM25yJHVzZU1lbW8pKCgpPT5uZXcgKDAsICQzOGI5NDkwYzFjY2E4ZmM0JGV4cG9ydCQ4OWJlNWEyNDNlNTljNGIyKSgpLCBbXSk7XG4gICAgdmlydHVhbGl6ZXIuZGVsZWdhdGUgPSB7XG4gICAgICAgIHNldFZpc2libGVWaWV3czogc2V0VmlzaWJsZVZpZXdzLFxuICAgICAgICBzZXRWaXNpYmxlUmVjdCAocmVjdCkge1xuICAgICAgICAgICAgdmlydHVhbGl6ZXIudmlzaWJsZVJlY3QgPSByZWN0O1xuICAgICAgICAgICAgb3B0cy5vblZpc2libGVSZWN0Q2hhbmdlKHJlY3QpO1xuICAgICAgICB9LFxuICAgICAgICBzZXRDb250ZW50U2l6ZTogc2V0Q29udGVudFNpemUsXG4gICAgICAgIHJlbmRlclZpZXc6IG9wdHMucmVuZGVyVmlldyxcbiAgICAgICAgcmVuZGVyV3JhcHBlcjogb3B0cy5yZW5kZXJXcmFwcGVyLFxuICAgICAgICBiZWdpbkFuaW1hdGlvbnM6ICgpPT5zZXRBbmltYXRpbmcodHJ1ZSksXG4gICAgICAgIGVuZEFuaW1hdGlvbnM6ICgpPT5zZXRBbmltYXRpbmcoZmFsc2UpLFxuICAgICAgICBnZXRTY3JvbGxBbmNob3I6IG9wdHMuZ2V0U2Nyb2xsQW5jaG9yXG4gICAgfTtcbiAgICB2aXJ0dWFsaXplci5sYXlvdXQgPSBvcHRzLmxheW91dDtcbiAgICB2aXJ0dWFsaXplci5jb2xsZWN0aW9uID0gb3B0cy5jb2xsZWN0aW9uO1xuICAgIHZpcnR1YWxpemVyLnRyYW5zaXRpb25EdXJhdGlvbiA9IG9wdHMudHJhbnNpdGlvbkR1cmF0aW9uO1xuICAgICgwLCAkOEQzbnIkdXNlTGF5b3V0RWZmZWN0KSgoKT0+e1xuICAgICAgICB2aXJ0dWFsaXplci5hZnRlclJlbmRlcigpO1xuICAgIH0pO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBhcnJvdy1ib2R5LXN0eWxlXG4gICAgKDAsICQ4RDNuciR1c2VFZmZlY3QpKCgpPT57XG4gICAgICAgIHJldHVybiAoKT0+dmlydHVhbGl6ZXIud2lsbFVubW91bnQoKTtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gICAgfSwgW10pO1xuICAgIGxldCBzZXRWaXNpYmxlUmVjdCA9ICgwLCAkOEQzbnIkdXNlQ2FsbGJhY2spKChyZWN0KT0+e1xuICAgICAgICB2aXJ0dWFsaXplci52aXNpYmxlUmVjdCA9IHJlY3Q7XG4gICAgfSwgW1xuICAgICAgICB2aXJ0dWFsaXplclxuICAgIF0pO1xuICAgIGxldCBzdGFydFNjcm9sbGluZyA9ICgwLCAkOEQzbnIkdXNlQ2FsbGJhY2spKCgpPT57XG4gICAgICAgIHZpcnR1YWxpemVyLnN0YXJ0U2Nyb2xsaW5nKCk7XG4gICAgICAgIHNldFNjcm9sbGluZyh0cnVlKTtcbiAgICB9LCBbXG4gICAgICAgIHZpcnR1YWxpemVyXG4gICAgXSk7XG4gICAgbGV0IGVuZFNjcm9sbGluZyA9ICgwLCAkOEQzbnIkdXNlQ2FsbGJhY2spKCgpPT57XG4gICAgICAgIHZpcnR1YWxpemVyLmVuZFNjcm9sbGluZygpO1xuICAgICAgICBzZXRTY3JvbGxpbmcoZmFsc2UpO1xuICAgIH0sIFtcbiAgICAgICAgdmlydHVhbGl6ZXJcbiAgICBdKTtcbiAgICBsZXQgc3RhdGUgPSAoMCwgJDhEM25yJHVzZU1lbW8pKCgpPT4oe1xuICAgICAgICAgICAgdmlydHVhbGl6ZXI6IHZpcnR1YWxpemVyLFxuICAgICAgICAgICAgdmlzaWJsZVZpZXdzOiB2aXNpYmxlVmlld3MsXG4gICAgICAgICAgICBzZXRWaXNpYmxlUmVjdDogc2V0VmlzaWJsZVJlY3QsXG4gICAgICAgICAgICBjb250ZW50U2l6ZTogY29udGVudFNpemUsXG4gICAgICAgICAgICBpc0FuaW1hdGluZzogaXNBbmltYXRpbmcsXG4gICAgICAgICAgICBpc1Njcm9sbGluZzogaXNTY3JvbGxpbmcsXG4gICAgICAgICAgICBzdGFydFNjcm9sbGluZzogc3RhcnRTY3JvbGxpbmcsXG4gICAgICAgICAgICBlbmRTY3JvbGxpbmc6IGVuZFNjcm9sbGluZ1xuICAgICAgICB9KSwgW1xuICAgICAgICB2aXJ0dWFsaXplcixcbiAgICAgICAgdmlzaWJsZVZpZXdzLFxuICAgICAgICBzZXRWaXNpYmxlUmVjdCxcbiAgICAgICAgY29udGVudFNpemUsXG4gICAgICAgIGlzQW5pbWF0aW5nLFxuICAgICAgICBpc1Njcm9sbGluZyxcbiAgICAgICAgc3RhcnRTY3JvbGxpbmcsXG4gICAgICAgIGVuZFNjcm9sbGluZ1xuICAgIF0pO1xuICAgIHJldHVybiBzdGF0ZTtcbn1cblxuXG5cblxuZXhwb3J0IHskYzc0Y2RhN2QzMWFmMTI1MyRleHBvcnQkYzg0NjcxZjQ2ZDZhMWNhIGFzIExheW91dCwgJGQ3ZmQ2MTAwOWMyMWQwYmIkZXhwb3J0JDdlMGVlYjlkYTcwMmEwODUgYXMgTGF5b3V0SW5mbywgJDMwNDFkYjMyOTY5NDVlNmUkZXhwb3J0JGJhZjI2MTQ2YTQxNGYyNGEgYXMgUG9pbnQsICQ2MDQyM2Y5MmM3ZjlhZDg3JGV4cG9ydCRjNzlmYzY0OTJmM2FmMTNkIGFzIFJlY3QsICRlZTFiZmE5MGE5NTdmYjhhJGV4cG9ydCRjYjZkYTg5YzZhZjFhOGVjIGFzIFNpemUsICRhZDFkOThhYThmMGMzMWI0JGV4cG9ydCQxYTUyMjM4ODdjNTYwNDQxIGFzIFJldXNhYmxlVmlldywgJGZjMGIxM2I0ODRhYzExOTQkZXhwb3J0JDE1MDVkYjgyZmUzNTdlNjUgYXMgdXNlVmlydHVhbGl6ZXJTdGF0ZX07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tb2R1bGUuanMubWFwXG4iXSwibmFtZXMiOlsidXNlU3RhdGUiLCIkOEQzbnIkdXNlU3RhdGUiLCJ1c2VNZW1vIiwiJDhEM25yJHVzZU1lbW8iLCJ1c2VFZmZlY3QiLCIkOEQzbnIkdXNlRWZmZWN0IiwidXNlQ2FsbGJhY2siLCIkOEQzbnIkdXNlQ2FsbGJhY2siLCJ1c2VMYXlvdXRFZmZlY3QiLCIkOEQzbnIkdXNlTGF5b3V0RWZmZWN0IiwiJGM3NGNkYTdkMzFhZjEyNTMkZXhwb3J0JGM4NDY3MWY0NmQ2YTFjYSIsInNob3VsZEludmFsaWRhdGUiLCJuZXdSZWN0Iiwib2xkUmVjdCIsIndpZHRoIiwiaGVpZ2h0IiwidmFsaWRhdGUiLCJpbnZhbGlkYXRpb25Db250ZXh0IiwiZ2V0SW5pdGlhbExheW91dEluZm8iLCJsYXlvdXRJbmZvIiwiZ2V0RmluYWxMYXlvdXRJbmZvIiwiJGQ3ZmQ2MTAwOWMyMWQwYmIkZXhwb3J0JDdlMGVlYjlkYTcwMmEwODUiLCJjb3B5IiwicmVzIiwidHlwZSIsImtleSIsInJlY3QiLCJlc3RpbWF0ZWRTaXplIiwib3BhY2l0eSIsInRyYW5zZm9ybSIsInBhcmVudEtleSIsImlzU3RpY2t5IiwiekluZGV4IiwiYWxsb3dPdmVyZmxvdyIsImNvbnN0cnVjdG9yIiwiJDMwNDFkYjMyOTY5NDVlNmUkZXhwb3J0JGJhZjI2MTQ2YTQxNGYyNGEiLCJ4IiwieSIsImVxdWFscyIsInBvaW50IiwiaXNPcmlnaW4iLCIkNjA0MjNmOTJjN2Y5YWQ4NyRleHBvcnQkYzc5ZmM2NDkyZjNhZjEzZCIsIm1heFgiLCJtYXhZIiwiYXJlYSIsInRvcExlZnQiLCJ0b3BSaWdodCIsImJvdHRvbUxlZnQiLCJib3R0b21SaWdodCIsImludGVyc2VjdHMiLCJjb250YWluc1JlY3QiLCJjb250YWluc1BvaW50IiwiZ2V0Q29ybmVySW5SZWN0IiwicG9pbnRFcXVhbHMiLCJzaXplRXF1YWxzIiwic2l6ZSIsInVuaW9uIiwib3RoZXIiLCJNYXRoIiwibWluIiwibWF4IiwiaW50ZXJzZWN0aW9uIiwiJGVlMWJmYTkwYTk1N2ZiOGEkZXhwb3J0JGNiNmRhODljNmFmMWE4ZWMiLCIkYWQxZDk4YWE4ZjBjMzFiNCR2YXIkS0VZIiwiJGFkMWQ5OGFhOGYwYzMxYjQkZXhwb3J0JDFhNTIyMzg4N2M1NjA0NDEiLCJwcmVwYXJlRm9yUmV1c2UiLCJjb250ZW50IiwicmVuZGVyZWQiLCJ2aXJ0dWFsaXplciIsIiQzZWIxMzFkY2YzN2FkNWY4JHZhciRwZXJmIiwid2luZG93IiwicGVyZm9ybWFuY2UiLCIkM2ViMTMxZGNmMzdhZDVmOCR2YXIkcGVyZk5vdyIsIm5vdyIsIndlYmtpdE5vdyIsIm1zTm93IiwibW96Tm93IiwiJDNlYjEzMWRjZjM3YWQ1ZjgkdmFyJGdldFRpbWUiLCJiaW5kIiwiRGF0ZSIsImdldFRpbWUiLCIkM2ViMTMxZGNmMzdhZDVmOCR2YXIkZml4VHMiLCIkM2ViMTMxZGNmMzdhZDVmOCRleHBvcnQkZGMwYjYzNzIwNzg4MDkwYyIsImJlZ2luIiwiZW5kIiwiZHVyYXRpb24iLCJlYXNlIiwiZm4iLCJjYW5jZWxlZCIsInJhZl9pZCIsInByb21pc2UiLCJQcm9taXNlIiwicmVzb2x2ZSIsInN0YXJ0IiwiZGlmZlgiLCJkaWZmWSIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsInJ1biIsInQiLCJkZWx0YSIsInByb2NlZWQiLCJjYW5jZWwiLCJjYW5jZWxBbmltYXRpb25GcmFtZSIsIiQzZWIxMzFkY2YzN2FkNWY4JGV4cG9ydCQ3Nzg2MGMxMDZiNGE2YTJlIiwiJDNlYjEzMWRjZjM3YWQ1ZjgkZXhwb3J0JDU3NjM2YmI0M2IxY2NiYjAiLCJzaW4iLCJQSSIsIiRmYzM2ZjlhMDQ2YTljZTc5JGV4cG9ydCQzN2EyNmIyODNmZDc3NDBlIiwiYSIsImIiLCJTZXQiLCJrZXlzIiwiaGFzIiwiYWRkIiwiJGZjMzZmOWEwNDZhOWNlNzkkZXhwb3J0JGFjYWY5NmEyNzQzODI0NmIiLCJ0b1JlbW92ZSIsInRvQWRkIiwidG9VcGRhdGUiLCIkZmMzNmY5YTA0NmE5Y2U3OSRleHBvcnQkY2ZjMTQwODhkZmVmY2U1ZiIsIml0ZXJhdG9ycyIsIml0ZXJhdG9yIiwiJGZjMzZmOWEwNDZhOWNlNzkkZXhwb3J0JDY4OTdjMjg0YjZmOWY0ZGMiLCJvYmplY3QiLCIkZmMzNmY5YTA0NmE5Y2U3OSRleHBvcnQkYThkMGQwYzhkMWM1ZGY2NCIsIiQzNjQxOTFiM2RlY2YzNjk3JHZhciRSb2xsaW5nQXZlcmFnZSIsImFkZFNhbXBsZSIsInNhbXBsZSIsImNvdW50IiwidmFsdWUiLCIkMzY0MTkxYjNkZWNmMzY5NyRleHBvcnQkNDQ1NWVlNmFmYjM4ZGNiYiIsInNldFZpc2libGVSZWN0IiwidGltZSIsInN0YXJ0VGltZSIsImF2ZXJhZ2VUaW1lIiwidmlzaWJsZVJlY3QiLCJ2ZWxvY2l0eSIsImNvbGxlY3RNZXRyaWNzIiwiYXZlcmFnZVBlcmYiLCJvIiwiYWJzIiwib3ZlcnNjYW5ZIiwib3ZlcnNjYW5YIiwiZ2V0T3ZlcnNjYW5uZWRSZWN0Iiwib3ZlcnNjYW5uZWQiLCJyb3VuZCIsIiQ4ZTEzNWU1MzFkOGRjYjY2JGV4cG9ydCRmZWJjNTU3M2M3NWNlZmIwIiwibGV2ZWwiLCJhY3Rpb25zIiwiYW5pbWF0ZWQiLCJpbml0aWFsTWFwIiwiTWFwIiwiZmluYWxNYXAiLCJpbml0aWFsTGF5b3V0SW5mbyIsImZpbmFsTGF5b3V0SW5mbyIsInJlbW92ZWQiLCIkMzhiOTQ5MGMxY2NhOGZjNCRleHBvcnQkODliZTVhMjQzZTU5YzRiMiIsIl9zZXRDb250ZW50U2l6ZSIsIl9jb250ZW50U2l6ZSIsImRlbGVnYXRlIiwic2V0Q29udGVudFNpemUiLCJfc2V0Q29udGVudE9mZnNldCIsIm9mZnNldCIsIl92aXNpYmxlUmVjdCIsImNvbnRlbnRTaXplIiwiX3NldFZpc2libGVSZWN0IiwiZm9yY2VVcGRhdGUiLCJjdXJyZW50Iiwic2hvdWxkT3ZlcnNjYW4iLCJfb3ZlcnNjYW5NYW5hZ2VyIiwibGF5b3V0IiwiX3Jlc2V0QW5pbWF0ZWRDb250ZW50T2Zmc2V0IiwicmVsYXlvdXROb3ciLCJvZmZzZXRDaGFuZ2VkIiwic2l6ZUNoYW5nZWQiLCJ1cGRhdGVTdWJ2aWV3cyIsImNvbGxlY3Rpb24iLCJfY29sbGVjdGlvbiIsImRhdGEiLCJfc2V0RGF0YSIsIl9ydW5UcmFuc2FjdGlvbiIsInRyYW5zaXRpb25EdXJhdGlvbiIsInJlbG9hZERhdGEiLCJyZWxheW91dCIsImNvbnRlbnRDaGFuZ2VkIiwiZ2V0SXRlbSIsInBlcnNpc3RlZEtleXMiLCJfcGVyc2lzdGVkS2V5cyIsImlzUGVyc2lzdGVkS2V5IiwiayIsImdldExheW91dEluZm8iLCJfbGF5b3V0Iiwic2V0TGF5b3V0IiwiYXBwbHlMYXlvdXQiLCJfZ2V0UmV1c2VUeXBlIiwiZ2V0VHlwZSIsInJldXNlVHlwZSIsImdldFJldXNhYmxlVmlldyIsIl9yZXVzYWJsZVZpZXdzIiwicmV1c2FibGUiLCJ2aWV3IiwibGVuZ3RoIiwicG9wIiwidmlld1R5cGUiLCJfYW5pbWF0ZWRDb250ZW50T2Zmc2V0IiwiX3JlbmRlclZpZXciLCJyZXVzYWJsZVZpZXciLCJfcmVuZGVyQ29udGVudCIsImNhY2hlZCIsIl9yZW5kZXJlZENvbnRlbnQiLCJnZXQiLCJyZW5kZXJWaWV3Iiwic2V0IiwidmlzaWJsZVZpZXdzIiwiQXJyYXkiLCJmcm9tIiwiX3Zpc2libGVWaWV3cyIsInZhbHVlcyIsImdldFZpZXciLCJnZXRWaWV3c09mVHlwZSIsImZpbHRlciIsInYiLCJrZXlGb3JWaWV3Iiwia2V5QXRQb2ludCIsImxheW91dEluZm9zIiwiZ2V0VmlzaWJsZUxheW91dEluZm9zIiwid2lsbFVubW91bnQiLCJfcmVsYXlvdXRSYWYiLCJjb250ZXh0IiwiX3Njcm9sbEFuaW1hdGlvbiIsIl9pbnZhbGlkYXRpb25Db250ZXh0IiwiT2JqZWN0IiwiYXNzaWduIiwic2Nyb2xsQW5jaG9yIiwiX2dldFNjcm9sbEFuY2hvciIsImJlZm9yZUxheW91dCIsImdldENvbnRlbnRTaXplIiwiYWZ0ZXJMYXlvdXQiLCJnZXRWaXNpYmxlUmVjdCIsInJlc3RvcmVkU2Nyb2xsQW5jaG9yIiwiX3Jlc3RvcmVTY3JvbGxBbmNob3IiLCJjb250ZW50T2Zmc2V0WCIsImNvbnRlbnRPZmZzZXRZIiwiaGFzTGF5b3V0VXBkYXRlcyIsInRyYW5zYWN0aW9uIiwiX2FwcGx5TGF5b3V0SW5mb3MiLCJfZW5hYmxlVHJhbnNpdGlvbnMiLCJkb25lIiwiX2Rpc2FibGVUcmFuc2l0aW9ucyIsImFmdGVyQW5pbWF0aW9uIiwic2V0VGltZW91dCIsIl9jb3JyZWN0SXRlbU9yZGVyIiwiX2lzU2Nyb2xsaW5nIiwiX3RyYW5zYWN0aW9uIiwiX3Zpc2libGVMYXlvdXRJbmZvcyIsIl9jaGlsZHJlbiIsImRlbGV0ZSIsImJlZ2luQW5pbWF0aW9ucyIsImVuZEFuaW1hdGlvbnMiLCJhbmNob3JTY3JvbGxQb3NpdGlvbiIsImdldFNjcm9sbEFuY2hvciIsImNvcm5lciIsImFuY2hvclNjcm9sbFBvc2l0aW9uQXRUb3AiLCJjb3JuZXJBbmNob3IiLCJjb250ZW50T2Zmc2V0IiwiX2NvbnRleHRfdHJhbnNhY3Rpb24iLCJmaW5hbEFuY2hvciIsImFkanVzdG1lbnQiLCJfZ2V0TGF5b3V0SW5mb01hcCIsIm1hcCIsInZpc2libGVMYXlvdXRJbmZvcyIsImN1cnJlbnRseVZpc2libGUiLCJpdGVtIiwicmV1c2VWaWV3IiwiX2FwcGx5TGF5b3V0SW5mbyIsInJlbW92ZVZpZXdzIiwiX2ZsdXNoVmlzaWJsZVZpZXdzIiwiX2hhc0xheW91dFVwZGF0ZXMiLCJhZnRlclJlbmRlciIsIl90cmFuc2FjdGlvblF1ZXVlIiwiX3Byb2Nlc3NUcmFuc2FjdGlvblF1ZXVlIiwidmlld3NCeVBhcmVudEtleSIsIl92aWV3X2xheW91dEluZm8iLCJfdmlld3NCeVBhcmVudEtleV9nZXQiLCJfdmlld19sYXlvdXRJbmZvMSIsIl92aWV3X2xheW91dEluZm8yIiwiX3ZpZXdfbGF5b3V0SW5mbzMiLCJwdXNoIiwiYnVpbGRUcmVlIiwicGFyZW50Iiwidmlld3MiLCJjaGlsZHJlbiIsInJlbmRlcldyYXBwZXIiLCJjaGlsZFZpZXdzIiwic2V0VmlzaWJsZVZpZXdzIiwidXBkYXRlZCIsImN1ciIsInVwZGF0ZUl0ZW1TaXplIiwiX3NpemVVcGRhdGVRdWV1ZSIsImNoYW5nZWQiLCJzdGFydFNjcm9sbGluZyIsImVuZFNjcm9sbGluZyIsInNjcm9sbFRvSXRlbSIsIm9wdGlvbnMiLCJzaG91bGRTY3JvbGxYIiwic2hvdWxkU2Nyb2xsWSIsIm9mZnNldFgiLCJvZmZzZXRZIiwibWluWCIsIm1pblkiLCJzY3JvbGxUbyIsInRoZW4iLCJjbGVhciIsImFjdGlvbiIsIl9zdGFydFRyYW5zYWN0aW9uIiwiX25leHRUcmFuc2FjdGlvbiIsIl9lbmRUcmFuc2FjdGlvbiIsIm5leHQiLCJzaGlmdCIsIl9wZXJmb3JtVHJhbnNhY3Rpb24iLCJfZ2V0Q29udGVudFJlY3QiLCJfc2V0dXBUcmFuc2FjdGlvbkFuaW1hdGlvbnMiLCJXZWFrTWFwIiwiX29wdGlvbnNfdHJhbnNpdGlvbkR1cmF0aW9uIiwiJGZjMGIxM2I0ODRhYzExOTQkZXhwb3J0JDE1MDVkYjgyZmUzNTdlNjUiLCJvcHRzIiwiaXNBbmltYXRpbmciLCJzZXRBbmltYXRpbmciLCJpc1Njcm9sbGluZyIsInNldFNjcm9sbGluZyIsIm9uVmlzaWJsZVJlY3RDaGFuZ2UiLCJzdGF0ZSIsIkxheW91dCIsIkxheW91dEluZm8iLCJQb2ludCIsIlJlY3QiLCJTaXplIiwiUmV1c2FibGVWaWV3IiwidXNlVmlydHVhbGl6ZXJTdGF0ZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-stately/virtualizer/dist/import.mjs\n");

/***/ })

};
;